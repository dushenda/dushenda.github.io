<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM相关缩略语</title>
    <url>/2025/12/20/ARM%E7%9B%B8%E5%85%B3/ARM%E7%9B%B8%E5%85%B3%E7%BC%A9%E7%95%A5%E8%AF%AD/</url>
    <content><![CDATA[<blockquote>
<p>转载：https://zhuanlan.zhihu.com/p/1985799288740136627</p>
</blockquote>
<p>ARM 相关缩略语大全（按大类系统整理）<br />
本文系统性整理 <strong>ARM 架构</strong>中常见缩略语，覆盖 <strong>CPU / Core / AMBA / CoreSight / GIC / 内存系统 / 异构与加速 / 安全 / 虚拟化 / SoC 互连</strong> 等多个层面，适合 <strong>内核、驱动、SoC、性能分析、芯片架构</strong> 方向长期查阅。</p>
<p>一、ARM 架构与指令集（Architecture &amp; ISA）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>ARM</td>
<td>Advanced RISC Machines</td>
<td>ARM 公司 / 架构统称</td>
</tr>
<tr class="odd">
<td>ISA</td>
<td>Instruction Set Architecture</td>
<td>指令集架构</td>
</tr>
<tr class="even">
<td>AArch32</td>
<td>ARM Architecture 32-bit</td>
<td>ARMv7 及兼容 32 位执行态</td>
</tr>
<tr class="odd">
<td>AArch64</td>
<td>ARM Architecture 64-bit</td>
<td>ARMv8+ 的 64 位执行态</td>
</tr>
<tr class="even">
<td>ARMv7-A</td>
<td>ARM Architecture v7 Application</td>
<td>经典 32 位应用处理器架构</td>
</tr>
<tr class="odd">
<td>ARMv8-A</td>
<td>ARM Architecture v8 Application</td>
<td>引入 AArch64</td>
</tr>
<tr class="even">
<td>ARMv9-A</td>
<td>ARM Architecture v9 Application</td>
<td>引入 SVE2 / CCA</td>
</tr>
<tr class="odd">
<td>Thumb</td>
<td>Thumb Instruction Set</td>
<td>16-bit 压缩指令集</td>
</tr>
<tr class="even">
<td>Thumb-2</td>
<td>Thumb-2 Instruction Set</td>
<td>16/32 混合指令</td>
</tr>
<tr class="odd">
<td>NEON</td>
<td>Advanced SIMD</td>
<td>ARM 向量 SIMD 扩展</td>
</tr>
<tr class="even">
<td>SVE</td>
<td>Scalable Vector Extension</td>
<td>可变向量长度 SIMD</td>
</tr>
<tr class="odd">
<td>SVE2</td>
<td>SVE v2</td>
<td>面向通用计算与 DSP</td>
</tr>
<tr class="even">
<td>SME</td>
<td>Scalable Matrix Extension</td>
<td>ARMv9 矩阵扩展</td>
</tr>
</tbody>
</table>
<p>二、ARM CPU Core 家族（Processor Cores）<br />
Cortex 系列</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>Cortex-A</td>
<td>Cortex Application</td>
<td>应用处理器（Linux / Android）</td>
</tr>
<tr class="odd">
<td>Cortex-R</td>
<td>Cortex Real-time</td>
<td>实时处理器</td>
</tr>
<tr class="even">
<td>Cortex-M</td>
<td>Cortex Microcontroller</td>
<td>微控制器</td>
</tr>
</tbody>
</table>
<p>Cortex-A 常见核心</p>
<table>
<tbody>
<tr class="odd">
<td>Core</td>
<td>特点</td>
<td>应用</td>
</tr>
<tr class="even">
<td>A53</td>
<td>小核，低功耗</td>
<td>手机 / 嵌入式</td>
</tr>
<tr class="odd">
<td>A55</td>
<td>A53 后继</td>
<td>big.LITTLE</td>
</tr>
<tr class="even">
<td>A57</td>
<td>高性能</td>
<td>服务器 / 手机</td>
</tr>
<tr class="odd">
<td>A72</td>
<td>高 IPC</td>
<td>SoC 主核</td>
</tr>
<tr class="even">
<td>A73</td>
<td>优化能效</td>
<td>移动平台</td>
</tr>
<tr class="odd">
<td>A75</td>
<td>ARMv8.2</td>
<td>DynamIQ</td>
</tr>
<tr class="even">
<td>A76</td>
<td>高性能单核</td>
<td>旗舰 SoC</td>
</tr>
<tr class="odd">
<td>A78</td>
<td>高能效</td>
<td>新一代移动</td>
</tr>
<tr class="even">
<td>X1 / X2 / X3</td>
<td>Cortex-X</td>
<td>极致性能</td>
</tr>
</tbody>
</table>
<p>Neoverse（服务器）</p>
<table>
<tbody>
<tr class="odd">
<td>Core</td>
<td>定位</td>
</tr>
<tr class="even">
<td>N1</td>
<td>通用服务器</td>
</tr>
<tr class="odd">
<td>N2</td>
<td>ARMv9 数据中心</td>
</tr>
<tr class="even">
<td>V1</td>
<td>SVE 向量优化</td>
</tr>
<tr class="odd">
<td>E1</td>
<td>边缘高吞吐</td>
</tr>
</tbody>
</table>
<p>三、异常级别与特权模型（Exception Levels）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>EL0</td>
<td>Exception Level 0</td>
<td>用户态</td>
</tr>
<tr class="odd">
<td>EL1</td>
<td>Exception Level 1</td>
<td>内核态</td>
</tr>
<tr class="even">
<td>EL2</td>
<td>Exception Level 2</td>
<td>Hypervisor</td>
</tr>
<tr class="odd">
<td>EL3</td>
<td>Exception Level 3</td>
<td>Secure Monitor</td>
</tr>
<tr class="even">
<td>PL</td>
<td>Privilege Level</td>
<td>特权等级</td>
</tr>
<tr class="odd">
<td>SPSR</td>
<td>Saved Program Status Register</td>
<td>异常返回寄存器</td>
</tr>
<tr class="even">
<td>ESR</td>
<td>Exception Syndrome Register</td>
<td>异常原因</td>
</tr>
</tbody>
</table>
<p>四、内存系统（Memory System &amp; MMU）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>MMU</td>
<td>Memory Management Unit</td>
<td>内存管理单元</td>
</tr>
<tr class="odd">
<td>SMMU</td>
<td>System Memory Management Unit</td>
<td>系统内存管理单元</td>
</tr>
<tr class="even">
<td>MPU</td>
<td>Memory Protection Unit</td>
<td>无 MMU 系统</td>
</tr>
<tr class="odd">
<td>TLB</td>
<td>Translation Lookaside Buffer</td>
<td>地址翻译缓存</td>
</tr>
<tr class="even">
<td>ASID</td>
<td>Address Space ID</td>
<td>进程地址空间标识</td>
</tr>
<tr class="odd">
<td>VA</td>
<td>Virtual Address</td>
<td>虚拟地址</td>
</tr>
<tr class="even">
<td>PA</td>
<td>Physical Address</td>
<td>物理地址</td>
</tr>
<tr class="odd">
<td>IPA</td>
<td>Intermediate Physical Address</td>
<td>虚拟化中间地址</td>
</tr>
<tr class="even">
<td>TTBR</td>
<td>Translation Table Base Register</td>
<td>页表基址</td>
</tr>
<tr class="odd">
<td>MAIR</td>
<td>Memory Attribute Indirection Register</td>
<td>内存属性</td>
</tr>
<tr class="even">
<td>ATS</td>
<td>Address Translation Service</td>
<td>PCIe 地址翻译</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>五、AMBA 总线与互连（Bus &amp; Interconnect）<br />
AMBA 总线协议</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>AMBA</td>
<td>Advanced Microcontroller Bus Architecture</td>
<td>ARM 总线体系</td>
</tr>
<tr class="odd">
<td>AXI</td>
<td>Advanced eXtensible Interface</td>
<td>高性能总线</td>
</tr>
<tr class="even">
<td>AXI4</td>
<td>AXI version 4</td>
<td>主流 SoC 总线</td>
</tr>
<tr class="odd">
<td>AXI-Lite</td>
<td>AXI Lite</td>
<td>寄存器访问</td>
</tr>
<tr class="even">
<td>AHB</td>
<td>Advanced High-performance Bus</td>
<td>中速总线</td>
</tr>
<tr class="odd">
<td>APB</td>
<td>Advanced Peripheral Bus</td>
<td>低速外设</td>
</tr>
<tr class="even">
<td>CHI</td>
<td>Coherent Hub Interface</td>
<td>Cache Coherent 总线</td>
</tr>
<tr class="odd">
<td>ACE</td>
<td>AXI Coherency Extensions</td>
<td>一致性扩展</td>
</tr>
</tbody>
</table>
<p>互连与一致性</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>说明</td>
<td></td>
</tr>
<tr class="even">
<td>CCN</td>
<td>Cache Coherent Network</td>
<td>一致性网络</td>
</tr>
<tr class="odd">
<td>CMN</td>
<td>Coherent Mesh Network</td>
<td>Mesh 架构</td>
</tr>
<tr class="even">
<td>DVM</td>
<td>Distributed Virtual Memory</td>
<td>TLB 一致性</td>
</tr>
<tr class="odd">
<td>Snoop</td>
<td>Cache Snoop</td>
<td>Cache 探测</td>
</tr>
</tbody>
</table>
<p>六、GIC 中断控制器（Generic Interrupt Controller）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>GIC</td>
<td>Generic Interrupt Controller</td>
<td>ARM 中断控制器</td>
</tr>
<tr class="odd">
<td>GICv2</td>
<td>GIC version 2</td>
<td>ARMv7 常用</td>
</tr>
<tr class="even">
<td>GICv3</td>
<td>GIC version 3</td>
<td>ARMv8 主流</td>
</tr>
<tr class="odd">
<td>GICv4</td>
<td>GIC version 4</td>
<td>虚拟化直通</td>
</tr>
<tr class="even">
<td>SGI</td>
<td>Software Generated Interrupt</td>
<td>软件中断</td>
</tr>
<tr class="odd">
<td>PPI</td>
<td>Private Peripheral Interrupt</td>
<td>CPU 私有中断</td>
</tr>
<tr class="even">
<td>SPI</td>
<td>Shared Peripheral Interrupt</td>
<td>共享中断</td>
</tr>
<tr class="odd">
<td>ITS</td>
<td>Interrupt Translation Service</td>
<td>MSI 映射</td>
</tr>
<tr class="even">
<td>LPI</td>
<td>Locality-specific Peripheral Interrupt</td>
<td>大规模中断</td>
</tr>
</tbody>
</table>
<p>七、CoreSight 调试与追踪（Debug &amp; Trace）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>CoreSight</td>
<td>ARM Debug &amp; Trace 架构</td>
<td>调试体系</td>
</tr>
<tr class="odd">
<td>JTAG</td>
<td>Joint Test Action Group</td>
<td>硬件调试接口</td>
</tr>
<tr class="even">
<td>SWD</td>
<td>Serial Wire Debug</td>
<td>精简调试</td>
</tr>
<tr class="odd">
<td>ETM</td>
<td>Embedded Trace Macrocell</td>
<td>指令追踪</td>
</tr>
<tr class="even">
<td>PTM</td>
<td>Program Trace Macrocell</td>
<td>程序追踪</td>
</tr>
<tr class="odd">
<td>STM</td>
<td>System Trace Macrocell</td>
<td>系统事件追踪</td>
</tr>
<tr class="even">
<td>ITM</td>
<td>Instrumentation Trace Macrocell</td>
<td>软件埋点</td>
</tr>
<tr class="odd">
<td>DWT</td>
<td>Data Watchpoint and Trace</td>
<td>数据监控</td>
</tr>
<tr class="even">
<td>CTI</td>
<td>Cross Trigger Interface</td>
<td>模块联动</td>
</tr>
<tr class="odd">
<td>TPIU</td>
<td>Trace Port Interface Unit</td>
<td>Trace 输出</td>
</tr>
</tbody>
</table>
<p>八、安全架构（Security）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>全称</td>
<td>说明</td>
</tr>
<tr class="even">
<td>TrustZone</td>
<td>ARM TrustZone</td>
<td>安全隔离</td>
</tr>
<tr class="odd">
<td>Secure World</td>
<td>安全世界</td>
<td>TEE</td>
</tr>
<tr class="even">
<td>Normal World</td>
<td>普通世界</td>
<td>REE</td>
</tr>
<tr class="odd">
<td>TEE</td>
<td>Trusted Execution Environment</td>
<td>安全 OS</td>
</tr>
<tr class="even">
<td>OP-TEE</td>
<td>Open Portable TEE</td>
<td>开源 TEE</td>
</tr>
<tr class="odd">
<td>CCA</td>
<td>Confidential Compute Architecture</td>
<td>ARMv9</td>
</tr>
<tr class="even">
<td>RME</td>
<td>Realm Management Extension</td>
<td>Realm 隔离</td>
</tr>
</tbody>
</table>
<p>九、虚拟化（Virtualization）</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>说明</td>
</tr>
<tr class="even">
<td>HYP</td>
<td>Hypervisor 模式</td>
</tr>
<tr class="odd">
<td>VHE</td>
<td>Virtualization Host Extensions</td>
</tr>
<tr class="even">
<td>Stage-2</td>
<td>二级地址翻译</td>
</tr>
<tr class="odd">
<td>VGIC</td>
<td>Virtual GIC</td>
</tr>
<tr class="even">
<td>VCPU</td>
<td>Virtual CPU</td>
</tr>
<tr class="odd">
<td>VMID</td>
<td>Virtual Machine ID</td>
</tr>
</tbody>
</table>
<p>十、SoC / 系统级常见缩略语</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>说明</td>
</tr>
<tr class="even">
<td>SoC</td>
<td>System on Chip</td>
</tr>
<tr class="odd">
<td>PMU</td>
<td>Performance Monitor Unit</td>
</tr>
<tr class="even">
<td>DVFS</td>
<td>Dynamic Voltage and Frequency Scaling</td>
</tr>
<tr class="odd">
<td>QoS</td>
<td>Quality of Service</td>
</tr>
<tr class="even">
<td>NoC</td>
<td>Network on Chip</td>
</tr>
<tr class="odd">
<td>SRAM</td>
<td>Static RAM</td>
</tr>
<tr class="even">
<td>DRAM</td>
<td>Dynamic RAM</td>
</tr>
<tr class="odd">
<td>LPDDR</td>
<td>Low Power DDR</td>
</tr>
</tbody>
</table>
<p>十一、软件与生态</p>
<table>
<tbody>
<tr class="odd">
<td>缩略语</td>
<td>说明</td>
</tr>
<tr class="even">
<td>PSCI</td>
<td>Power State Coordination Interface</td>
</tr>
<tr class="odd">
<td>SMC</td>
<td>Secure Monitor Call</td>
</tr>
<tr class="even">
<td>HVC</td>
<td>Hypervisor Call</td>
</tr>
<tr class="odd">
<td>UEFI</td>
<td>Unified Extensible Firmware Interface</td>
</tr>
<tr class="even">
<td>ACPI</td>
<td>Advanced Configuration and Power Interface</td>
</tr>
<tr class="odd">
<td>DT / DTS</td>
<td>Device Tree / Source</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>ARM</tag>
        <tag>缩略语</tag>
      </tags>
  </entry>
  <entry>
    <title>CsvHelper 使用手册</title>
    <url>/2018/09/04/Csharp/CsvHelper%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="csvhelper-使用手册">CsvHelper 使用手册</h1>
<h2 id="导引">导引</h2>
<h3 id="安装">安装</h3>
<p>在包管理控制台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">PM&gt; </span><span class="language-bash">Install-Package CsvHelper</span></span><br></pre></td></tr></table></figure>
<p>.NET CLI 控制台</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">dotnet add package CsvHelper</span></span><br></pre></td></tr></table></figure>
<h3 id="读一个-csv-文件">读一个 CSV 文件</h3>
<p>首先创建一个这样的 CSV 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID,Name</span><br><span class="line">1,one</span><br><span class="line">2,two</span><br></pre></td></tr></table></figure>
<p>做一个类的定义如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们创建的类的属性名能够匹配目标 CSV 文件的表头，那么我们就无需任何配置的读取这个文件。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;Path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>GetRecords&lt;T&gt;</code> 方法将会返回一个 <code>IEnumerable&lt;T&gt;</code>将会<code>yield</code> records。这也就意味着当你在反复查询记录的时候一次只能返回一条，即仅仅只有文件的一小部分会被读到内存中。不过要小心的是，如果你做了任何关于 LINQ 投影的事情，就像调用 <code>.ToList()</code>，整个文件都会被读入到内存中。 <code>CsvReader</code>只能向前走，所以当你想要运行任何 LINQ 查询来防范你的数据，你需要知道如果这样做的话，整个文件会被加载到内存中。</p>
<p>加入我们对前面的 CSV 文件做了一点点改变，使它与之前的属性不是完全匹配了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id,name</span><br><span class="line">1,one</span><br><span class="line">2,two</span><br></pre></td></tr></table></figure>
<p>在此次改动中，我们把名字都用小写字母替代了。由于我们之前设置的属性名能是驼峰式的，这样我们就可以改变属性头与表格头的匹配方式了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    csv.Configuration.PrepareHeaderForMatch = (<span class="built_in">string</span> header,<span class="built_in">int</span> index) =&gt; header.ToLower();</span><br><span class="line">    <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用配置 <code>PrepareHeaderForMatch</code>，我们就能够实现不同名称之间的配对。头名和属性名都包含在 <code>PrepareHeaderForMatch</code>函数中。当 reader 需要使用属性名来设置头名的时候，他们将会匹配。你还能够使用这个函数来做一些其他的事情，比如说空格或者其他的一些字符。</p>
<p>那我们再来看看如果我们去掉 CSV 文件的头名怎么破吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,one</span><br><span class="line">2,two</span><br></pre></td></tr></table></figure>
<p>首先我们需要告诉 reader 文件中已经没有头记录了，配置如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    csv.Configuration.HasHeadRecord = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">record</span> = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CsvReader 将会使用类中属性的位置作为索引点。但是这有一个问题，你不能再依靠 .NET 中类成员的顺序了。解决方法就是将这个属性映射到 CSV 文件的特定位置。</p>
<p>一种方法就是用属性映射。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Index(0)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Index(1)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>IndexAttribute</code>允许你指定你想要使用属性的位置。</p>
<p>你还可以使用名字作为映射，让我们使用前面的小写头部的例子来看看怎么使用名字匹配。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Name(<span class="string">&quot;id&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Name(<span class="string">&quot;name&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有许多的属性你同样可以使用。</p>
<p>如果我们无法操作我们做匹配的这个类来增加我们需要的属性怎么办？在这个例子中，我们会使用 <code>ClassMap</code>做一次流利的匹配。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span>:<span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">		Map(M =&gt; m.Id).Name(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">		Map(m =&gt; m.Name).Name(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了来使用映射，我们需要注册配置。（也就是写一下配置方法）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">    <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐创造一个类映射，因为这样的话使用 CsvHelper 会更加强大。</p>
<h3 id="写一个-csv-文件">写一个 CSV 文件</h3>
<p>现在让我们来看一看怎么写一个 CSV 文件吧，这跟读基本上是一样的，只是顺序相反。</p>
<p>跟之前读文件一样，我们用一样的类定义。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一些这样的记录（Records）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;Foo&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">new</span> Foo&#123;Id=<span class="number">1</span>,Name=<span class="string">&quot;one&quot;</span>&#125;,</span><br><span class="line">	<span class="keyword">new</span> Foo&#123;Id=<span class="number">2</span>,Name=<span class="string">&quot;two&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以无需配置的把这些记录写到文件中。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;Path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">&#123;</span><br><span class="line">    csv.WriteRecords(records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>WriteRecords</code>方法将会把所有的记录都写到文件中，在你完成写数据之后，你应该调用 <code>writer.Flush()</code>来确保写入器内部缓冲区中的所有数据都已被刷新到文件中。在 <code>using</code>块中的缓存器会自动被清空，因此我们并不需要刻意的去处理这个块。使用 <code>using</code>块来包含 <code>IDisposable</code>对象是一种比较好的方式，这个对象会在 <code>using</code>块退出之后 自己做出相应的处理（在我们这个例子中会自动清除缓存）。</p>
<p>记得我们是不能在 .NET 里面依赖属性的顺序的吗？如果我们写一个有标头的类的时候，这并不重要，我们只需要在后面使用标头即可。如果我们想要将标头安置在 CSV 文件的相应位置的时候，我们就需要指定索引来保证它的顺序，所以当你在写入 CSV 文件数据的时候设置索引是一个好习惯。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span>:<span class="title">classMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Map(m=&gt;m.Id).Index(<span class="number">0</span>).Name(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    	Map(m=&gt;m.Name).Index(<span class="number">1</span>).Name(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="举例说明">举例说明</h2>
<h3 id="预备知识">预备知识</h3>
<p>下面是使用 CsvHelper 需要知道预备知识。</p>
<p>这里有一些关于 .NET 的基础知识是你使用 CsvHelper 前需要知道的，微软有一个<a href="https://docs.microsoft.com/zh-cn/dotnet/">很棒的文档</a>能够帮助你学习更多。</p>
<h4 id="使用和释放">使用和释放</h4>
<p>不论何时你什么时候创建一个 <code>IDisposable</code> 的对象，你都要在使用资源后释放它，大多数类使用非托管资源来是实现 <code>IDisposable</code>，这也就意味着在 <code>System.IO</code>命名空间里的类都需要被释放。</p>
<p>最好的练习释放对象的方法就是使用 <code>using</code>块中写代码，因为在 <code>using</code> 块中，资源会快速自动的被处理。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这里使用 stream 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stream 对象将会在这里被快速的处理</span></span><br></pre></td></tr></table></figure>
<p>如果你在后面也需要用到这个对象，并且稍后会释放它，那么 使用<code>using</code>会帮你做一些错误处理，因此使用 <code>using</code>相比于直接调用 <code>Dispose</code>依旧是一个更好的选择。但是关于这个目前仍然有一些争论，因为有人觉得它没有展现出使用意图。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line"><span class="comment">//之后其他部分的代码</span></span><br><span class="line"><span class="keyword">using</span> (stream)&#123;	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写文件">读写文件</h4>
<p><code>System.IO.File</code>组件包含有打开文件进行读写的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenWrite(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些东西同样返回一个 <code>FileStream</code>来为操作文件进行服务。加入我们的数据是文本型的，我们就需要 <code>StreamReader</code>和 <code>StreamWriter</code>来读写文本。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(stream))    </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = File.OpenRead(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(stream))    </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StreamReader</code>和 <code>StreamWriter</code>都有一种简便写法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 CsvHelper 并不知道你文件数据的具体编码，所以当你有一个特殊的编码的时候。你需要再你的流（stream）里面指定它。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StremaReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>),Encoding.UTF8)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>,Encoding.UTF8))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CsvReader</code> 和 <code>CsvWriter</code>的构造函数分别是 <code>TextReader</code> 和 <code>TextWriter</code>，<code>TextReader</code> 和 <code>TextWriter</code>都是读写文本的一个抽象类。<code>StreamReader</code>和 <code>StreamWriter</code>都继承自 <code>TextReader</code> 和 <code>TextWriter</code>，因此我们也把它们和<code>CsvReader，CsvWriter</code>一起使用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">&#123;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读-csv-文件">读 CSV 文件</h3>
<h4 id="获取类记录">获取类记录</h4>
<p>将 CSV 插入到对应类的对象中。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取动态记录">获取动态记录</h4>
<p>将 CSV 插入到 <code>dynamic</code>对象中，由于无法判断属性的类型，所以动态对象上的所有属性都是字符串。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;<span class="built_in">dynamic</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取匿名类型的记录">获取匿名类型的记录</h4>
<p>如果你需要将 CSV 插入到匿名类型的对象中，仅仅只要提供匿名类型的定义即可。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> anonymousTypeDefinition = <span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Id = <span class="literal">default</span>(<span class="built_in">int</span>),</span><br><span class="line">            Name = <span class="built_in">string</span>.Empty</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords(anonymousTypeDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型记录">枚举类型记录</h4>
<p>将 CSV 转换为一个类对象，该对象可在枚举的每次迭代中重用。每个枚举将生成给定的记录，但只生成映射的成员。如果你提供一个映射却没有映射其中的一个成员，那么该成员就不会得到当前行的数据。值得注意的是，对于你在工程中调用的任何方法会被强制返回一个 <code>IEnumerable</code> 的值，就像方法 <code>ToList()</code> ，你会得到一个与所有记录的实例与你在 CSV 中最后一条记录相对应的的列表。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">record</span> = <span class="keyword">new</span> Foo();</span><br><span class="line">        <span class="keyword">var</span> records = csv.EnumerateRecords(<span class="keyword">record</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> r <span class="keyword">in</span> records)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// r is the same instance as record.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手动读取">手动读取</h4>
<p>因为一些原因，不去配置一个与你的类定义一一对应的映射会变得更加容易，只需要再多纪杭代码就可手动实现行的读取。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;Foo&gt;();</span><br><span class="line">        csv.Read();</span><br><span class="line">        csv.ReadHeader();</span><br><span class="line">        <span class="keyword">while</span> (csv.Read())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">record</span> = <span class="keyword">new</span> Foo</span><br><span class="line">            &#123;</span><br><span class="line">                Id = csv.GetField&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;Id&quot;</span>),</span><br><span class="line">                Name = csv.GetField(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            records.Add(<span class="keyword">record</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取多样的数据集">读取多样的数据集</h4>
<p>因为某些原因，CSV 里面会包含多类型的混合数据集。就像这样读就没有什么问题了，当你检索数据的时候，你需要相应的改变类的类型。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FooId,Name</span><br><span class="line">1,foo</span><br><span class="line"></span><br><span class="line">BarId,Name</span><br><span class="line">07a0fca2-1b1c-4e44-b1be-c2b05da5afc7,bar</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.IgnoreBlankLines = <span class="literal">false</span>;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;BarMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> fooRecords = <span class="keyword">new</span> List&lt;Foo&gt;();</span><br><span class="line">        <span class="keyword">var</span> barRecords = <span class="keyword">new</span> List&lt;Bar&gt;();</span><br><span class="line">        <span class="keyword">var</span> isHeader = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (csv.Read())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isHeader)</span><br><span class="line">            &#123;</span><br><span class="line">                csv.ReadHeader();</span><br><span class="line">                isHeader = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(csv.GetField(<span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                isHeader = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (csv.Context.HeaderRecord[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;FooId&quot;</span>:</span><br><span class="line">                    fooRecords.Add(csv.GetRecord&lt;Foo&gt;());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;BarId&quot;</span>:</span><br><span class="line">                    barRecords.Add(csv.GetRecord&lt;Bar&gt;());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Unknown record type.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Name(<span class="string">&quot;FooId&quot;</span>);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BarMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Bar</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Name(<span class="string">&quot;BarId&quot;</span>);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取多种记录类型">读取多种记录类型</h4>
<p>如果你的 CSV 文件中每行都有不同的记录类型，你应该读基于行的类型。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A,1,foo</span><br><span class="line">B,07a0fca2-1b1c-4e44-b1be-c2b05da5afc7,bar</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.HasHeaderRecord = <span class="literal">false</span>;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;BarMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> fooRecords = <span class="keyword">new</span> List&lt;Foo&gt;();</span><br><span class="line">        <span class="keyword">var</span> barRecords = <span class="keyword">new</span> List&lt;Bar&gt;();</span><br><span class="line">        <span class="keyword">while</span> (csv.Read())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (csv.GetField(<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    fooRecords.Add(csv.GetRecord&lt;Foo&gt;());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                    barRecords.Add(csv.GetRecord&lt;Bar&gt;());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Unknown record type.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Index(<span class="number">1</span>);</span><br><span class="line">        Map(m =&gt; m.Name).Index(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BarMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Bar</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Index(<span class="number">1</span>);</span><br><span class="line">        Map(m =&gt; m.Name).Index(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写-csv-文件">写 CSV 文件</h3>
<h4 id="写类对象">写类对象</h4>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;Foo&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Foo &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;one&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.WriteRecords(records);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<h4 id="写动态类对象">写动态类对象</h4>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;<span class="built_in">dynamic</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dynamic</span> <span class="keyword">record</span> = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">    <span class="keyword">record</span>.Id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">record</span>.Name = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    records.Add(<span class="keyword">record</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StringWriter())</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.WriteRecords(records);</span><br><span class="line"></span><br><span class="line">        writer.ToString().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<h4 id="写匿名类型对象">写匿名类型对象</h4>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;one&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.WriteRecords(records);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<h3 id="配置">配置</h3>
<h4 id="类映射">类映射</h4>
<h5 id="映射属性">映射属性</h5>
<p>映射到属性。这个将会把类的属性映射到 CSV 数据的标头名字上，映射需要在配置中被注册，例子等价于一点也不使用类映射，用标头来匹配类名。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;        </span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过名称映射">通过名称映射</h5>
<p>通过标头名映射到属性，如果你的属性名不匹配你的类名，那么你就可以通过名字来映射到属性。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Column1,Column2</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Name(<span class="string">&quot;ColumnA&quot;</span>);</span><br><span class="line">        Map(m =&gt; m.Name).Name(<span class="string">&quot;ColumnB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过可替换的名映射">通过可替换的名映射</h5>
<p>多标头名映射至属性，如果你有一个可以改变的标头名，你就可以指定多种头名。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Name(<span class="string">&quot;TheId&quot;</span>, <span class="string">&quot;Id&quot;</span>);</span><br><span class="line">        Map(m =&gt; m.Name).Name(<span class="string">&quot;TheName&quot;</span>, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="映射复制名">映射复制名</h5>
<p>映射已经复制标头名的属性，有时候你复制了头名，这时候会通过标题名称索引来处理。name 索引是标头名称出现次数的索引，而不是标头位置的索引。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name,Name</span><br><span class="line">1,first,last</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName &#123; <span class="keyword">get</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.FirstName).Name(<span class="string">&quot;Name&quot;</span>).NameIndex(<span class="number">0</span>);</span><br><span class="line">        Map(m =&gt; m.LastName).Name(<span class="string">&quot;Name&quot;</span>).NameIndex(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过索引映射">通过索引映射</h5>
<p>通过标头的索引位置映射属性，如果你的数据不包含标头，你就可以使用索引来映射数据。不能通过 .NET 类的属性的顺序来，所以如果你没有使用名称进行映射，确保你指定了索引。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.HasHeaderRecord = <span class="literal">false</span>;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id).Index(<span class="number">0</span>);</span><br><span class="line">        Map(m =&gt; m.Name).Index(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自动映射">自动映射</h5>
<p>自动映射，如果你没有提供映射配置，你可以直接调用在类中的自动配置，组件会自动帮你创建一个映射。这对于你有比较多数量的属性而言是一个很好的方式，因为他会自动帮你正确的设置好，你需要做的就是对代码做一些小改变。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,The Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;       </span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMap();</span><br><span class="line">        Map(m =&gt; m.Name).Name(<span class="string">&quot;The Name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="忽略属性">忽略属性</h5>
<p>忽略映射属性，当你使用自动映射类方法的时候，每个属性都会被映射，如果那里有你不想要映射的属性，你就能够直接忽视他们了。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;       </span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMap();</span><br><span class="line">        Map(m =&gt; m.IsDirty).Ignore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常数值">常数值</h5>
<p>对于特定的属性设置常值，你能够设置常值属性而不是映射到域。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;       </span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        <span class="keyword">var</span> records = csv.GetRecords&lt;Foo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsDirty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">        Map(m =&gt; m.IsDirty).Constant(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类型转换">类型转换</h5>
<p>使用指定的类型转换，如果你需要从非标准的 .NET 类型转换或者转换到非标准的 .NET 数据，你能够提供一个类型转化来使用属性。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name,Json</span><br><span class="line">1,one,&quot;&#123; &quot;&quot;Foo&quot;&quot;: &quot;&quot;Bar&quot;&quot; &#125;&quot;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.GetRecords&lt;Foo&gt;().ToList().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Json Json &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Foo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonConverter</span>&lt;<span class="title">T</span>&gt; : DefaultTypeConverter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span> <span class="title">ConvertFromString</span>(<span class="params"><span class="built_in">string</span> text, IReaderRow row, MemberMapData memberMapData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ConvertToString</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, IWriterRow row, MemberMapData memberMapData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> JsonConvert.SerializeObject(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">        Map(m =&gt; m.Json).TypeConverter&lt;JsonConverter&lt;Json&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内联类型转化">内联类型转化</h5>
<p>转化到一个内联类型，如果你不想要写一个满的 <code>ITypeConverter</code>实现，你能够创建一个可以实现功能的函数。</p>
<h6 id="读">读</h6>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name,Json</span><br><span class="line">1,one,&quot;&#123; &quot;&quot;Foo&quot;&quot;: &quot;&quot;Bar&quot;&quot; &#125;&quot;</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">    using (var reader = new StreamReader(&quot;path\\to\\file.csv&quot;))</span><br><span class="line">    using (var csv = new CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.GetRecords&lt;Foo&gt;().ToList().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public int Id &#123; get; set; &#125;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public Json Json &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Json</span><br><span class="line">&#123;</span><br><span class="line">    public string Foo &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FooMap : ClassMap&lt;Foo&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public FooMap()</span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">        Map(m =&gt; m.Json).ConvertUsing(row =&gt; JsonConvert.DeserializeObject&lt;Json&gt;(row.GetField(&quot;Json&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="写">写</h6>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> records = <span class="keyword">new</span> List&lt;Foo&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Foo &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;one&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> writer = <span class="keyword">new</span> StreamWriter(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvWriter(writer))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.WriteRecords(records);</span><br><span class="line"></span><br><span class="line">        writer.ToString().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Json Json &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Foo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">        Map(m =&gt; m.Json).ConvertUsing(o =&gt; JsonConvert.SerializeObject(o));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name,Json</span><br><span class="line">1,one,&quot;&#123;&quot;&quot;Id&quot;&quot;:1,&quot;&quot;Name&quot;&quot;:&quot;&quot;one&quot;&quot;,&quot;&quot;Json&quot;&quot;:null&#125;&quot;</span><br></pre></td></tr></table></figure>
<h5 id="映射选项">映射选项</h5>
<p>属性一定要存在才能映射，如果你有数据不确定是不是有标头，你需要制作映射选项。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,one</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.GetRecords&lt;Foo&gt;().ToList().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTimeOffset? Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name);</span><br><span class="line">        Map(m =&gt; m.Date).Optional();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="验证">验证</h5>
<p>验证一个域值，如果你想要确保你的数据符合一些标准，你能够验证它。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id,Name</span><br><span class="line">1,on-e</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.Configuration.RegisterClassMap&lt;FooMap&gt;();</span><br><span class="line">        csv.GetRecords&lt;Foo&gt;().ToList().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTimeOffset? Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FooMap</span> : <span class="title">ClassMap</span>&lt;<span class="title">Foo</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooMap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Map(m =&gt; m.Id);</span><br><span class="line">        Map(m =&gt; m.Name).Validate(field =&gt; !field.Contains(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性">属性</h4>
<p>大部分的配置都能通过使用属性类映射被完成，<a href="https://joshclose.github.io/CsvHelper/api/CsvHelper.Configuration.Attributes/">完整的可获得的属性列表</a>。</p>
<p>数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Identifier,name,IsBool,Constant</span><br><span class="line">1,one,yes,a</span><br><span class="line">2,two,no,b</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">    &#123;</span><br><span class="line">        csv.GetRecords&lt;Foo&gt;().ToList().Dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Name(<span class="string">&quot;Identifier&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Index(1)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BooleanTrueValues(<span class="string">&quot;yes&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">BooleanFalseValues(<span class="string">&quot;no&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsBool &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Constant(<span class="string">&quot;bar&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Constant &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Optional</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Optional &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Ignore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Ignored &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型转换-1">类型转换</h4>
<p>待补…</p>
<h4 id="数据表">数据表</h4>
<p>使用 CsvHelper 去加载数据表是非常频繁的事情，因此我直接将其集成了一个功能。</p>
<p>CsvDataReader 实现 <code>IDataReader</code>方法。，这也就意味着它仅有前向数据读取的所有功能，所以真的不必要去直接使用这个类而不用 <code>CsvReader</code>， <code>CsvDataReader</code>要求有 <code>CsvReader</code>的实例并且在内部使用来完成其功能。</p>
<p>使用 CsvHelper 来加载一个 <code>DataTable</code>是比较简单的，默认的，表格中的所有列将会以字符串的形式被加载。当读取器已经做好了实例化的准备，你只需要在创建 CsvDataReader实例前做一些配置即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do any configuration to `CsvReader` before creating CsvDataReader.</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> dr = <span class="keyword">new</span> CsvDataReader(csv))</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">var</span> dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">        dt.Load(dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想要指定行和行的类型，数据表也可以进行自动的类型转换。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;path\\to\\file.csv&quot;</span>))</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> csv = <span class="keyword">new</span> CsvReader(reader))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do any configuration to `CsvReader` before creating CsvDataReader.</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> dr = <span class="keyword">new</span> CsvDataReader(csv))</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">var</span> dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">        dt.Columns.Add(<span class="string">&quot;Id&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">        dt.Columns.Add(<span class="string">&quot;Name&quot;</span>, <span class="keyword">typeof</span>(<span class="built_in">string</span>));</span><br><span class="line"></span><br><span class="line">        dt.Load(dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用程序接口api">应用程序接口（API）</h3>
<h4 id="命名空间csvhelper-namespace">命名空间（CsvHelper Namespace）</h4>
<h5 id="类classes">类（Classes）</h5>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/BadDataException">BadDataException</a></td>
<td style="text-align: left;">Represents errors that occur due to bad data.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvDataReader">CsvDataReader</a></td>
<td style="text-align: left;">Provides a means of reading a CSV file forward-only by using CsvReader.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvFieldReader">CsvFieldReader</a></td>
<td style="text-align: left;">Reads fields from a <code>System.IO.TextReader</code> .</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvHelperException">CsvHelperException</a></td>
<td style="text-align: left;">Represents errors that occur in CsvHelper.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvParser">CsvParser</a></td>
<td style="text-align: left;">Parses a CSV file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvReader">CsvReader</a></td>
<td style="text-align: left;">Reads data that was parsed from <code>CsvHelper.IParser</code> .</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvSerializer">CsvSerializer</a></td>
<td style="text-align: left;">Defines methods used to serialize data into a CSV file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/CsvWriter">CsvWriter</a></td>
<td style="text-align: left;">Used to write CSV files.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/Factory">Factory</a></td>
<td style="text-align: left;">Creates CsvHelper classes.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/FieldValidationException">FieldValidationException</a></td>
<td style="text-align: left;">Represents a user supplied field validation failure.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/HeaderValidationException">HeaderValidationException</a></td>
<td style="text-align: left;">Represents a header validation failure.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/MissingFieldException">MissingFieldException</a></td>
<td style="text-align: left;">Represents an error caused because a field is missing in the header while reading a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ObjectResolver">ObjectResolver</a></td>
<td style="text-align: left;">Creates objects from a given type.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ParserException">ParserException</a></td>
<td style="text-align: left;">Represents errors that occur while parsing a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ReaderException">ReaderException</a></td>
<td style="text-align: left;">Represents errors that occur while reading a CSV file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ReadingContext">ReadingContext</a></td>
<td style="text-align: left;">CSV reading state.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/RecordBuilder">RecordBuilder</a></td>
<td style="text-align: left;">Builds CSV records.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ReflectionExtensions">ReflectionExtensions</a></td>
<td style="text-align: left;">Extensions to help with reflection.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ValidationException">ValidationException</a></td>
<td style="text-align: left;">Represents a user supplied validation failure.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/WriterException">WriterException</a></td>
<td style="text-align: left;">Represents errors that occur while writing a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/WritingContext">WritingContext</a></td>
<td style="text-align: left;">CSV writing state.</td>
</tr>
</tbody>
</table>
<h5 id="接口interfaces">接口（Interfaces）</h5>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IFactory">IFactory</a></td>
<td style="text-align: left;">Defines methods used to create CsvHelper classes.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IFieldReader">IFieldReader</a></td>
<td style="text-align: left;">Defines methods used to read a field in a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IObjectResolver">IObjectResolver</a></td>
<td style="text-align: left;">Defines the functionality of a class that creates objects from a given type.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IParser">IParser</a></td>
<td style="text-align: left;">Defines methods used the parse a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IReader">IReader</a></td>
<td style="text-align: left;">Defines methods used to read parsed data from a CSV file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IReaderRow">IReaderRow</a></td>
<td style="text-align: left;">Defines methods used to read parsed data from a CSV file row.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/ISerializer">ISerializer</a></td>
<td style="text-align: left;">Defines methods used to serialize data into a CSV file.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IWriter">IWriter</a></td>
<td style="text-align: left;">Defines methods used to write to a CSV file.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/IWriterRow">IWriterRow</a></td>
<td style="text-align: left;">Defines methods used to write a CSV row.</td>
</tr>
</tbody>
</table>
<h5 id="枚举enums">枚举（Enums）</h5>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a href="https://joshclose.github.io/CsvHelper/api/CsvHelper/Caches">Caches</a></td>
<td style="text-align: left;">Types of caches.</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>CSharp</tag>
        <tag>CSV</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-网络抓包</title>
    <url>/2025/12/10/Linux%20Debug/Linux-%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="wireshark">wireshark</h1>
<h2 id="远程抓包">远程抓包</h2>
<p>在wireshark的以下两个部分进行抓包，不建议性能分析时进行，在连通性验证时可以使用（ssh传输可能丢包等） <img src="img1.png" /> <img src="image.png" alt="image.png" /></p>
<h2 id="sshtcpdumpwireshark解析">ssh+tcpdump+wireshark解析</h2>
<p>直接抓包解析 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh &lt;ip&gt; &#x27;tcpdump -ni any -s0 -U -w - udp port 53&#x27; | wireshark -k -i -</span><br></pre></td></tr></table></figure> 跳板机执行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -J &lt;jumpsever ip&gt; &lt;ip&gt; &#x27;tcpdump -ni any -s0 -U -w - udp port 53&#x27; | wireshark -k -i -</span><br></pre></td></tr></table></figure> 直接抓包并保存 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh &lt;ip&gt; <span class="string">&#x27;tcpdump -ni any -s0 -U -w- udp port 53&#x27;</span> &gt; /tmp/packets.pcap</span><br></pre></td></tr></table></figure></p>
<h1 id="tcpdump">tcpdump</h1>
<h2 id="常用抓包指令">常用抓包指令</h2>
<p>过滤tcp flags，比如抓syn报文，看是否能握手成功 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -ni any &#x27;tcp[tcpflags] == tcp-syn&#x27;</span><br></pre></td></tr></table></figure> 查看tcp状态，如下为发送了sync，如果一直未回复，则可以在<code>sar -n ETCP 1</code>看到<code>retrans/s</code>不断上升 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch -n 0.1 &#x27;ss -tpn state syn-sent&#x27;</span><br></pre></td></tr></table></figure> 抓syn和syn+ack报文 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -ni any <span class="string">&#x27;tcp[tcpflags] == tcp-syn or tcp[13]=18&#x27;</span></span><br></pre></td></tr></table></figure> 抓syn和syn+rst报文 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -ni any &#x27;tcp[tcpflags] == tcp-syn or tcp[13] &amp; 4!=0&#x27;</span><br></pre></td></tr></table></figure> 抓syn和icmp不可达报文 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -ni any &#x27;tcp[tcpflags] == tcp-syn or icmp[0] = 3&#x27;</span><br></pre></td></tr></table></figure> 抓syn、syn+ack、rst和icmp端口不可达报文（tcp[13]指的是从tcp报文头偏移13字节的选项） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -ni any &#x27;(tcp[tcpflags] == tcp-syn or tcp[13]=18) or tcp[13] &amp;amp; 4!=0 or icmp[0] = 3&#x27;</span><br></pre></td></tr></table></figure> tcp flags抓包例子 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump &#x27;tcp[tcpflags] == tcp-syn&#x27;</span><br><span class="line">tcpdump &#x27;tcp[tcpflags] == tcp-rst&#x27;</span><br><span class="line">tcpdump &#x27;tcp[tcpflags] == tcp-fin&#x27;</span><br></pre></td></tr></table></figure> 抓取指定报文大小 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump less 32</span><br><span class="line">tcpdump greater 32</span><br><span class="line">tcpdump &lt;= 102</span><br></pre></td></tr></table></figure> 持续抓取端口 <code>8080</code>的流量，每个文件最大 <code>100MB</code>，最多保留 <code>10</code>个文件，写满后覆盖最旧的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -C 100 -W 10 -w my_capture.pcap port 8080</span><br></pre></td></tr></table></figure> 抓取 <code>10000</code>个发往 <code>80</code>端口的包 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -c 10000 -w http_requests.pcap dst port 80</span><br></pre></td></tr></table></figure></p>
<h2 id="常用选项">常用选项</h2>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>-i &lt;interface&gt;</code></strong>​</td>
<td>指定抓包网卡。<code>any</code>表示所有网卡。</td>
<td><code>-i any</code></td>
</tr>
<tr class="even">
<td><strong><code>port &lt;端口号&gt;</code></strong>​</td>
<td>过滤特定端口的流量（TCP/UDP）。</td>
<td><code>port 8080</code></td>
</tr>
<tr class="odd">
<td><strong><code>-C &lt;大小&gt;</code></strong>​</td>
<td><strong>按文件大小分割</strong>。单位通常为MB（M）。</td>
<td><code>-C 100</code></td>
</tr>
<tr class="even">
<td><strong><code>-W &lt;数量&gt;</code></strong>​</td>
<td><strong>限制文件总数</strong>，与 <code>-C</code>配合实现循环覆盖。</td>
<td><code>-W 10</code></td>
</tr>
<tr class="odd">
<td><strong><code>-w &lt;文件名&gt;</code></strong>​</td>
<td>将抓取的原始数据包写入指定文件。</td>
<td><code>-w my_capture.pcap</code></td>
</tr>
<tr class="even">
<td><strong><code>-c &lt;数量&gt;</code></strong>​</td>
<td>抓取指定数量的数据包后自动退出。</td>
<td><code>-c 10000</code></td>
</tr>
<tr class="odd">
<td><strong><code>-s &lt;长度&gt;</code></strong>​</td>
<td>设置每个数据包的抓取长度（快照长度byte），<code>-s 0</code>表示抓取完整数据包。<strong>(在长期抓只需要分析报文头很实用)</strong></td>
<td><code>-s 0</code></td>
</tr>
</tbody>
</table>
<h2 id="其他选项">其他选项</h2>
<h3 id="capture-commands">Capture Commands</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>Example usage</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-i any</code></td>
<td><code>tcpdump -i any</code></td>
<td>Capture from all interfaces; may require superuser (<code>sudo/su</code>)</td>
</tr>
<tr class="even">
<td><code>-i eth0</code></td>
<td><code>tcpdump -i eth0</code></td>
<td>Capture from the interface <code>eth0</code></td>
</tr>
<tr class="odd">
<td><code>-c count</code></td>
<td><code>tcpdump -i eth0 -c 5</code></td>
<td>Exit after receiving <code>count (5)</code> packets</td>
</tr>
<tr class="even">
<td><code>-r captures.pcap</code></td>
<td><code>tcpdump -i eth0 -r captures.pcap</code></td>
<td>Read and analyze saved capture file <code>captures.pcap</code></td>
</tr>
<tr class="odd">
<td><code>tcp</code></td>
<td><code>tcpdump -i eth0 tcp</code></td>
<td>Show TCP packets only</td>
</tr>
<tr class="even">
<td><code>udp</code></td>
<td><code>tcpdump -i eth0 udp</code></td>
<td>Show UDP packets only</td>
</tr>
<tr class="odd">
<td><code>icmp</code></td>
<td><code>tcpdump -i eth0 icmp</code></td>
<td>Show ICMP packets only</td>
</tr>
<tr class="even">
<td><code>ip</code></td>
<td><code>tcpdump -i eth0 ip</code></td>
<td>Show IPv4 packets only</td>
</tr>
<tr class="odd">
<td><code>ip6</code></td>
<td><code>tcpdump -i eth0 ip6</code></td>
<td>Show IPv6 packets only</td>
</tr>
<tr class="even">
<td><code>arp</code></td>
<td><code>tcpdump -i eth0 arp</code></td>
<td>Show ARP packets only</td>
</tr>
<tr class="odd">
<td><code>rarp</code></td>
<td><code>tcpdump -i eth0 rarp</code></td>
<td>Show RARP packets only</td>
</tr>
<tr class="even">
<td><code>slip</code></td>
<td><code>tcpdump -i eth0 slip</code></td>
<td>Show SLIP packets only</td>
</tr>
<tr class="odd">
<td><code>-I</code></td>
<td><code>tcpdump -i eth0 -I</code></td>
<td>Set interface as monitor mode</td>
</tr>
<tr class="even">
<td><code>-K</code></td>
<td><code>tcpdump -i eth0 -K</code></td>
<td>Don’t verify checksum</td>
</tr>
<tr class="odd">
<td><code>-p</code></td>
<td><code>tcpdump -i eth0 -p</code></td>
<td>Don’t capture in promiscuous mode</td>
</tr>
</tbody>
</table>
<h3 id="filter-commands">Filter Commands</h3>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>Filter expression</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src host 127.0.0.1</code></td>
<td>Filter by source IP/hostname <code>127.0.0.1</code></td>
</tr>
<tr class="even">
<td><code>dst host 127.0.0.1</code></td>
<td>Filter by destination IP/hostname <code>127.0.0.1</code></td>
</tr>
<tr class="odd">
<td><code>host 127.0.0.1</code></td>
<td>Filter by source or destination = <code>127.0.0.1</code></td>
</tr>
<tr class="even">
<td><code>ether src 01:23:45:AB:CD:EF</code></td>
<td>Filter by source MAC <code>01:23:45:AB:CD:EF</code></td>
</tr>
<tr class="odd">
<td><code>ether dst 01:23:45:AB:CD:EF</code></td>
<td>Filter by destination MAC <code>01:23:45:AB:CD:EF</code></td>
</tr>
<tr class="even">
<td><code>ether host 01:23:45:AB:CD:EF</code></td>
<td>Filter by source or destination MAC <code>01:23:45:AB:CD:EF</code></td>
</tr>
<tr class="odd">
<td><code>src net 127.0.0.1</code></td>
<td>Filter by source network location <code>127.0.0.1</code></td>
</tr>
<tr class="even">
<td><code>dst net 127.0.0.1</code></td>
<td>Filter by destination network location <code>127.0.0.1</code></td>
</tr>
<tr class="odd">
<td><code>net 127.0.0.1</code></td>
<td>Filter by source or destination network location <code>127.0.0.1</code></td>
</tr>
<tr class="even">
<td><code>net 127.0.0.1/24</code></td>
<td>Filter by source or destination network location <code>127.0.0.1</code> with the tcpdump subnet mask of length <code>24</code></td>
</tr>
<tr class="odd">
<td><code>src port 80</code></td>
<td>Filter by source port = 80</td>
</tr>
<tr class="even">
<td><code>dst port 80</code></td>
<td>Filter by destination port = 80</td>
</tr>
<tr class="odd">
<td><code>port 80</code></td>
<td>Filter by source or destination port = 80</td>
</tr>
<tr class="even">
<td><code>src portrange 80-400</code></td>
<td>Filter by source port value between 80 and 400</td>
</tr>
<tr class="odd">
<td><code>dst portrange 80-400</code></td>
<td>Filter by destination port value between 80 and 400</td>
</tr>
<tr class="even">
<td><code>portrange 80-400</code></td>
<td>Filter by source or destination port value between 80 and 400</td>
</tr>
<tr class="odd">
<td><code>ether broadcast</code></td>
<td>Filter for Ethernet broadcasts</td>
</tr>
<tr class="even">
<td><code>ip broadcast</code></td>
<td>Filter for IPv4 broadcasts</td>
</tr>
<tr class="odd">
<td><code>ether multicast</code></td>
<td>Filter for Ethernet multicasts</td>
</tr>
<tr class="even">
<td><code>ip multicast</code></td>
<td>Filter for IPv4 multicasts</td>
</tr>
<tr class="odd">
<td><code>ip6 multicast</code></td>
<td>Filter for IPv6 multicasts</td>
</tr>
<tr class="even">
<td><code>ip src host mydevice</code></td>
<td>Filter by IPv4 source hostname <code>mydevice</code></td>
</tr>
<tr class="odd">
<td><code>arp dst host mycar</code></td>
<td>Filter by ARP destination hostname <code>mycar</code></td>
</tr>
<tr class="even">
<td><code>rarp src host 127.0.0.1</code></td>
<td>Filter by RARP source <code>127.0.0.1</code></td>
</tr>
<tr class="odd">
<td><code>ip6 dst host mywatch</code></td>
<td>Filter by IPv6 destination hostname <code>mywatch</code></td>
</tr>
<tr class="even">
<td><code>tcp dst port 8000</code></td>
<td>Filter by destination TCP port = 8000</td>
</tr>
<tr class="odd">
<td><code>udp src portrange 1000-2000</code></td>
<td>Filter by source TCP ports in 1000–2000</td>
</tr>
<tr class="even">
<td><code>sctp port 22</code></td>
<td>Filter by source or destination port = 22</td>
</tr>
</tbody>
</table>
<h3 id="display-commands">Display Commands</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Example</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>tcpdump -i eth0 -A</code></td>
<td>Print each packet (minus its link level header) in ASCII. Handy for capturing web pages. <br> <br>[![Screenshot with ASCII (sudo tcpdump twitter)</td>
</tr>
<tr class="even">
<td><code>tcpdump -D</code></td>
<td>Print the list of the network interfaces available on the system and on which tcpdump can capture packets.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -e</code></td>
<td>Print the link-level header on each output line, such as MAC layer addresses for protocols such as Ethernet and IEEE 802.11.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -F /path/to/params.conf</code></td>
<td>Use the file <code>params.conf</code> as input for the <a href="###%20Filter%20Commands">filter expression</a>. (Ignore other expressions on the command line.)</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -n</code></td>
<td>Don’t convert addresses (i.e., host addresses, port numbers, etc.) to names.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -S</code></td>
<td>Print absolute, rather than relative, TCP sequence numbers. (Absolute TCP sequence numbers are longer.)</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 --time-stamp-precision=nano</code></td>
<td>When capturing, set the timestamp precision for the capture to <code>tsp</code>: <br>• <code>micro</code> for microsecond (default) <br>• <code>nano</code> for nanosecond.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -t</code></td>
<td>Omit the timestamp on each output line.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -tt</code></td>
<td>Print the timestamp, as seconds since January 1, 1970, 00:00:00, UTC, and fractions of a second since that time, on each dump line.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -ttt</code></td>
<td>Print a delta (microsecond or nanosecond resolution depending on the <code>--time-stamp-precision</code> option) between the current and previous line on each output line. The default is microsecond resolution.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -tttt</code></td>
<td>Print a timestamp as hours, minutes, seconds, and fractions of a second since midnight, preceded by the date, on each dump line.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -ttttt</code></td>
<td>Print a delta (microsecond or nanosecond resolution depending on the <code>--time-stamp-precision</code> option) between the current and first line on each dump line. The default is microsecond resolution.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -u</code></td>
<td>Print undecoded network file system (NFS) handles.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -v</code></td>
<td>Produce verbose output. <br>When writing to a file (<code>-w</code> option) and at the same time not reading from a file (<code>-r</code> option), report to standard error, once per second, the number of packets captured.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -vv</code></td>
<td>Additional verbose output than <code>-v</code></td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -vvv</code></td>
<td>Additional verbose output than <code>-vv</code></td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -x</code></td>
<td>Print the headers and data of each packet (minus its link level header) in hex.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -xx</code></td>
<td>Print the headers and data of each packet, including its link level header, in hex.</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -X</code></td>
<td>Print the headers and data of each packet (minus its link level header) in hex and ASCII.</td>
</tr>
<tr class="even">
<td><code>tcpdump -i eth0 -XX</code></td>
<td>Print the headers and data of each packet, including its link level header, in hex and ASCII.</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="output-commands">Output Commands</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>Example</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-w captures.pcap</code></td>
<td><code>tcpdump -i eth0 -w captures.pcap</code></td>
<td>Output capture to a file <code>captures.pcap</code></td>
</tr>
<tr class="even">
<td><code>-d</code></td>
<td><code>tcpdump -i eth0 -d</code></td>
<td>Display human-readable form in standard output</td>
</tr>
<tr class="odd">
<td><code>-L</code></td>
<td><code>tcpdump -i eth0 -L</code></td>
<td>Display data link types for the interface</td>
</tr>
<tr class="even">
<td><code>-q</code></td>
<td><code>tcpdump -i eth0 -q</code></td>
<td>Quick/quiet output. Print less protocol information, so output lines are shorter.</td>
</tr>
<tr class="odd">
<td><code>-U</code></td>
<td><code>tcpdump -i eth0 -U -w out.pcap</code></td>
<td><strong>Without -w option</strong> <br>Print a description of each packet’s contents. <br><strong>With -w option</strong> <br>Write each packet to the output file <code>out.pcap</code> in real time rather than only when the output buffer fills.</td>
</tr>
</tbody>
</table>
<h3 id="miscellaneous-commands">Miscellaneous Commands</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Syntax</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>AND</code></td>
<td><code>and, &amp;&amp;</code></td>
<td><code>tcpdump -n src 127.0.0.1 and dst port 21</code></td>
<td>Combine filtering options joined by “and”</td>
</tr>
<tr class="even">
<td><code>OR</code></td>
<td><code>or, \|</code></td>
<td><code>tcpdump dst 127.0.0.1 or src port 22</code></td>
<td>Match any of the conditions joined by “or”</td>
</tr>
<tr class="odd">
<td><code>EXCEPT</code></td>
<td><code>not, !</code></td>
<td><code>tcpdump dst 127.0.0.1 and not icmp</code></td>
<td>Negate the condition prefixed by “not”</td>
</tr>
<tr class="even">
<td><code>LESS</code></td>
<td><code>less, &lt;, (&lt;=)</code></td>
<td><code>tcpdump dst host 127.0.0.1 and less 128</code></td>
<td>Shows packets shorter than (or equal to) 128 bytes in length. <br>&lt; only applies to length 32, i.e., <code>&lt;32</code>.</td>
</tr>
<tr class="odd">
<td><code>GREATER</code></td>
<td><code>greater, &gt;, (&gt;=)</code></td>
<td><code>tcpdump dst host 127.0.0.1 and greater 64</code></td>
<td>Shows packets longer than (or equal to) 64 bytes in length. <br>&gt; only applies to length 32, i.e., <code>&gt;32</code>.</td>
</tr>
<tr class="even">
<td><code>EQUAL</code></td>
<td><code>=, ==</code></td>
<td><code>tcpdump host 127.0.0.1 = 0</code></td>
<td>Show packets with zero length</td>
</tr>
</tbody>
</table>
<h3 id="example-usage">Example Usage</h3>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Example</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>tcpdump -r outfile.pcap src host 10.0.2.15</code></td>
<td>Print all packets in the file <code>outfile.pcap</code> coming from the host with IP address 10.0.2.15</td>
</tr>
<tr class="even">
<td><code>tcpdump -i any ip and not tcp port 80</code></td>
<td>Listen for non-HTTP packets (which have TCP port number 80) on any network interface</td>
</tr>
<tr class="odd">
<td><code>tcpdump -i eth0 -n &gt;32 -w pv01.pcap -c 30</code></td>
<td>Save 30 packets of length exceeding 32 bytes to <code>captures.pcap</code> without DNS resolution on the <code>eth0</code> network interface</td>
</tr>
<tr class="even">
<td><code>tcpdump -AtuvX icmp</code></td>
<td>Capture ICMP traffic and print ICMP packets in hex and ASCII and the following features: <br>With: <br>• headers <br>• data <br>• undecoded NFS handles <br>Without: <br>• link level headers <br>• timestamps.</td>
</tr>
<tr class="odd">
<td><code>tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'</code></td>
<td>Print all IPv4 HTTP packets to and from port 80, i.e. print only packets that contain data, not, for example, SYN and FIN packets and ACK-only packets.</td>
</tr>
</tbody>
</table>
<h1 id="参考搬运">参考/搬运</h1>
<ul>
<li><a href="https://debugging.works/blog/network-debugging/">https://debugging.works/blog/network-debugging/</a></li>
<li><a href="https://www.stationx.net/tcpdump-cheat-sheet/">https://www.stationx.net/tcpdump-cheat-sheet/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>bcc初体验</title>
    <url>/2024/01/22/Linux%20Debug/bcc%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="安装">安装</h2>
<h3 id="ubuntu">Ubuntu</h3>
<p>BCC已经打包到Ubuntu的multiverse仓库，名字<code>bpfcc-tools</code>，使用如下命令安装 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential bpfcc-tools linux-header-$(uname -r) bpftrace</span><br></pre></td></tr></table></figure></p>
<h2 id="使用">使用</h2>
<p>funccount</p>
<p>stackcount</p>
]]></content>
      <tags>
        <tag>bpf</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>bpftrace技术1-常用命令</title>
    <url>/2025/12/10/Linux%20Debug/bpftrace%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="bpftrace是什么">bpftrace是什么</h1>
<p>一种追踪内核态和用户态的新技术</p>
<h1 id="看可以跟踪哪些内核函数">看可以跟踪哪些内核函数</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -l | grep kprobe</span><br></pre></td></tr></table></figure>
<h1 id="跟踪内核函数例子">跟踪内核函数例子</h1>
<h2 id="是否调用">是否调用</h2>
<p>跟踪 <code>net/ipv4/netfilter/ip_tables.c looks promising</code> 的两个函数: <code>compat_do_ipt_get_ctl</code> 和 <code>do_ipt_get_ctl</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~# </span><span class="language-bash">bpftrace -e <span class="string">&#x27;kprobe:do_ipt_get_ctl &#123; printf(&quot;function was called!\n&quot;); &#125;&#x27;</span></span></span><br><span class="line">Attaching 1 probe...</span><br><span class="line">function was called!</span><br><span class="line">function was called!</span><br></pre></td></tr></table></figure>
<p><code>compat_do_ipt_get_ctl</code> 函数签名如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">compat_do_ipt_get_ctl</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> cmd, <span class="type">void</span> __user *user, <span class="type">int</span> *len)</span></span><br></pre></td></tr></table></figure>
<h2 id="调用命令pid入参">调用命令，pid，入参</h2>
<p>建立<code>test.bpf</code>文件 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">kprobe:do_ipt_get_ctl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;called by %s (pid: %d). and: %d\n&quot;</span>, comm, pid, ((sock *)arg0)-&gt;__sk_common.skc_family);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">~<span class="meta"># bpftrace test.bpf</span></span><br><span class="line">/bpftrace/include/stdarg.h:<span class="number">52</span>:<span class="number">1</span>: warning: null character ignored [-Wnull-character]       </span><br><span class="line">/lib/modules/<span class="number">4.19</span>.<span class="number">0</span><span class="number">-8</span>-amd64/source/arch/x86/include/<span class="keyword">asm</span>/bitops.h:<span class="number">209</span>:<span class="number">2</span>: error: <span class="string">&#x27;asm goto&#x27;</span> constructs are not supported yet</span><br><span class="line">/lib/modules/<span class="number">4.19</span>.<span class="number">0</span><span class="number">-8</span>-amd64/source/arch/x86/include/<span class="keyword">asm</span>/bitops.h:<span class="number">256</span>:<span class="number">2</span>: error: <span class="string">&#x27;asm goto&#x27;</span> constructs are not supported yet</span><br><span class="line">/lib/modules/<span class="number">4.19</span>.<span class="number">0</span><span class="number">-8</span>-amd64/source/arch/x86/include/<span class="keyword">asm</span>/bitops.h:<span class="number">310</span>:<span class="number">2</span>: error: <span class="string">&#x27;asm goto&#x27;</span> constructs are not supported yet</span><br><span class="line">/lib/modules/<span class="number">4.19</span>.<span class="number">0</span><span class="number">-8</span>-amd64/source/arch/x86/include/<span class="keyword">asm</span>/jump_label.h:<span class="number">23</span>:<span class="number">2</span>: error: <span class="string">&#x27;asm goto&#x27;</span> constructs are not supported yet</span><br><span class="line">/lib/modules/<span class="number">4.19</span>.<span class="number">0</span><span class="number">-8</span>-amd64/source/arch/x86/include/<span class="keyword">asm</span>/signal.h:<span class="number">24</span>:<span class="number">2</span>: note: <span class="built_in">array</span> <span class="string">&#x27;sig&#x27;</span> declared here</span><br><span class="line">Attaching <span class="number">1</span> probe...</span><br><span class="line">called by iptables-legacy (pid: <span class="number">2981</span>). and: <span class="number">2</span></span><br><span class="line">called by iptables-legacy (pid: <span class="number">2981</span>). and: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p> <code>2</code> 的含义解释如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/usr/src/linux-headers<span class="number">-4.19</span>.<span class="number">0</span><span class="number">-8</span>-common/include/linux/socket.h</span><br><span class="line"><span class="number">160</span> <span class="comment">/* Supported address families. */</span></span><br><span class="line"><span class="number">161</span> <span class="meta">#<span class="keyword">define</span> AF_UNSPEC   0</span></span><br><span class="line"><span class="number">162</span> <span class="meta">#<span class="keyword">define</span> AF_UNIX     1   <span class="comment">/* Unix domain sockets      */</span></span></span><br><span class="line"><span class="number">163</span> <span class="meta">#<span class="keyword">define</span> AF_LOCAL    1   <span class="comment">/* POSIX name for AF_UNIX   */</span></span></span><br><span class="line"><span class="number">164</span> <span class="meta">#<span class="keyword">define</span> AF_INET     2   <span class="comment">/* Internet IP Protocol     */</span></span></span><br><span class="line"><span class="number">165</span> <span class="meta">#<span class="keyword">define</span> AF_AX25     3   <span class="comment">/* Amateur Radio AX.25      */</span></span></span><br><span class="line"><span class="number">166</span> <span class="meta">#<span class="keyword">define</span> AF_IPX      4   <span class="comment">/* Novell IPX           */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="打印入参">打印入参</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kprobe:vfs_open &#123; printf(&quot;open path: %s\n&quot;, str(((path *)arg0)-&gt;dentry-&gt;d_name.name)); &#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="打印返回值">打印返回值</h2>
<p>使用默认变量<code>retval</code>。</p>
<h3 id="内核函数返回值">内核函数返回值</h3>
<p>使用 <code>kretprobe</code>跟踪内核函数的返回值。例如，跟踪 <code>vfs_read</code>的返回值（读取的字节数或错误码）： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kretprobe:vfs_read &#123; printf(&quot;vfs_read returned: %d\n&quot;, retval); &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="用户空间函数返回值">用户空间函数返回值</h3>
<p>使用 <code>uretprobe</code>跟踪用户空间函数的返回值。例如，跟踪一个名为 <code>myfunc</code>的函数的返回值： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;uretprobe:/path/to/binary:myfunc &#123; printf(&quot;myfunc returned: %d\n&quot;, retval); &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="结合入口和返回探针">结合入口和返回探针</h3>
<p>测量函数执行时间或关联参数与返回值。这可以通过在函数入口（如 <code>kprobe</code>/<code>uprobe</code>）记录时间戳（<code>tid</code>是内置变量，代表线程id），然后在返回探针中计算差值来实现。例如： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kprobe:vfs_read &#123; @start[tid] = nsecs; &#125; </span></span><br><span class="line"><span class="string">                kretprobe:vfs_read /@start[tid]/ &#123; </span></span><br><span class="line"><span class="string">                    $duration = nsecs - @start[tid]; </span></span><br><span class="line"><span class="string">                    printf(&quot;vfs_read took %d ns, returned %d\n&quot;, $duration, retval); </span></span><br><span class="line"><span class="string">                    delete(@start[tid]); </span></span><br><span class="line"><span class="string">                &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="过滤条件">过滤条件</h3>
<p>可以在返回探针上添加过滤条件，例如只处理特定进程或返回值范围的调用。使用 <code>/&lt;filter&gt;/</code>语法。例如，只打印返回值大于0的 <code>vfs_read</code>调用： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kretprobe:vfs_read /retval &gt; 0/ &#123; printf(&quot;vfs_read returned: %d\n&quot;, retval); &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bpftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>bpftrace技术2-map变量和map函数</title>
    <url>/2025/12/10/Linux%20Debug/bpftrace%E6%8A%80%E6%9C%AF2-map%E5%8F%98%E9%87%8F%E5%92%8Cmap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="map-的核心概念与用途">Map 的核心概念与用途</h1>
<p>在 bpftrace 中，符号 <code>@</code>用于定义和操作 <strong>Map 变量</strong>（或称映射变量）。这是 bpftrace 实现高效数据聚合的核心机制，你可以把它理解为一个在内核中运行的、功能强大的<strong>迷你数据库</strong></p>
<p>Map 的主要作用是在不同的事件探针（probe）之间<strong>存储、共享和聚合数据</strong>。当某个事件触发时，你可以将数据记录到 Map 中；当另一个相关事件触发时，再从中读取或更新数据。这使得实现复杂的追踪逻辑成为可能。</p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>数据持久化</strong>​</td>
<td>Map 中的数据在多个探针事件之间保持存在，不像普通变量那样每次事件触发后就被重置。（全局变量）</td>
</tr>
<tr class="even">
<td><strong>键值对结构</strong>​</td>
<td>Map 使用键（key）来索引值（value），格式为 <code>@map_name[key] = value</code>。键可以是单一值，也可以是多个值的组合（如 <code>@a[pid, comm]</code>）。kv结构</td>
</tr>
<tr class="odd">
<td><strong>自动输出</strong>​</td>
<td>默认情况下，当 bpftrace 程序退出时（例如你按下 <code>Ctrl-C</code>），所有非空的 Map 内容会自动打印到屏幕上。</td>
</tr>
</tbody>
</table>
<h1 id="map-的常见操作与示例"> Map 的常见操作与示例</h1>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 24%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>操作/函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>赋值</strong>​</td>
<td>直接给 Map 赋值。</td>
<td><code>@start_time[tid] = nsecs</code>(记录线程的开始时间)</td>
</tr>
<tr class="even">
<td><strong>计数 (<code>count()</code>)</strong>​</td>
<td>统计事件发生的次数。</td>
<td><code>@syscall_count[comm] = count()</code>(统计每个进程名的系统调用次数)</td>
</tr>
<tr class="odd">
<td><strong>求和 (<code>sum()</code>)</strong>​</td>
<td>对数值进行累加。</td>
<td><code>@total_bytes[pid] = sum(args-&gt;ret)</code>(累计每个进程读取的总字节数)</td>
</tr>
<tr class="even">
<td><strong>统计 (<code>avg()</code>, <code>min()</code>, <code>max()</code>)</strong>​</td>
<td>计算平均值、最小值、最大值。</td>
<td><code>@response_time = avg($latency)</code></td>
</tr>
<tr class="odd">
<td><strong>直方图 (<code>hist()</code>)</strong>​</td>
<td><strong>非常实用</strong>，生成2的幂次方的直方图，直观展示数据分布。</td>
<td><code>@latency_ns = hist(nsecs - @start[tid])</code>(可视化读操作的延迟分布)</td>
</tr>
<tr class="even">
<td><strong>线性直方图 (<code>lhist()</code>)</strong>​</td>
<td>生成自定义区间的线性直方图。</td>
<td><code>@read_sizes = lhist(args-&gt;ret, 0, 10000, 1000)</code>(统计读取大小的分布)</td>
</tr>
<tr class="odd">
<td><strong>数据清理 (<code>delete()</code>)</strong>​</td>
<td>从 Map 中删除特定的键值对，防止内存无限增长。</td>
<td><code>delete(@start_time[tid])</code>(在处理完一个事件后清理对应的开始时间)</td>
</tr>
</tbody>
</table>
<h1 id="与其他变量的区别"> 与其他变量的区别</h1>
<table>
<thead>
<tr class="header">
<th>变量类型</th>
<th>前缀</th>
<th>作用域与用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Map 变量</strong>​</td>
<td><code>@</code></td>
<td><strong>全局</strong>。用于在探针之间持久化存储和聚合数据。</td>
</tr>
<tr class="even">
<td><strong>内置变量</strong>​</td>
<td>无</td>
<td><strong>只读</strong>。提供事件上下文信息，如 <code>pid</code>(进程ID)、<code>comm</code>(命令名)、<code>retval</code>(函数返回值)等。</td>
</tr>
<tr class="odd">
<td><strong>暂存变量</strong>​</td>
<td><code>$</code></td>
<td><strong>局部临时</strong>。用于单次探针触发过程中的中间计算，例如 <code>$duration = nsecs - @start[tid]</code>。</td>
</tr>
</tbody>
</table>
<h1 id="map函数参考表">map函数参考表</h1>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 36%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>函数原型</th>
<th>核心作用与参数说明</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>count()</code></strong>​</td>
<td><strong>计数</strong>。统计事件被触发的次数。无参数。</td>
<td>统计系统调用次数、函数调用次数等。</td>
</tr>
<tr class="even">
<td><strong><code>sum(int n)</code></strong>​</td>
<td><strong>求和</strong>。对参数 <code>n</code>的值进行累加。</td>
<td>计算总的字节读写量、总耗时等。</td>
</tr>
<tr class="odd">
<td><strong><code>avg(int n)</code></strong>​</td>
<td><strong>求平均值</strong>。计算参数 <code>n</code>的平均值。</td>
<td>计算平均延迟、平均数据包大小等。</td>
</tr>
<tr class="even">
<td><strong><code>min(int n)</code></strong>​</td>
<td><strong>求最小值</strong>。记录参数 <code>n</code>的最小值。</td>
<td>追踪最小延迟、最小数据块大小。</td>
</tr>
<tr class="odd">
<td><strong><code>max(int n)</code></strong>​</td>
<td><strong>求最大值</strong>。记录参数 <code>n</code>的最大值。</td>
<td>追踪最大延迟、最大数据块大小。</td>
</tr>
<tr class="even">
<td><strong><code>stats(int n)</code></strong>​</td>
<td><strong>统计摘要</strong>。返回参数 <code>n</code>的计数、平均值、总和、最小值、最大值。</td>
<td>获取一个指标的全面统计信息。</td>
</tr>
<tr class="odd">
<td><strong><code>hist(int n)</code></strong>​</td>
<td><strong>对数直方图</strong>。按2的幂次方区间（如 <code>[4-8)</code>, <code>[8-16)</code>）展示参数 <code>n</code>的分布。</td>
<td>直观展示延迟、数据大小的分布情况，易于发现模式。</td>
</tr>
<tr class="even">
<td><strong><code>lhist(int n, int min, int max, int step)</code></strong>​</td>
<td><strong>线性直方图</strong>。在指定的线性区间（<code>min</code>到<code>max</code>，步长为<code>step</code>）内展示参数 <code>n</code>的分布。</td>
<td>当需要自定义固定区间进行分析时使用。</td>
</tr>
<tr class="odd">
<td><strong><code>delete(@m[key])</code></strong>​</td>
<td><strong>删除键值对</strong>。从 Map <code>@m</code>中删除指定的 <code>key</code>及其对应的值。</td>
<td>清理临时数据，防止 Map 无限增长，常用于配对探针（如 kprobe/kretprobe）。</td>
</tr>
<tr class="even">
<td><strong><code>clear(@m)</code></strong>​</td>
<td><strong>清空 Map</strong>。清除 Map <code>@m</code>中的所有键值对。</td>
<td>在定时器（如 <code>interval</code>）中定期重置统计。</td>
</tr>
<tr class="odd">
<td><strong><code>zero(@m)</code></strong>​</td>
<td><strong>归零 Map</strong>。将 Map <code>@m</code>中所有键的值重置为 0。</td>
<td>重置计数或求和等数据，但保留键的结构。</td>
</tr>
</tbody>
</table>
<h1 id="例子">例子</h1>
<h2 id="count--统计系统调用次数">count()- 统计系统调用次数</h2>
<p>统计每个进程调用的系统调用次数</p>
<p><code>bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@count[bash]: 15</span><br><span class="line">@count[sshd]: 28</span><br><span class="line">@count[snmpd]: 102</span><br></pre></td></tr></table></figure></p>
<ul>
<li>@[comm]：以进程名 comm为键（key）。</li>
<li>count()：每次事件触发，对应键的值加 1</li>
</ul>
<h2 id="sumint-n--计算读取的总字节数">sum(int n)- 计算读取的总字节数</h2>
<p>累计所有进程通过 read 系统调用成功读取的字节数</p>
<p><code>bpftrace -e 'tracepoint:syscalls:sys_exit_read /args-&gt;ret &gt; 0/ { @bytes = sum(args-&gt;ret); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@bytes: 1048576</span><br></pre></td></tr></table></figure></p>
<ul>
<li>/args-&gt;ret &gt; 0/：过滤器，只处理成功读取（返回值大于0）的情况。</li>
<li>sum(args-&gt;ret)：对返回值（读取的字节数）进行累加</li>
</ul>
<h2 id="avgint-n--计算平均读取大小">avg(int n)- 计算平均读取大小</h2>
<p>计算每次 <code>read</code>系统调用成功读取的平均字节数。</p>
<p><code>bpftrace -e 'tracepoint:syscalls:sys_exit_read /args-&gt;ret &gt; 0/ { @avg_size = avg(args-&gt;ret); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@avg_size: 512</span><br></pre></td></tr></table></figure></p>
<ul>
<li>/args-&gt;ret &gt; 0/：过滤器，只处理成功读取（返回值大于0）的情况。</li>
<li>avg(args-&gt;ret)：对返回值（读取的字节数）求平均</li>
</ul>
<h2 id="statsint-n--获取完整的统计摘要">stats(int n)- 获取完整的统计摘要</h2>
<p>对 <code>read</code>系统调用的返回值进行全面的统计。</p>
<p><code>bpftrace -e 'tracepoint:syscalls:sys_exit_read /args-&gt;ret &gt; 0/ { @s = stats(args-&gt;ret); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@s: count 100, average 4096, total 409600, min 1, max 8192</span><br></pre></td></tr></table></figure></p>
<ul>
<li>/args-&gt;ret &gt; 0/：过滤器，只处理成功读取（返回值大于0）的情况。</li>
<li>stats(args-&gt;ret)：求调用次数，对返回值（读取的字节数）求平均，求总数，求最大最小值</li>
</ul>
<h2 id="histint-n--分析读取字节数的对数分布">hist(int n)- 分析读取字节数的对数分布</h2>
<p>显示 <code>read</code>系统调用返回值的分布，区间按2的幂次方划分。</p>
<p><code>bpftrace -e 'tracepoint:syscalls:sys_exit_read { @bytes = hist(args-&gt;ret); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@bytes:</span><br><span class="line">[0, 1]                12 |@@@@@@@@@@@@@@@@@@@@                                |</span><br><span class="line">[2, 4)                18 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     |</span><br><span class="line">[4, 8)                 0 |                                                    |</span><br><span class="line">...</span><br><span class="line">[128, 256)             1 |@</span><br></pre></td></tr></table></figure></p>
<ul>
<li>hist(args-&gt;ret)：分为2^x ~2^y 大小的桶，统计每个桶的里面的数目个数</li>
</ul>
<h2 id="lhistint-n-int-min-int-max-int-step--分析读取字节数的线性分布">lhist(int n, int min, int max, int step)- 分析读取字节数的线性分布</h2>
<p>使用线性直方图统计 <code>read</code>返回值，范围从0到2000，步长为200。</p>
<p><code>bpftrace -e 'tracepoint:syscalls:sys_exit_read { @bytes = lhist(args-&gt;ret, 0, 2000, 200); }'</code></p>
<p>输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@bytes:</span><br><span class="line">(..., 0)                0 |                                                    |</span><br><span class="line">[0, 200)              66 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span><br><span class="line">[200, 400)             2 |@                                                   |</span><br><span class="line">...</span><br><span class="line">[2000, ...)            39 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |</span><br></pre></td></tr></table></figure></p>
<ul>
<li>hist(args-&gt;ret)：分为0-200区间桶，统计每个桶的里面的数目个数</li>
</ul>
<h2 id="deletemkey--清理临时数据">delete(<span class="citation" data-cites="m">@m</span>[key])- 清理临时数据</h2>
<p>在计算函数耗时后，删除用于存储开始时间的临时键，避免 Map 无限增长。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kprobe:vfs_read </span></span><br><span class="line"><span class="string">			&#123; @start[tid] = nsecs; &#125; </span></span><br><span class="line"><span class="string">			   kretprobe:vfs_read /@start[tid]/ </span></span><br><span class="line"><span class="string">			   &#123; $duration_ns = nsecs - @start[tid]; </span></span><br><span class="line"><span class="string">				 @us = hist($duration_ns); </span></span><br><span class="line"><span class="string">			     delete(@start[tid]); &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>此函数通常用于配对操作的探针（如 <code>kprobe</code>和 <code>kretprobe</code>），在操作完成后及时清理资源</li>
</ul>
<h2 id="clearm和-zerom--重置-map">clear(<span class="citation" data-cites="m">@m</span>)和 zero(<span class="citation" data-cites="m">@m</span>)- 重置 Map</h2>
<p>每5秒打印并清空一次系统调用计数 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:raw_syscalls:sys_enter &#123; @[comm] = count(); &#125; interval:s:5 &#123; print(@); clear(@); &#125;&#x27;</span></span><br></pre></td></tr></table></figure> 输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@[Relay(89295)]: 3</span><br><span class="line">@[mini_init]: 4</span><br><span class="line">@[gmain]: 5</span><br><span class="line">@[Relay(909)]: 6</span><br><span class="line">@[Relay(893)]: 6</span><br><span class="line">@[systemd-udevd]: 37</span><br><span class="line">@[chronyd]: 40</span><br><span class="line">@[bpftrace]: 118</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>clear(@m)</code>会删除 Map 中的所有键值对。而 <code>zero(@m)</code>则将所有键的值重置为0，但保留键的结构 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:raw_syscalls:sys_enter &#123; @[comm] = count(); &#125; interval:s:5 &#123; print(@); zero(@); &#125;&#x27;</span></span><br></pre></td></tr></table></figure> 输出 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@[gmain]: 5</span><br><span class="line">@[Relay(893)]: 6</span><br><span class="line">@[Relay(909)]: 6</span><br><span class="line">@[Relay(89295)]: 9</span><br><span class="line">@[mini_init]: 12</span><br><span class="line">@[chronyd]: 44</span><br><span class="line">@[init]: 103</span><br><span class="line">@[bpftrace]: 114</span><br><span class="line">@[GnsPortTracker]: 242</span><br><span class="line">@[top]: 350</span><br><span class="line">@[grep]: 664</span><br><span class="line">@[sh]: 923</span><br><span class="line">@[Xwayland]: 1978</span><br><span class="line">@[ps]: 2778</span><br><span class="line">@[libuv-worker]: 4028</span><br><span class="line">@[ls]: 4256</span><br><span class="line">@[node]: 4722</span><br><span class="line">@[mini_init]: 0   &lt;---------主要看这个，明显没有调用，但是结构被保留下来了</span><br><span class="line">@[Relay(109)]: 3</span><br><span class="line">@[Relay(909)]: 6</span><br><span class="line">@[Relay(89295)]: 6</span><br><span class="line">@[Relay(893)]: 6</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="map特点">map特点</h1>
<ul>
<li><strong>自动打印</strong>：默认情况下，当 bpftrace 程序终止时（例如用户按下 <code>Ctrl-C</code>），所有非空的 Map 变量会自动打印出来。</li>
<li><strong>过滤条件</strong>：使用 <code>/&lt;filter&gt;/</code>可以设置条件，只有满足条件时才会执行后面的动作，这能有效提升脚本效率和输出内容的针对性</li>
<li><strong>结合变量</strong>：Map 函数常与内置变量（如 <code>comm</code>, <code>pid</code>, <code>nsecs</code>）或临时变量（以 <code>$</code>开头）结合使用，以实现复杂的追踪逻辑</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bpftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>bpftrace技术3-内置变量</title>
    <url>/2025/12/10/Linux%20Debug/bpftrace%E6%8A%80%E6%9C%AF3-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="内置变量">内置变量</h1>
<p>bpftrace 的内置变量是其强大功能的基石，它们能让你在脚本中轻松获取事件触发时的上下文信息。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 24%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>变量类别</th>
<th>变量名</th>
<th>说明与典型应用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>进程/线程信息</strong>​</td>
<td><code>pid</code></td>
<td>当前<strong>进程ID</strong>。用于过滤特定进程的事件。</td>
</tr>
<tr class="even">
<td></td>
<td><code>tid</code></td>
<td>当前<strong>线程ID</strong>。用于进行更精细的线程级分析。</td>
</tr>
<tr class="odd">
<td></td>
<td><code>comm</code></td>
<td>当前<strong>进程名</strong>（最多16个字符）。常用于按进程名进行统计和过滤。</td>
</tr>
<tr class="even">
<td></td>
<td><code>uid</code></td>
<td>当前<strong>用户ID</strong>。用于分析特定用户的操作。</td>
</tr>
<tr class="odd">
<td><strong>时间信息</strong>​</td>
<td><code>nsecs</code></td>
<td>自系统启动以来的<strong>纳秒级时间戳</strong>。常用于计算函数耗时、事件间隔等。</td>
</tr>
<tr class="even">
<td><strong>CPU/系统信息</strong>​</td>
<td><code>cpu</code></td>
<td>当前事件发生时所在的<strong>CPU处理器ID</strong>。</td>
</tr>
<tr class="odd">
<td></td>
<td><code>curtask</code></td>
<td>当前进程的内核<code>task_struct</code>结构体地址（以64位无符号整数表示），用于高级内核调试。</td>
</tr>
<tr class="even">
<td><strong>探针上下文信息</strong>​</td>
<td><code>arg0</code>, <code>arg1</code>, … <code>argN</code></td>
<td><strong>Kprobe/Uprobe 的参数</strong>。用于获取被探测函数的参数值（注意：Tracepoint 不可用）。</td>
</tr>
<tr class="odd">
<td></td>
<td><code>args</code></td>
<td><strong>Tracepoint 的参数结构体</strong>。用于通过 <code>args-&gt;field_name</code>的方式访问 Tracepoint 的特定字段。</td>
</tr>
<tr class="even">
<td></td>
<td><code>retval</code></td>
<td><strong>Kretprobe/Uretprobe 的返回值</strong>。用于获取被探测函数的返回值。</td>
</tr>
<tr class="odd">
<td></td>
<td><code>func</code></td>
<td>当前触发的 <strong>Kprobe/Uprobe 所探测的函数名</strong>。</td>
</tr>
<tr class="even">
<td></td>
<td><code>kstack</code>/ <code>ustack</code></td>
<td>当前时刻的<strong>内核栈</strong>或<strong>用户栈</strong>描述。用于分析代码执行路径，定位性能瓶颈</td>
</tr>
</tbody>
</table>
<h1 id="例子">例子</h1>
<h2 id="计算函数执行时间"><strong>计算函数执行时间</strong></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测量 vfs_read 函数的执行时间（微秒）</span></span><br><span class="line">~ » bpftrace -e &#x27;kprobe:vfs_read &#123; @start[tid] = nsecs; &#125;</span><br><span class="line">                                kretprobe:vfs_read /@start[tid]/ &#123;</span><br><span class="line">                                    $duration_us = (nsecs - @start[tid]) / 1000;</span><br><span class="line">                                    @us = hist($duration_us);</span><br><span class="line">                                    delete(@start[tid]);</span><br><span class="line">&#125;&#x27;</span><br><span class="line">Attaching 2 probes...</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">@start[551]: 84374532046638</span><br><span class="line">@start[323672]: 84374600291711</span><br><span class="line">@us:</span><br><span class="line">[0]                   45 |@@@@@                                               |</span><br><span class="line">[1]                  452 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</span><br><span class="line">[2, 4)               264 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      |</span><br><span class="line">[4, 8)               338 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              |</span><br><span class="line">[8, 16)               43 |@@@@                                                |</span><br><span class="line">[16, 32)              25 |@@                                                  |</span><br><span class="line">[32, 64)               4 |                                                    |</span><br><span class="line">[64, 128)              0 |                                                    |</span><br><span class="line">[128, 256)             0 |                                                    |</span><br><span class="line">[256, 512)             0 |                                                    |</span><br><span class="line">[512, 1K)              6 |                                                    |</span><br><span class="line">[1K, 2K)               0 |                                                    |</span><br><span class="line">[2K, 4K)               3 |                                                    |</span><br><span class="line">[4K, 8K)               1 |                                                    |</span><br></pre></td></tr></table></figure>
<h2 id="追踪特定进程的系统调用"><strong>追踪特定进程的系统调用</strong></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ » bpftrace -e &#x27;tracepoint:syscalls:sys_enter_openat /comm == &quot;top&quot;/ &#123;</span><br><span class="line">    printf(&quot;PID %d is opening: %s\n&quot;, pid, str(args-&gt;filename));</span><br><span class="line">&#125;&#x27;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">PID 323556 is opening: /proc/uptime</span><br><span class="line">PID 323556 is opening: /proc</span><br><span class="line">PID 323556 is opening: /proc/uptime</span><br><span class="line">PID 323556 is opening: /proc/1/stat</span><br><span class="line">PID 323556 is opening: /proc/1/statm</span><br><span class="line">PID 323556 is opening: /proc/2/stat</span><br><span class="line">PID 323556 is opening: /proc/2/statm</span><br><span class="line">PID 323556 is opening: /proc/7/stat</span><br></pre></td></tr></table></figure>
<h2 id="分析内核调用路径"><strong>分析内核调用路径</strong></h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 统计 ip_output 函数的调用栈，这里要注意，@[kstack]的key记录的是两条不同的调用链</span><br><span class="line">~ » bpftrace -e &#x27;kprobe:ip_output &#123; @[kstack] = count(); &#125;&#x27;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">@[</span><br><span class="line">    ip_output+5</span><br><span class="line">    __ip_queue_xmit+400</span><br><span class="line">    ip_queue_xmit+25</span><br><span class="line">    __tcp_transmit_skb+2666</span><br><span class="line">    __tcp_send_ack.part.0+198</span><br><span class="line">    tcp_send_ack+32</span><br><span class="line">    __tcp_ack_snd_check+66</span><br><span class="line">    tcp_rcv_established+660</span><br><span class="line">    tcp_v4_do_rcv+362</span><br><span class="line">    tcp_v4_rcv+3671</span><br><span class="line">    ip_protocol_deliver_rcu+55</span><br><span class="line">    ip_local_deliver_finish+138</span><br><span class="line">    ip_local_deliver+115</span><br><span class="line">    ip_sublist_rcv_finish+137</span><br><span class="line">    ip_sublist_rcv+410</span><br><span class="line">    ip_list_rcv+314</span><br><span class="line">    __netif_receive_skb_list_core+639</span><br><span class="line">    netif_receive_skb_list_internal+463</span><br><span class="line">    napi_complete_done+126</span><br><span class="line">    netvsc_poll+1451</span><br><span class="line">    __napi_poll+49</span><br><span class="line">    net_rx_action+680</span><br><span class="line">    handle_softirqs+244</span><br><span class="line">    __irq_exit_rcu+120</span><br><span class="line">    irq_exit_rcu+18</span><br><span class="line">    sysvec_hyperv_callback+180</span><br><span class="line">    asm_sysvec_hyperv_callback+31</span><br><span class="line">    pv_native_safe_halt+15</span><br><span class="line">    arch_cpu_idle+13</span><br><span class="line">    default_idle_call+46</span><br><span class="line">    do_idle+517</span><br><span class="line">    cpu_startup_entry+49</span><br><span class="line">    rest_init+218</span><br><span class="line">    arch_call_rest_init+18</span><br><span class="line">    start_kernel+1241</span><br><span class="line">    x86_64_start_reservations+37</span><br><span class="line">    __pfx_reserve_bios_regions+0</span><br><span class="line">    secondary_startup_64_no_verify+381</span><br><span class="line">]: 3</span><br><span class="line">@[</span><br><span class="line">    ip_output+5</span><br><span class="line">    __ip_queue_xmit+400</span><br><span class="line">    ip_queue_xmit+25</span><br><span class="line">    __tcp_transmit_skb+2666</span><br><span class="line">    __tcp_send_ack.part.0+198</span><br><span class="line">    tcp_send_ack+32</span><br><span class="line">    __tcp_ack_snd_check+66</span><br><span class="line">    tcp_rcv_established+660</span><br><span class="line">    tcp_v4_do_rcv+362</span><br><span class="line">    tcp_v4_rcv+3671</span><br><span class="line">    ip_protocol_deliver_rcu+55</span><br><span class="line">    ip_local_deliver_finish+138</span><br><span class="line">    ip_local_deliver+115</span><br><span class="line">    ip_sublist_rcv_finish+137</span><br><span class="line">    ip_sublist_rcv+410</span><br><span class="line">    ip_list_rcv+314</span><br><span class="line">    __netif_receive_skb_list_core+639</span><br><span class="line">    netif_receive_skb_list_internal+463</span><br><span class="line">    napi_complete_done+126</span><br><span class="line">    netvsc_poll+1451</span><br><span class="line">    __napi_poll+49</span><br><span class="line">    net_rx_action+680</span><br><span class="line">    handle_softirqs+244</span><br><span class="line">    __irq_exit_rcu+120</span><br><span class="line">    irq_exit_rcu+18</span><br><span class="line">    sysvec_hyperv_callback+180</span><br><span class="line">    asm_sysvec_hyperv_callback+31</span><br><span class="line">    pv_native_safe_halt+15</span><br><span class="line">    arch_cpu_idle+13</span><br><span class="line">    default_idle_call+46</span><br><span class="line">    do_idle+517</span><br><span class="line">    cpu_startup_entry+49</span><br><span class="line">    start_secondary+281</span><br><span class="line">    secondary_startup_64_no_verify+381</span><br><span class="line">]: 8</span><br></pre></td></tr></table></figure>
<p><img src="image1.png" /></p>
<h1 id="其他说明">其他说明</h1>
<ul>
<li>argX与 args的区别：arg0, arg1…用于 kprobe/uprobe，它们是简单的整数参数。而 args是一个结构体，专用于 tracepoint，需要通过 args-&gt;字段名来访问其成员。</li>
<li>查看 Tracepoint 参数：你可以使用 bpftrace -lv tracepoint:name命令来查看某个 tracepoint 有哪些参数可用。例如，要查看 write系统调用的参数，可以执行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ » bpftrace -lv tracepoint:syscalls:sys_enter_write</span><br><span class="line">tracepoint:syscalls:sys_enter_write</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    unsigned int fd</span><br><span class="line">    const char * buf</span><br><span class="line">    size_t count</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>bpftrace</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存子系统-Page Cache</title>
    <url>/2025/12/13/Linux%E5%86%85%E5%AD%98%E5%AD%90%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E5%AD%98%E5%AD%90%E7%B3%BB%E7%BB%9F-Page%20Cache/</url>
    <content><![CDATA[<h1 id="pagecache是什么">pagecache是什么</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/meminfo</span></span><br><span class="line">...</span><br><span class="line">Buffers:            1224 kB</span><br><span class="line">Cached:           111472 kB</span><br><span class="line">SwapCached:        36364 kB</span><br><span class="line">Active:          6224232 kB</span><br><span class="line">Inactive:         979432 kB</span><br><span class="line">Active(anon):    6173036 kB</span><br><span class="line">Inactive(anon):   927932 kB</span><br><span class="line">Active(file):      51196 kB</span><br><span class="line">Inactive(file):    51500 kB</span><br><span class="line">...</span><br><span class="line">Shmem:             10000 kB</span><br><span class="line">...</span><br><span class="line">SReclaimable:      43532 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Page Cache = Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</p>
<p><img src="pagecache.png" /></p>
<p>/proc/meminfo的解释见如下网站<a href="https://www.kernel.org/doc/Documentation/filesystems/proc.rst">https://www.kernel.org/doc/Documentation/filesystems/proc.rst</a></p>
<p>在 Page Cache 中，Active(file)+Inactive(file) 是 File-backed page（与文件对应的内存页），是你最需要关注的部分。因为你平时用的 mmap() 内存映射方式和 buffered I/O 来消耗的内存就属于这部分。</p>
<p>而 SwapCached 是在打开了 Swap 分区后，把 Inactive(anon)+Active(anon) 这两项里的匿名页给交换到磁盘（swap out），然后再读入到内存（swap in）后分配的内存。由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。这样做的目的也是为了减少 I/O。</p>
<p><img src="swapcache.png" /></p>
<p>SwapCached 只在 Swap 分区打开的情况下才会有，建议在生产环境中关闭 Swap 分区，因为 Swap 过程产生的 I/O 会很容易引起性能抖动。</p>
<p>下面解释一下free输出</p>
<p>buff/cache = Buffers + Cached + SReclaimable <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">free -k</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        7926580     7277960      492392       10000      156228      430680</span><br><span class="line">Swap:       8224764      380748     7844016</span><br></pre></td></tr></table></figure></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 18%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>指标</th>
<th>数据来源 (参考 <code>/proc/meminfo</code>)</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><code>Buffers</code></strong>​</td>
<td><code>Buffers</code>值</td>
<td>临时存放<strong>原始磁盘块数据</strong>，用于优化对磁盘（块设备）的直接读写操作。</td>
</tr>
<tr class="even">
<td><strong><code>Cached</code></strong>​</td>
<td><code>Cached</code>值</td>
<td>缓存<strong>从文件读取的数据</strong>（即页缓存/Page Cache），使得再次访问这些文件时可以直接从内存快速读取，无需访问磁盘。</td>
</tr>
<tr class="odd">
<td><strong><code>SReclaimable</code></strong>​</td>
<td><code>SReclaimable</code>值</td>
<td>属于 <strong>Slab 分配器</strong>​ 的一部分，记录内核对象（如目录项、inode 等）缓存中<strong>可以被回收</strong>占用的内存。指可以被回收的内核内存，包括 dentry 和 inode 等。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>实际场景中的表现：通过 vmstat等工具可以观察它们的变化。例如，当使用 dd命令向磁盘分区直接写入大量数据时（如 dd if=/dev/urandom of=/dev/sdb1 …），会观察到 Buffers显著增长，因为这是对原始磁盘块的操作。而当读写普通文件时（如 dd if=/dev/urandom of=/tmp/file …），则会看到 Cached部分明显增加，因为这些数据被文件系统缓存了。</p>
</blockquote>
<h1 id="pagecache出现的意义">pagecache出现的意义</h1>
<p>先看如何使用pagecache的方法</p>
<ul>
<li>第一种，应用程序维护自己的 Cache 做更加细粒度的控制，比如 MySQL 就是这样做的，你可以参考MySQL Buffer Pool 。</li>
<li>第二种，使用 Direct I/O 来绕过 Page Cache。</li>
</ul>
<p>pagecache的意义就是加速：标准 I/O 和内存映射会先把数据写入到 Page Cache，这样做会通过减少 I/O 次数来提升读写效率。</p>
<p>我们看一个具体的例子。首先，我们来生成一个 1G 大小的新文件，然后把 Page Cache 清空，确保文件内容不在内存中，以此来比较第一次读文件和第二次读文件耗时的差异。具体的流程如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=./dd.out bs=4096 count=((1024*256))</span><br></pre></td></tr></table></figure>
<p>清空 Page Cache，需要先执行一下 sync 来将脏页同步到磁盘再去 drop cache。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<p>读两次文件，计算耗时 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> <span class="built_in">cat</span> /home/yafang/test/dd.out &amp;&gt; /dev/null</span></span><br><span class="line">real  0m5.733s</span><br><span class="line">user  0m0.003s</span><br><span class="line">sys  0m0.213s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">time</span> <span class="built_in">cat</span> /home/yafang/test/dd.out &amp;&gt; /dev/null</span> </span><br><span class="line">real  0m0.132s</span><br><span class="line">user  0m0.001s</span><br><span class="line">sys  0m0.130s</span><br></pre></td></tr></table></figure></p>
<p>通过这样详细的过程你可以看到，第二次读取文件的耗时远小于第一次的耗时，这是因为第一次是从磁盘来读取的内容，磁盘 I/O 是比较耗时的，而第二次读取的时候由于文件内容已经在第一次读取时被读到内存了，所以是直接从内存读取的数据，内存相比磁盘速度是快很多的。这就是 Page Cache 存在的意义：减少 I/O，提升应用的 I/O 速度。</p>
<h1 id="pagecache机制">pagecache机制</h1>
<h2 id="pagecache产生">pagecache产生</h2>
<p>Page Cache 的产生有两种不同的方式：</p>
<ul>
<li>Buffered I/O（标准 I/O）；</li>
<li>Memory-Mapped I/O（存储映射 I/O）。 <img src="pagecache_twoway.png" /></li>
</ul>
<p>buffered/mmap都能产生 Page Cache，但是二者的还是有些差异的：标准 I/O 是写的 (write(2)) 用户缓冲区 (Userpace Page 对应的内存)，然后再将用户缓冲区里的数据拷贝到内核缓冲区 (Pagecache Page 对应的内存)；如果是读的 (read(2)) 话则是先从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区读数据，也就是 buffer 和文件内容不存在任何映射关系。</p>
<p>对于存储映射 I/O 而言，则是直接将 Pagecache Page 给映射到用户地址空间，用户直接读写 Pagecache Page 中内容。</p>
<p>显然，存储映射 I/O 要比标准 I/O 效率高一些，毕竟少了“用户空间到内核空间互相拷贝”的过程。这也是很多应用开发者发现，为什么使用内存映射 I/O 比标准 I/O 方式性能要好一些的主要原因。</p>
<p>我们来用具体的例子演示一下 Page Cache 是如何“诞生”的，就以其中的标准 I/O 为例，因为这是我们最常使用的一种方式，如下是一个简单的示例脚本：</p>
<h2 id="pagecache回收">pagecache回收</h2>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>内存子系统</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的linux性能查询命令</title>
    <url>/2025/12/09/Linux%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/%E5%B8%B8%E8%A7%81%E7%9A%84linux%E6%80%A7%E8%83%BD%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常见的linux性能查询命令">常见的linux性能查询命令</h1>
<p>Purpose: a single-page, production-ready cheatsheet for Linux/SRE triage. Optimized for fast on-call use: concise flags, copy-paste recipes, brief notes, and clear risk callouts.</p>
<p>Tip: Use your editor/browser search to jump to any command by its number, e.g., “## 41. lsof”.</p>
<h2 id="binaries-elf">Binaries &amp; ELF</h2>
<p>Cheat Card - Linked libs: <code>ldd /path/to/bin</code> (security caveat: may execute code in rare cases) - ELF headers/sections: <code>readelf -h /bin/ls</code>; sections: <code>readelf -S /bin/ls</code> - Symbols (prefer readelf): <code>readelf -Ws /bin/ls | grep ' FUNC '</code>; dynamic: <code>readelf -Ws -d /bin/ls</code> - Disassemble: <code>objdump -d /bin/ls | less</code> (add <code>-M intel</code> for Intel syntax) - Symbols via nm: <code>nm -D /bin/ls | grep symbol_name</code> - Requires: binutils (readelf/objdump/nm)</p>
<h2 id="ldd">1. ldd</h2>
<p>List shared library dependencies of executables and shared objects. - Basic: <code>ldd /path/to/bin</code> - Security caveat: may execute code in rare cases; avoid on untrusted binaries. - Alternative: <code>LD_TRACE_LOADED_OBJECTS=1 /lib64/ld-linux-x86-64.so.2 /path/to/bin</code> (still uses loader)</p>
<h2 id="text-data-utilities">Text &amp; Data Utilities</h2>
<p>Cheat Card - Search recursively: <code>grep -RIn --exclude-dir .git 'pattern' .</code>; context: <code>-C2</code> - Edit in-place: <code>sed -i.bak -E 's/old/new/g' file</code> (backup) - Summarize data: <code>awk -F, '{a[$1]+=$2} END{for(k in a) print k,a[k]}' file.csv</code> - JSON parse: <code>jq -r '.items[].metadata.name' file.json</code> - Compare dirs: <code>diff -ruN dir_old dir_new | less -R</code> - Transform text: <code>tr -s ' ' | cut -d, -f1,3 | xargs -n1 echo</code> - Safe temp: <code>mktemp -d</code> for dirs; files: <code>mktemp</code> - Reverse lines: <code>rev &lt;file</code> (quick visual check)</p>
<h2 id="grep">2. grep</h2>
<ul>
<li>search for one or more expressions: <code>grep -E 'hello|world' temp</code></li>
<li>search for one or more words: <code>grep -Ew 'hello|world' temp</code></li>
<li>search for suffix matches: <code>grep -E 'hello(world|lolo)' temp</code></li>
<li>search for suffixes matching regex: <code>grep -E 'hello[0-9]{3,}' temp</code></li>
<li>recursive search in tree: <code>grep -RIn --exclude-dir .git --exclude='*.log' 'pattern' .</code></li>
<li>fixed strings (fast) and ignore case: <code>grep -Fni 'literal text' file</code></li>
<li>context lines: <code>grep -R --color -n -C2 'pattern' .</code> (or <code>-A</code> after, <code>-B</code> before)</li>
<li>binary-skip and file names only: <code>grep -rI -l 'pattern' .</code></li>
</ul>
<h2 id="sed">3. sed</h2>
<p>What it does: stream editor for non-interactive find/replace, line edits, and range selections.</p>
<ul>
<li>In-place with backup: <code>sed -i.bak -E 's/old/new/g' file</code></li>
<li>Delete matching lines: <code>sed -i '/pattern/d' file</code></li>
<li>Print lines between markers: <code>sed -n '/BEGIN/,/END/p' file</code></li>
<li>Replace with capture groups: <code>sed -E 's/([0-9]{4})-([0-9]{2})-([0-9]{2})/\3-\2-\1/' file</code></li>
<li>Insert before/after match:
<ul>
<li>Before: <code>sed '/pattern/i\\inserted before' file</code></li>
<li>After: <code>sed '/pattern/a\\appended after' file</code></li>
</ul></li>
<li>Trim trailing spaces: <code>sed -i 's/[ \t]\+$//' file</code></li>
<li>Multiple edits: <code>sed -E -e 's/foo/bar/g' -e '/tmp/d' file</code></li>
</ul>
<h2 id="awk">4. awk</h2>
<p>What it does: text processing and quick data summarization using fields and expressions.</p>
<ul>
<li>Default FS is whitespace; set CSV FS: <code>awk -F, '...' file.csv</code></li>
<li>Select fields: <code>awk '{print $1, $3}' file</code></li>
<li>Filter rows: <code>awk '$5 &gt; 100 {print $1, $5}' file</code></li>
<li>Sum a column: <code>awk '{s+=$3} END{print s}' file</code></li>
<li>Group and sum by key: <code>awk '{a[$1]+=$2} END{for (k in a) print k, a[k]}' file</code></li>
<li>Pretty print: <code>awk '{printf "%-20s %10d\n", $1, $2}' file</code></li>
<li>Count unique values: <code>awk '{c[$1]++} END{for (k in c) print k, c[k]}' file</code></li>
</ul>
<h2 id="networking">Networking</h2>
<p>Cheat Card - Ports→PIDs: <code>ss -ltnp</code>; established only: <code>ss -tn state established</code> - TCP detail: <code>ss -i dst &lt;ip&gt;</code> (rtt, cwnd, retrans) - Path/source IP: <code>ip route get &lt;dest&gt;</code>; counters: <code>ip -s link show &lt;iface&gt;</code> - Latency/loss: <code>mtr -ezbw &lt;dest&gt;</code>; quick traceroute ICMP: <code>traceroute -I &lt;dest&gt;</code> - Targeted capture: <code>tcpdump -ni &lt;iface&gt; tcp port 443</code> (or <code>port 53</code>, <code>icmp</code>) - DNS: <code>resolvectl query &lt;name&gt;</code> or <code>dig &lt;name&gt; A +short</code></p>
<h2 id="ping">5. ping</h2>
<ul>
<li><p>Compat: Linux; Root: may require CAP_NET_RAW depending on system; Requires: iputils-ping.</p></li>
<li><p><code>-4</code>: ping IPv4 only</p></li>
<li><p><code>-6</code>: ping IPv6 only</p></li>
<li><p><code>-A</code>: adapts to roundtrip time</p></li>
<li><p><code>-b</code>: allow pinging broadcast addresses</p></li>
<li><p><code>-I</code>: ping through an interface</p></li>
<li><p><code>-M</code>: set PMTU strategy</p></li>
<li><p><code>-s</code>: set packetsize (default is 56B)</p></li>
<li><p><code>-t</code>: set IP time-to-live</p></li>
<li><p><code>ping 224.0.0.1</code>: ping multicast address</p></li>
</ul>
<p>Notes: - Using average <code>rtt</code> values, you can determine whether there are huge variations causing jitter, especially in RT applications - ping will report duplications, however, duplicate packets should never occur, and seem to be caused by inappropriate link-level retransmissions - ping will report damaged packets, suggesting broken hardware in the network Requires: iputils-ping.</p>
<h2 id="ip">6. ip</h2>
<ul>
<li><p>Compat: Linux; Root: not required for reads; Requires: iproute2.</p></li>
<li><p><code>ip addr</code>: Show information for all addresses</p></li>
<li><p><code>ip addr show dev wlo1</code>: Display information only for device wlo1</p></li>
<li><p><code>ip link</code>: Show information for all interfaces</p></li>
<li><p><code>ip link show dev wlo1</code>: Display information only for device wlo1</p></li>
<li><p><code>ip -s</code>: Display interface statistics (packets dropped, received, sent, etc.)</p></li>
<li><p>Quick recipes:</p>
<ul>
<li>Path and source IP: <code>ip route get &lt;dest&gt;</code></li>
<li>Interface counters: <code>ip -s link show &lt;iface&gt;</code> (rx/tx errors, drops)</li>
<li>Neighbors/ARP: <code>ip neigh</code> and <code>ip neigh show dev &lt;iface&gt;</code></li>
<li>Multicast: <code>ip maddr</code> or <code>ip maddr show dev &lt;iface&gt;</code></li>
</ul></li>
</ul>
<p>Example <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Query path and chosen source IP</span></span><br><span class="line">ip route get 8.8.8.8</span><br><span class="line"><span class="comment"># Expect: 8.8.8.8 via 192.168.1.1 dev wlo1 src 192.168.1.23</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>ip route</code>: List all of the route entries in the kernel</p></li>
<li><p><code>ip route add</code>: Add a route entry to the kernel routing table</p></li>
<li><p><code>ip route replace</code>: Replace an existing route (add if not present)</p></li>
<li><p><code>ip maddr</code>: Display multicast information for all devices</p></li>
<li><p><code>ip maddr show dev wlo1</code></p></li>
<li><p><code>ip neigh show dev wlo1</code>: check for reachability of specific interfaces<br />
Requires: iproute2.</p></li>
</ul>
<h2 id="arp">7. arp</h2>
<ul>
<li><p>Compat: Legacy; prefer <code>ip neigh</code>; Requires: net-tools.</p></li>
<li><p><code>arp</code>: show all ARP table entries</p></li>
<li><p><code>arp -d address</code>: delete ARP entry for address</p></li>
<li><p><code>arp -s address hw_addr</code>: set up new table entry Note: legacy from net-tools; prefer <code>ip neigh</code>. Requires: net-tools.</p></li>
</ul>
<h2 id="arping">8. arping</h2>
<ul>
<li><p>Compat: Linux; Root/CAP_NET_RAW required; Package: arping (iputils-arping on some distros).</p></li>
<li><p><code>arping -I wlo1 192.168.0.1</code>: send ARP requests to host</p></li>
<li><p><code>arping -D -I wlo1 192.168.0.15</code>: check for duplicate MAC address Requires: arping (iputils-arping on some distros).</p></li>
</ul>
<h2 id="ethtool">9. ethtool</h2>
<ul>
<li><p>Compat: Linux; Root for changing settings, read stats usually ok; Requires: ethtool.</p></li>
<li><p><code>ethtool -S wlo1</code>: print network statistics Requires: ethtool.</p></li>
</ul>
<h2 id="ss">10. ss</h2>
<ul>
<li><p>Compat: Linux; Modern replacement for netstat; Requires: iproute2.</p></li>
<li><p><code>ss -a</code>: show all sockets</p></li>
<li><p><code>ss -o</code>: show all sockets with timer information</p></li>
<li><p><code>ss -p</code>: show process using the socket</p></li>
<li><p><code>ss -t|-u|-4|-6</code></p></li>
<li><p><code>ss -ltnp</code>: list listening TCP sockets with PIDs</p></li>
<li><p><code>ss -tn state established</code>: show established TCP only</p></li>
<li><p><code>ss -tn sport = :443</code> or <code>ss -tn dport = :443</code>: filter by port</p></li>
<li><p><code>ss -s</code>: summary stats (TCP states, mem)</p></li>
<li><p><code>ss -i</code>:</p>
<ul>
<li><code>ts</code>: show string “ts” if the timestamp option is set</li>
<li><code>sack</code>: show string “sack” if the sack option is set</li>
<li><code>ecn</code>: show string “ecn” if the explicit congestion notification option is set</li>
<li><code>ecnseen</code>: show string “ecnseen” if the saw ecn flag is found in received packets</li>
<li><code>fastopen</code>: show string “fastopen” if the fastopen option is set</li>
<li><code>cong_alg</code>: the congestion algorithm name, the default congestion algorithm is “cubic”</li>
<li><code>wscale:&lt;snd_wscale&gt;:&lt;rcv_wscale&gt;</code>: if window scale option is used, this field shows the send scale factor and receive scale factor</li>
<li><code>rto:&lt;icsk_rto&gt;</code>: tcp re-transmission timeout value, the unit is millisecond</li>
<li><code>backoff:&lt;icsk_backoff&gt;</code>: used for exponential backoff re-transmission, the actual re-transmission timeout value is icsk_rto &lt;&lt; icsk_backoff</li>
<li><code>rtt:&lt;rtt&gt;/&lt;rttvar&gt;</code>: rtt is the average round trip time, rttvar is the mean deviation of rtt, their units are millisecond</li>
<li><code>ato:&lt;ato&gt;</code>: ack timeout, unit is millisecond, used for delay ack mode</li>
<li><code>mss:&lt;mss&gt;</code>: max segment size</li>
<li><code>cwnd:&lt;cwnd&gt;</code>: congestion window size</li>
<li><code>pmtu:&lt;pmtu&gt;</code>: path MTU value</li>
<li><code>ssthresh:&lt;ssthresh&gt;</code>: tcp congestion window slow start threshold</li>
<li><code>bytes_acked:&lt;bytes_acked&gt;</code>: bytes acked</li>
<li><code>bytes_received:&lt;bytes_received&gt;</code>: bytes received</li>
<li><code>segs_out:&lt;segs_out&gt;</code>: segments sent out</li>
<li><code>segs_in:&lt;segs_in&gt;</code>: segments received</li>
<li><code>send &lt;send_bps&gt;bps</code>: egress bps</li>
<li><code>lastsnd:&lt;lastsnd&gt;</code>: how long time since the last packet sent, the unit is millisecond</li>
<li><code>lastrcv:&lt;lastrcv&gt;</code>: how long time since the last packet received, the unit is millisecond</li>
<li><code>lastack:&lt;lastack&gt;</code>: how long time since the last ack received, the unit is millisecond</li>
</ul></li>
<li><p><code>ss -A tcp,udp</code>: dump socket tables Requires: iproute2.</p></li>
</ul>
<h2 id="tcpdump">37. tcpdump</h2>
<p>Compat: Linux; Root/CAP_NET_RAW required for captures; Requires: tcpdump. What it does: capture packets for inspection and troubleshooting. Requires: tcpdump.</p>
<ul>
<li>Interface and no name resolution: <code>tcpdump -ni &lt;iface&gt;</code></li>
<li>Host or subnet: <code>tcpdump -ni &lt;iface&gt; host &lt;ip&gt;</code>; <code>tcpdump -ni &lt;iface&gt; net 10.0.0.0/8</code></li>
<li>Ports/protocols: <code>tcpdump -ni &lt;iface&gt; tcp port 443</code> or <code>udp port 53</code></li>
<li>SYNs only (new TCP handshakes): <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># New TCP handshakes only (SYN without ACK)</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; <span class="string">&#x27;tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) == 0&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>DNS queries: <code>tcpdump -ni &lt;iface&gt; port 53</code></li>
<li>ICMP reachability: <code>tcpdump -ni &lt;iface&gt; icmp</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Requires: tcpdump</span></span><br><span class="line"><span class="comment"># Capture full packets to a file</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; -s 0 -w capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rotate captures every 5m, keep 6 files</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; -s 0 -G 300 -W 6 -w <span class="string">&#x27;cap-%Y%m%d%H%M%S.pcap&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mtr">38. mtr</h2>
<p>Compat: Linux; May need root/CAP_NET_RAW for certain probe types; Requires: mtr. What it does: combines ping and traceroute to visualize latency and loss per hop.</p>
<ul>
<li>Run with extra info: <code>mtr -ezbw &lt;dest&gt;</code></li>
<li>Report mode (one-off): <code>mtr -ezbwrc 10 &lt;dest&gt;</code> Requires: mtr.</li>
</ul>
<h2 id="traceroute">39. traceroute</h2>
<ul>
<li><p>Compat: Linux; Requires: traceroute; TCP mode may need CAP_NET_RAW/root.</p></li>
<li><p><code>traceroute -I</code>: use ICMP echo for probes</p></li>
<li><p><code>traceroute -T</code>: use TCP SYN for probes Requires: traceroute.</p></li>
</ul>
<h2 id="nicstat">40. nicstat</h2>
<ul>
<li><p>Compat: Linux; Not widely packaged; Consider <code>sar -n</code>/<code>ethtool -S</code> alternatives.</p></li>
<li><p>nicstat prints out network statistics for all network cards (NICs), including packets, kilobytes per second, average packet sizes and more.</p></li>
<li><p><code>nicstat -t</code>: show CPU stats</p></li>
<li><p><code>nicstat</code>: show network interface stats Requires: nicstat (may need third-party repo/source on some distros).</p></li>
</ul>
<details>
<summary>
Metrics reference (click to expand)
</summary>
<ul>
<li><code>Time</code> - The time corresponding to the end of the sample shown, in HH:MM:SS format (24-hour clock).</li>
<li><code>Int</code> - The interface name.</li>
<li><code>rKB/s, InKB</code> - Kilobytes/second read (received).</li>
<li><code>wKB/s, OutKB</code> - Kilobytes/second written (transmitted).</li>
<li><code>rMbps, RdMbps</code> - Megabits/second read (received).</li>
<li><code>wMbps, WrMbps</code> - Megabits/second written (transmitted).</li>
<li><code>rPk/s, InSeg, InDG</code> - Packets (TCP Segments, UDP Datagrams)/second read (received).</li>
<li><code>wPk/s, OutSeg, OutDG</code> - Packets (TCP Segments, UDP Datagrams)/second written (transmitted).</li>
<li><code>rAvs</code> - Average size of packets read (received).</li>
<li><code>wAvs</code> - Average size of packets written (transmitted).</li>
<li><code>%Util</code> - Percentage utilization of the interface. For full-duplex interfaces, this is the greater of rKB/s or wKB/s as a percentage of the interface speed. For half-duplex interfaces, rKB/s and wKB/s are summed.</li>
<li><code>%rUtil, %wUtil</code> - Percentage utilization for bytes read and written, respectively.</li>
<li><code>Sat</code> - Saturation. This the number of errors/second seen for the interface
<ul>
<li>an indicator the interface may be approaching saturation. This statistic is combined from a number of kernel statistics. It is recommended to use the ‘-x’ option to see more individual statistics (those mentioned below) when attempting to diagnose a network issue.</li>
</ul></li>
<li><code>IErr</code> - Packets received that could not be processed because they contained errors</li>
<li><code>OErr</code> - Packets that were not successfully transmitted because of errors</li>
<li><code>Coll</code> - Ethernet collisions during transmit.</li>
<li><code>NoCP</code> - No-can-puts. This is when an incoming packet can not be put to the process reading the socket. This suggests the local process is unable to process incoming packets in a timely manner.</li>
<li><code>Defer</code> - Defer Transmits. Packets without collisions where first transmit attempt was delayed because the medium was busy.</li>
<li><code>Reset</code> - tcpEstabResets. The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.</li>
<li><code>AttF</code> - tcpAttemptFails - The number of times that TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.</li>
<li><code>%ReTX</code> - Percentage of TCP segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets.</li>
<li><code>InConn</code> - tcpPassiveOpens - The number of times that TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state.</li>
<li><code>OutCon</code> - tcpActiveOpens - The number of times that TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state.</li>
<li><code>Drops</code> - tcpHalfOpenDrop + tcpListenDrop + tcpListenDropQ0. tcpListenDrop and tcpListenDropQ0 - Number of connections dropped from the completed connection queue and incomplete connection queue, respectively. tcpHalfOpenDrops - Number of connections dropped after the initial SYN packet was received.</li>
</ul>
</details>
<h2 id="nslookup">41. nslookup</h2>
<ul>
<li>Compat: Legacy; prefer <code>dig</code>/<code>resolvectl</code>; Requires: dnsutils/bind-utils.</li>
</ul>
<p>query Internet name servers interactively</p>
<ul>
<li><code>nslookup &lt;domain&gt;</code></li>
<li>Note: legacy tool. Prefer <code>dig</code> for detailed queries or <code>resolvectl</code> on systemd-based systems. Requires: dnsutils/bind-utils (for nslookup/dig).</li>
<li>Quick equivalents: <code>dig &lt;domain&gt; A +short</code>; <code>resolvectl query &lt;domain&gt;</code></li>
</ul>
<h2 id="host">42. host</h2>
<ul>
<li>Compat: Linux; Requires: bind9-host/bind-utils.</li>
</ul>
<p>host is a simple utility for performing DNS lookups. It is normally used to convert names to IP addresses and vice versa.</p>
<ul>
<li><code>host &lt;domain&gt;</code></li>
<li>Examples: <code>host -t A &lt;domain&gt;</code>; reverse lookup: <code>host &lt;ip&gt;</code></li>
<li>Tip: for more control, use <code>dig</code> (if installed) or <code>resolvectl</code>. Requires: bind9-host (Debian/Ubuntu) or bind-utils.</li>
</ul>
<h2 id="iwconfig">43. iwconfig</h2>
<ul>
<li><p>Compat: Legacy; prefer <code>iw</code>; Requires: wireless-tools.</p></li>
<li><p><code>iwconfig wlo1</code>: show WLAN config:</p></li>
<li><p>Note: <code>iwconfig</code> is legacy (wireless-tools). Prefer <code>iw</code> for modern drivers, e.g., <code>iw dev</code>, <code>iw dev wlo1 link</code>. Requires: wireless-tools. Modern alternative: iw.</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wlo1      IEEE 802.11  ESSID:&quot;NETGEAR97&quot;  </span><br><span class="line">      Mode:Managed  Frequency:2.462 GHz  Access Point: C4:04:15:58:60:C7   </span><br><span class="line">      Bit Rate=72.2 Mb/s   Tx-Power=20 dBm   </span><br><span class="line">      Retry short limit:7   RTS thr=2347 B   Fragment thr:off</span><br><span class="line">      Power Management:off</span><br><span class="line">      Link Quality=70/70  Signal level=-32 dBm  </span><br><span class="line">      Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0</span><br><span class="line">      Tx excessive retries:0  Invalid misc:22932   Missed beacon:0</span><br></pre></td></tr></table></figure>
<h2 id="brctl">44. brctl</h2>
<ul>
<li><p>Compat: Legacy; prefer <code>ip link</code> and <code>bridge</code>; Requires: bridge-utils.</p></li>
<li><p>brctl is used to set up, maintain, and inspect the ethernet bridge configuration in the linux kernel. Legacy: prefer <code>ip link add name br0 type bridge</code> and <code>bridge</code> (iproute2) tooling. Requires: bridge-utils.</p></li>
</ul>
<h2 id="kernel-tracing">Kernel &amp; Tracing</h2>
<p>Cheat Card - Kernel logs: <code>dmesg -T -l err,crit,alert,emerg</code> - Syscalls: <code>strace -ttT -p &lt;pid&gt; -f -e trace=network,file</code> - Modules: <code>lsmod | head</code>, <code>modprobe &lt;name&gt;</code> (caution), <code>sysctl -a | grep tcp</code> - Optional advanced: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># perf (if installed)</span></span><br><span class="line">perf top</span><br><span class="line">perf record -g -p &lt;pid&gt;; perf report</span><br><span class="line"></span><br><span class="line"><span class="comment"># bpftrace one-liner (Requires: bpftrace)</span></span><br><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_openat &#123; @[comm] = count(); &#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="dmesg">11. dmesg</h2>
<ul>
<li><p>Compat: Linux; May be restricted by <code>kernel.dmesg_restrict</code>; Requires: util-linux.</p></li>
<li><p><code>dmesg --level=&lt;LEVEL&gt;</code> where <code>&lt;LEVEL&gt;</code> is:</p>
<ul>
<li><code>emerg</code> - system is unusable.</li>
<li><code>alert</code> - action must be taken immediately.</li>
<li><code>crit</code> - critical conditions.</li>
<li><code>err</code> - error conditions.</li>
<li><code>warn</code> - warning conditions.</li>
<li><code>notice</code> - normal but significant condition.</li>
<li><code>info</code> - informational.</li>
<li><code>debug</code> - debug-level messages.</li>
</ul></li>
<li><p><code>dmesg -k</code>: print kernel messages</p></li>
<li><p><code>dmesg -f=&lt;FACILITY&gt;</code> where <code>&lt;FACILITY&gt;</code> is:</p>
<ul>
<li><code>kern</code>: Kernel messages.</li>
<li><code>user</code>: User-level messages.</li>
<li><code>mail</code>: Mail system.</li>
<li><code>daemon</code>: System daemons.</li>
<li><code>auth</code>: Security/authorization messages.</li>
<li><code>syslog</code>: Internal syslogd messages.</li>
<li><code>lpr</code>: Line printer subsystem.</li>
<li><code>news</code>: Network news subsystem.</li>
</ul></li>
<li><p><code>dmesg -T</code>: human readable timestamps</p></li>
</ul>
<h2 id="lsmod">12. lsmod</h2>
<ul>
<li><p>Compat: Linux; Lists modules without root; Requires: kmod.</p></li>
<li><p>Show loaded kernel modules and sizes/dependencies.</p></li>
<li><p>Quick peek: <code>lsmod | head</code></p></li>
<li><p>Module info (version, params): <code>modinfo &lt;module&gt;</code></p></li>
</ul>
<h2 id="modprobe">13. modprobe</h2>
<ul>
<li>Compat: Linux; Root required; Caution: can destabilize systems; Requires: kmod.</li>
</ul>
<p>Add or remove modules from the Linux kernel. - Load: <code>modprobe &lt;module&gt;</code>; with params: <code>modprobe &lt;module&gt; key=value</code> - Unload: <code>modprobe -r &lt;module&gt;</code> (fails if in use) - Caution: loading/unloading modules can destabilize systems; prefer persistent config and ensure module compatibility.</p>
<h2 id="disk-filesystems">Disk &amp; Filesystems</h2>
<p>Cheat Card - Space/inodes: <code>df -h</code> and <code>df -i</code>; biggest dirs: <code>du -xhd1 /path | sort -h</code> - IO saturation: <code>iostat -xz 1</code>; per-proc IO: <code>pidstat -d 1</code>, <code>iotop -oPa</code> - Devices/FS: <code>lsblk -o NAME,TYPE,SIZE,ROTA,MOUNTPOINT,MODEL</code>; mounts: <code>findmnt</code> - Mount ops: <code>mount --bind olddir newdir</code>; remount ro: <code>mount -o remount,ro /mnt</code></p>
<p>Inventory and health - Device tree: <code>lsblk -o NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,MODEL</code> - Identify filesystem UUID/TYPE: <code>blkid</code> - SMART check (if supported): <code>smartctl -H /dev/sdX</code> and <code>smartctl -a /dev/sdX</code> (Requires: smartmontools) - NVMe info: <code>nvme list</code>; <code>nvme smart-log /dev/nvme0</code> (Requires: nvme-cli)</p>
<p>Notes - iostat quick view (Requires: sysstat): <code>iostat -xz 1</code> (watch <code>await</code>, <code>%util</code>, <code>r/s</code>, <code>w/s</code>) - findmnt: show mount hierarchy or lookup by target: <code>findmnt /mount/point</code></p>
<ul>
<li>adds or removes modules from the Linux Kernel</li>
<li>Caution: loading/unloading modules can destabilize systems; prefer persistent config and ensure module compatibility.</li>
</ul>
<h2 id="dd-danger-destructive-read-first">14. dd (DANGER: DESTRUCTIVE — READ FIRST)</h2>
<ul>
<li><p>Compat: Linux; Root required for raw devices; Highly destructive when writing; Requires: coreutils.</p></li>
<li><p>Danger: dd will overwrite data with no confirmation. Double-check devices (e.g., <code>/dev/sdX</code>) and consider read-only or safer alternatives first. Use <code>lsblk</code>, <code>blkid</code> to verify targets.</p></li>
<li><p>Safer tips: for copies, consider <code>pv</code> to visualize throughput; for imaging, <code>dcfldd</code>; for testing, prefer non-destructive reads.</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Danger: wipes target disk. Verify device with lsblk/blkid.</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=4k status=progress</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Verify a drive is zeroed (non-zero bytes check)</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda status=none | hexdump -C | grep -q <span class="string">&#x27;[^00]&#x27;</span> || <span class="built_in">echo</span> <span class="string">&quot;All zeros&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fill a file with random data (example size)</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=myfile bs=6703104 count=1 status=progress</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Danger: clone a partition to another (same size/align). Verify both!</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda3 of=/dev/sdb3 bs=4096 status=progress conv=fsync</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Danger: write an image to a USB device. Verify device path first!</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/path/to/bootimage.img of=/dev/sdc bs=4M status=progress conv=fsync</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Quick r/w benchmark for a file (non-destructive read + temp write)</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/home/<span class="variable">$user</span>/bigfile of=/dev/null status=progress</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/home/<span class="variable">$user</span>/bigfile bs=1M count=1000 oflag=dsync status=progress</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sequential device read throughput sample (approx 1 GiB)</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sda of=/dev/null bs=1024k count=1024 status=progress</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a swapfile (example: 8 GiB), then mkswap + swapon</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=swapfile bs=1MiB count=$((<span class="number">8</span>*<span class="number">1024</span>)) status=progress</span><br></pre></td></tr></table></figure>
<h2 id="jq">15. jq</h2>
<ul>
<li>Compat: Linux; Requires: jq package.</li>
</ul>
<p>What it does: parse/query/transform JSON on the command line. Requires: jq.</p>
<ul>
<li>Pretty-print: <code>jq . file.json</code></li>
<li>Extract field list: <code>jq -r '.items[].metadata.name' file.json</code></li>
<li>Filter by condition: <code>jq '.[] | select(.status=="RUNNING")' file.json</code></li>
<li>Transform and count: <code>jq '[.[] | .level] | group_by(.) | map({level: .[0], count: length})' file.json</code></li>
<li>Sort and top N: <code>jq 'sort_by(.time) | reverse | .[0:5]' file.json</code></li>
<li>From journald: <code>journalctl -o json | jq -r 'select(.PRIORITY&lt;=3) | .MESSAGE'</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Requires: jq — show high-priority messages from journald</span></span><br><span class="line">journalctl -o json | jq -r <span class="string">&#x27;select(.PRIORITY&lt;=3) | .MESSAGE&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>Keys and length: <code>jq 'keys, length' file.json</code></li>
</ul>
<h2 id="diff">16. diff</h2>
<ul>
<li><p>Compat: Linux; Requires: diffutils.</p></li>
<li><p>unified diff: <code>diff -u old.txt new.txt</code></p></li>
<li><p>recursive dirs: <code>diff -ruN dir_old dir_new</code></p></li>
<li><p>ignore whitespace changes: <code>diff -u -w old new</code></p></li>
<li><p>handle CRLF: <code>diff -u --strip-trailing-cr a b</code></p></li>
<li><p>color (if supported): <code>diff --color=auto -u a b</code></p></li>
<li><p>apply a patch: <code>patch -p1 &lt; change.diff</code></p></li>
</ul>
<h2 id="uname">17. uname</h2>
<ul>
<li><p>Compat: Linux; Requires: coreutils.</p></li>
<li><p>get all details about the computer</p></li>
</ul>
<h2 id="syncfsync">18. sync/fsync</h2>
<ul>
<li><p>Compat: Linux; <code>sync</code> is user command; <code>fsync</code> is a syscall.</p></li>
<li><p><code>fsync</code> is a syscall that flushes a file’s in-memory data and metadata to storage. From the shell, use <code>sync</code> (flush all dirty data) or <code>syncfs</code> (flush a filesystem) when available.</p></li>
</ul>
<h2 id="mkswap">19. mkswap</h2>
<ul>
<li><p>Compat: Linux; Root required; Requires: util-linux.</p></li>
<li><p><code>-c</code>: check if blocks are corrupted</p></li>
<li><p><code>-p</code>: set pagesize</p></li>
</ul>
<h2 id="fsck">20. fsck</h2>
<ul>
<li><p>Compat: Linux; Root required; Avoid on mounted filesystems; Requires: e2fsprogs for ext*.</p></li>
<li><p>check for file system consistency:</p>
<ul>
<li>The superblock is checked for inconsistencies in:
<ul>
<li>File system size</li>
<li>Number of inodes</li>
<li>Free-block count</li>
<li>Free-inode count</li>
</ul></li>
<li>Each inode is checked for inconsistencies in:
<ul>
<li>Format and type</li>
<li>Link count</li>
<li>Duplicate block</li>
<li>Bad block numbers</li>
<li>Inode size</li>
</ul></li>
</ul></li>
<li><p>see: https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7uf0e/index.html</p></li>
<li><p>Caution: avoid running fsck on a mounted filesystem (except with specific fs support); prefer read-only mounts or maintenance windows.</p></li>
</ul>
<p>Extended notes - ext* specifics: <code>e2fsck</code> checks ext2/3/4; use <code>-f</code> to force, <code>-n</code> for read-only, <code>-p</code> for preen (auto-fix safe issues). Requires: e2fsprogs. - Bad blocks (DANGER): <code>badblocks</code> scans devices for bad sectors; write-mode is destructive. Prefer read-only first.</p>
<p>Examples <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read-only badblocks scan (non-destructive)</span></span><br><span class="line"><span class="built_in">sudo</span> badblocks -sv /dev/sdX</span><br><span class="line"></span><br><span class="line"><span class="comment"># DANGER: write-mode destructive scan — data loss</span></span><br><span class="line"><span class="built_in">sudo</span> badblocks -wsv /dev/sdX</span><br><span class="line"></span><br><span class="line"><span class="comment"># ext* filesystem check (read-only)</span></span><br><span class="line"><span class="built_in">sudo</span> e2fsck -fn /dev/sdXN</span><br></pre></td></tr></table></figure></p>
<h2 id="mount">21. mount</h2>
<ul>
<li><p>Compat: Linux; Root required unless user mounts configured; Requires: util-linux.</p></li>
<li><p><code>mount -a [-t type] [-O optlist]</code>: mount all FSs mentioned in fstab to be mounted</p></li>
<li><p><code>-o</code>: override the settings in fstab</p></li>
<li><p><code>mount --bind olddir newdir</code>: remount part of the hierarchy elsewhere</p></li>
<li><p><code>mount --move</code>: move mounted tree to another place</p></li>
<li><p>Caution: <code>--bind/--move</code> and remounts can impact running services; ensure correct <code>fstab</code> for persistence and have rollback plan.</p></li>
</ul>
<h2 id="umount">22. umount</h2>
<ul>
<li><p>Compat: Linux; Root required for system mounts; Requires: util-linux.</p></li>
<li><p>unmount from a mountpoint</p></li>
</ul>
<h2 id="chown">23. chown</h2>
<ul>
<li><code>chown root:staff /u</code>: change owner and group</li>
</ul>
<h2 id="sysctl">24. sysctl</h2>
<ul>
<li><p>Compat: Linux; Root required for <code>-w</code>; Persistence via <code>/etc/sysctl.d</code>; Requires: procps.</p></li>
<li><p>configure kernel parameters at runtime</p></li>
<li><p><code>sysctl -a | grep "tcp"</code></p></li>
<li><p>Caution: <code>sysctl -w</code> changes take effect immediately; persist only via <code>/etc/sysctl.d/*.conf</code> after validation.</p></li>
<li><p>Read a key: <code>sysctl net.ipv4.tcp_congestion_control</code></p></li>
<li><p>Set a key (runtime): <code>sysctl -w vm.swappiness=10</code></p></li>
<li><p>Persist: create <code>/etc/sysctl.d/99-local.conf</code> with <code>vm.swappiness = 10</code>, then <code>sysctl --system</code></p></li>
</ul>
<h2 id="iotop">25. iotop</h2>
<ul>
<li><p>Compat: Linux; Root required; Needs kernel taskstats/delay accounting; Python tool.</p></li>
<li><p><code>iotop -o</code>: only show threads doing I/O</p></li>
<li><p><code>iotop -p &lt;PID1&gt;,&lt;PID2&gt;,...</code>: list of processes to monitor</p></li>
<li><p><code>iotop -a</code>: show accumulated IO rather than diff Requires: iotop.</p></li>
</ul>
<h2 id="netstat">26. netstat</h2>
<ul>
<li>Compat: Legacy; prefer <code>ss</code>; Requires: net-tools.</li>
</ul>
<h2 id="processes-scheduling">Processes &amp; Scheduling</h2>
<p>Cheat Card - Top offenders: <code>ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%cpu | head</code> - Threads view: <code>top -H</code> or <code>ps -Lp &lt;pid&gt; -o pid,tid,pcpu,comm</code> - Target processes: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Preview before signaling</span></span><br><span class="line">pgrep -a &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then send a scoped, safe signal (example: TERM)</span></span><br><span class="line">pkill -TERM -u &lt;user&gt; -f <span class="string">&#x27;&lt;exact-pattern&gt;&#x27;</span></span><br></pre></td></tr></table></figure> - Over time: <code>pidstat -u 1 -p &lt;pid&gt;</code> (CPU) and <code>pidstat -d 1</code> (IO) - Find PIDs: <code>pidof &lt;proc&gt;</code>; list threads: <code>ps -Lp &lt;pid&gt;</code> - Niceness: start <code>nice -n 10 cmd</code>; adjust: <code>renice -n 10 -p &lt;pid&gt;</code> - Locks: <code>/proc/locks</code> shows current file locks (read-only) - Sessions: users <code>who</code>; recent logins <code>last | head</code> - Schedule: <code>crontab -l</code> list; <code>crontab -e</code> edit</p>
<ul>
<li>Deprecated in many distros; prefer <code>ss</code>.</li>
<li>Common mappings:
<ul>
<li><code>netstat -tulpn</code> -&gt; <code>ss -tulpn</code></li>
<li><code>netstat -anp</code> -&gt; <code>ss -anp</code></li>
<li><code>netstat -s</code> -&gt; <code>ss -s</code></li>
</ul></li>
</ul>
<h2 id="top">27. top</h2>
<ul>
<li><p>Compat: Linux; Requires: procps.</p></li>
<li><p>Dynamic process view with CPU, memory, and load summaries.</p></li>
<li><p>Key CPU line fields: <code>us</code> (user), <code>sy</code> (system), <code>ni</code>, <code>id</code> (idle), <code>wa</code> (iowait), <code>hi/si</code> (IRQ/softIRQ), <code>st</code> (steal).</p></li>
<li><p>Key per-proc fields: <code>%CPU</code>, <code>%MEM</code>, <code>VIRT</code> (virtual), <code>RES</code> (resident), <code>SHR</code> (shared), <code>TIME+</code> (CPU time).</p></li>
<li><p><code>top -E m|g</code>: scale as mega|giga bytes</p></li>
<li><p><code>top -H</code>: thread-mode</p></li>
<li><p><code>top -i</code>: show idle processes</p></li>
<li><p><code>top -o RES|VIRT|SWAP</code>, etc: sort by attribute</p></li>
<li><p><code>top -O</code>: output fields: print all available sort-attributes</p></li>
<li><p><code>top -p pid1,pid2,...</code>: monitor only these PIDs</p></li>
<li><p><code>top -1</code>: show per-CPU stats</p></li>
</ul>
<h2 id="vmstat">28. vmstat</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
</ul>
<p>Useful to get so/si information</p>
<ul>
<li>Report virtual memory statistics</li>
<li><code>vmstat -a</code>: number active/inactive memory</li>
<li><code>vmstat --stats</code>: various statistics</li>
</ul>
<p>Interpretation tips - <code>r</code> runnable &gt; number of CPUs indicates run-queue contention. - <code>b</code> blocked processes (often IO wait); correlate with <code>%wa</code> in top/mpstat. - <code>si/so</code> swap in/out: sustained non-zero values indicate memory pressure. - Use <code>vmstat 1</code> for near-real-time view.</p>
<h2 id="strace">29. strace</h2>
<ul>
<li>Compat: Linux; May be restricted by ptrace scope; Requires: strace.</li>
</ul>
<p>Trace system calls and signals. - Attach to a PID: <code>strace -ttT -p &lt;pid&gt; -f -e trace=network,file,fsync,clock,nanosleep</code> - Run a program under strace: <code>strace -o strace.log -s 200 -vv -f -ttT your_cmd --arg</code> - Syscall time summary: <code>strace -c -p &lt;pid&gt;</code> - Filter a path: <code>strace -ttT -e trace=file -P /etc/resolv.conf -p &lt;pid&gt;</code> - Notes: <code>-f</code> follows forks; <code>-ttT</code> adds timestamps and syscall durations; <code>-s</code> increases string size. - trace system calls and signals</p>
<h2 id="slabtop">30. slabtop</h2>
<ul>
<li><p>Compat: Linux; Requires: procps.</p></li>
<li><p><code>slabtop</code>: display kernel slab cache information in real time</p></li>
<li><p>Sort by size: <code>slabtop -s c</code>; one-shot: <code>slabtop -o</code></p></li>
</ul>
<h2 id="uptime">31. uptime</h2>
<ul>
<li><p>Compat: Linux; Requires: procps.</p></li>
<li><p>information about how long the system has been up, and load averages</p></li>
</ul>
<h2 id="htop">32. htop</h2>
<ul>
<li><p>Compat: Linux; Requires: htop package.</p></li>
<li><p>like top, but prettier</p></li>
</ul>
<h2 id="ps">33. ps</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
</ul>
<p>Cheat Card - Top CPU: <code>ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%cpu | head</code> - Top RSS: <code>ps -eo pid,user,rss,cmd --sort=-rss | head</code> - Tree view: <code>ps -ejH</code> (or <code>ps axjf</code>) - By command: <code>ps -C nginx -o pid,ppid,cmd,%mem,%cpu</code> - Threads of a PID: <code>ps -Lp &lt;pid&gt; -o pid,tid,pcpu,comm</code></p>
<ul>
<li><p><code>ps aux</code>: show all processes</p></li>
<li><p><code>ps axjf</code> - print process tree</p></li>
<li><p><code>ps a</code> - Lift the BSD-style “only yourself” restriction</p></li>
<li><p><code>ps -A</code> - select all processes</p></li>
<li><p><code>ps -d</code> - select all processes except session leaders</p></li>
<li><p><code>ps g</code> - select all processes including session leaders</p></li>
<li><p><code>ps Ta</code> - all process associated with this terminal</p></li>
<li><p><code>ps r</code> - restrict to running processes</p></li>
<li><p><code>ps --pid pidlist</code> - restrict to pidlist processes</p></li>
<li><p><code>ps -s|--sid</code> - select by session ID</p></li>
<li><p><code>ps t ttylist</code> - select by TTY list</p></li>
<li><p><code>ps U|-U</code> - select by effective user-id</p></li>
<li><p><code>ps s</code> - display signals</p></li>
<li><p><code>ps f</code> - ASCII art process hierarchy</p></li>
<li><p><code>ps ax -o rss,pid,user,pcpu,command --sort -%cpu</code>: sort by %cpu</p></li>
<li><p><code>ps ax -o rss,pid,user,pcpu,command --sort -rss</code>: sort by rss</p></li>
</ul>
<p>process states: - <code>D</code> - uninterruptible sleep (usually IO) - <code>I</code> - Idle kernel thread - <code>R</code> - running or runnable (on run queue) - <code>S</code> - interruptible sleep (waiting for an event to complete) - <code>T</code> - stopped by job control signal - <code>t</code> - stopped by debugger during the tracing - <code>W</code> - paging (not valid since the 2.6.xx kernel) - <code>X</code> - dead (should never be seen) - <code>Z</code> - defunct (“zombie”) process, terminated but not reaped by its parent</p>
<p>see STANDARD FORMAT SPECIFIERS in <code>man ps</code></p>
<h2 id="cpu">CPU</h2>
<p>Cheat Card - CPU saturation: <code>mpstat -P ALL 1</code> (sys/iowait/irq/soft) - Per-core view in top: <code>top -1</code>; over time per PID: <code>pidstat -u 1 -p &lt;pid&gt;</code> - Interrupt spikes: <code>mpstat -I CPU 1</code></p>
<h2 id="mpstat">34. mpstat</h2>
<ul>
<li>Compat: Linux; Requires: sysstat.</li>
</ul>
<p>The mpstat command writes to standard output activities for each available processor, processor 0 being the first one. Global average activities among all processors are also reported. Requires: sysstat.</p>
<p>Interpretation tips - High <code>%iowait</code>: CPUs idle while waiting on disk IO (check iostat). - High <code>%irq/%soft</code>: heavy interrupts/softirqs (often network or storage). - High <code>%steal</code>: hypervisor stealing time (noisy neighbor in a VM). - Compare per-core: hotspots can be isolated to specific cores (affinity).</p>
<ul>
<li><p><code>CPU</code>: Processor number. The keyword all indicates that statistics are calculated as averages among all processors.</p></li>
<li><p><code>%usr</code>: Show the percentage of CPU utilization that occurred while executing at the user level (application).</p></li>
<li><p><code>%nice</code>: Show the percentage of CPU utilization that occurred while executing at the user level with nice priority.</p></li>
<li><p><code>%sys</code>: Show the percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this does not include time spent servicing hardware and software interrupts.</p></li>
<li><p><code>%iowait</code>: Show the percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.</p></li>
<li><p><code>%irq</code>: Show the percentage of time spent by the CPU or CPUs to service hardware interrupts.</p></li>
<li><p><code>%soft</code>: Show the percentage of time spent by the CPU or CPUs to service software interrupts.</p></li>
<li><p><code>%steal</code>: Show the percentage of time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor.</p></li>
<li><p><code>%guest</code>: Show the percentage of time spent by the CPU or CPUs to run a virtual processor.</p></li>
<li><p><code>%gnice</code>: Show the percentage of time spent by the CPU or CPUs to run a niced guest.</p></li>
<li><p><code>mpstat -I</code>: report interrupt stats</p>
<ul>
<li><h1 id="of-interrupts-per-cpu">of interrupts per CPU</h1></li>
<li><h1 id="of-times-a-particular-interrupt-occurred">of times a particular interrupt occurred</h1></li>
</ul></li>
</ul>
<h2 id="memory">Memory</h2>
<p>Cheat Card - Snapshot: <code>free -h --wide</code>; paging: <code>vmstat -a 1</code> (si/so) - Per-proc memory: <code>ps -eo pid,user,rss,cmd --sort=-rss | head</code>; deep dive: <code>pmap -x &lt;pid&gt;</code> - OOM evidence: <code>dmesg -T | grep -i oom</code> or <code>journalctl -k -g OOM</code></p>
<h2 id="free">35. free</h2>
<ul>
<li><p>Compat: Linux; Requires: procps.</p></li>
<li><p><code>used</code> - Used memory (calculated as total - free - buffers - cache)</p></li>
<li><p><code>free</code> - Unused memory (MemFree and SwapFree in /proc/meminfo)</p></li>
<li><p><code>shared</code> - Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)</p></li>
<li><p><code>buffers</code> - Memory used by kernel buffers (Buffers in /proc/meminfo)</p></li>
<li><p><code>cache</code> - Memory used by the page cache and slabs (Cached and SReclaimable in /proc/meminfo)</p></li>
<li><p><code>buff/cache</code> - Sum of buffers and cache</p></li>
<li><p><code>available</code> - Estimation of how much memory is available for starting new applications, without swapping. Unlike the data provided by the cache or free fields, this field takes into account page cache and also that not all reclaimable memory slabs will be reclaimed due to items being in use (MemAvailable in /proc/meminfo, available on kernels 3.14, emulated on kernels 2.6.27+, otherwise the same as free)</p></li>
<li><p><code>free -l</code>: show low-high memory breakdown</p></li>
<li><p><code>free --wide</code>: show free memory stats</p></li>
</ul>
<p>Interpretation tips - <code>available</code> approximates memory free for new apps without swapping; don’t confuse <code>free</code> with usable memory. - High <code>buff/cache</code> is normal; it’s the page cache and reclaimable slabs.</p>
<p>Examples - Human-readable snapshot: <code>free -h --wide</code> - Example output: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           31Gi        2.1Gi       22Gi        312Mi       7.2Gi        28Gi</span><br><span class="line">Swap:           8Gi           0B        8Gi</span><br></pre></td></tr></table></figure></p>
<h2 id="sar">36. sar</h2>
<ul>
<li>Compat: Linux; Requires: sysstat; history needs <code>sadc</code> enabled.</li>
</ul>
<p>Cheat Card - CPU load/queue: <code>sar -q 1 5</code>; memory: <code>sar -r 1 5</code> - IO bw/ops: <code>sar -b 1 5</code>; per-device: <code>sar -d 1 5</code> (watch <code>await</code>, <code>%util</code>) - Network: <code>sar -n DEV 1 5</code>; TCP: <code>sar -n TCP,ETCP 1 5</code> - Paging: <code>sar -B 1 5</code> (<code>pgsteal</code>, <code>pgscan</code>, <code>majflt/s</code>)</p>
<p>Requires: sysstat (includes pidstat).</p>
<details>
<summary>
Field reference (click to expand)
</summary>
<ul>
<li><p><code>sar -B</code>: report paging stats</p>
<ul>
<li><code>gpgin/s</code> - Total number of kilobytes the system paged in from disk per second.</li>
<li><code>pgpgout/s</code> - Total number of kilobytes the system paged out to disk per second.</li>
</ul></li>
<li><p><code>fault/s</code> - Number of page faults (major + minor) made by the system per second. This is not a count of page faults that generate I/O, because some page faults can be resolved without I/O.</p>
<ul>
<li><code>majflt/s</code> - Number of major faults the system has made per second, those which have required loading a memory page from disk.</li>
<li><code>pgfree/s</code> - Number of pages placed on the free list by the system per second.</li>
<li><code>pgscank/s</code> - Number of pages scanned by the kswapd daemon per second.</li>
<li><code>pgscand/s</code> - Number of pages scanned directly per second.</li>
<li><code>pgsteal/s</code> - Number of pages the system has reclaimed from cache (pagecache and swapcache) per second to satisfy its memory demands.</li>
<li><code>%vmeff</code> - Calculated as pgsteal / pgscan, this is a metric of the efficiency of page reclaim. If it is near 100% then almost every page coming off the tail of the inactive list is being reaped. If it gets too low (e.g. less than 30%) then the virtual memory is having some difficulty. This field is displayed as zero if no pages have been scanned during the interval of time.</li>
</ul></li>
<li><p><code>sar -b</code>: Report I/O and transfer rate statistics.</p>
<ul>
<li><code>tps</code> - Total number of transfers per second that were issued to physical devices. A transfer is an I/O request to a physical device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size.</li>
<li><code>rtps</code> - Total number of read requests per second issued to physical devices.</li>
<li><code>wtps</code> - Total number of write requests per second issued to physical devices.</li>
<li><code>bread/s</code> - Total amount of data read from the devices in blocks per second. Blocks are equivalent to sectors and therefore have a size of 512 bytes.</li>
<li><code>bwrtn/s</code> - Total amount of data written to devices in blocks per second.</li>
</ul></li>
<li><p><code>sar -d</code>: report activity for each block device</p></li>
<li><p><code>tps</code> - Total number of transfers per second that were issued to physical devices. A transfer is an I/O request to a physical device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size.</p>
<ul>
<li><code>rkB/s</code> - Number of kilobytes read from the device per second.</li>
<li><code>wkB/s</code> - Number of kilobytes written to the device per second.</li>
<li><code>areq-sz</code> - The average size (in kilobytes) of the I/O requests that were issued to the device. Note: In previous versions, this field was known as avgrq-sz and was expressed in sectors.</li>
<li><code>aqu-sz</code> - The average queue length of the requests that were issued to the device. Note: In previous versions, this field was known as avgqu-sz.</li>
<li><code>await</code> - The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.</li>
<li><code>svctm</code> - The average service time (in milliseconds) for I/O requests that were issued to the device. Warning! Do not trust this field any more. This field will be removed in a future sysstat version.</li>
<li><code>%util</code> - Percentage of elapsed time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100% for devices serving requests serially. But for devices serving requests in parallel, such as RAID arrays and modern SSDs, this number does not reflect their performance limits.</li>
</ul></li>
<li><p><code>sar -F</code>: display stats. for currently mounted FSs:</p>
<ul>
<li><code>MBfsfree</code> - Total amount of free space in megabytes (including space available only to privileged user).</li>
<li><code>MBfsused</code> - Total amount of space used in megabytes.</li>
<li><code>%fsused</code> - Percentage of filesystem space used, as seen by a privileged user.</li>
<li><code>%ufsused</code> - Percentage of filesystem space used, as seen by an unprivileged user.</li>
<li><code>Ifree</code> - Total number of free file nodes in filesystem.</li>
<li><code>Iused</code> - Total number of file nodes used in filesystem.</li>
<li><code>%Iused</code> - Percentage of file nodes used in filesystem.</li>
</ul></li>
<li><p><code>sar -m</code>: power management statistics:</p>
<ul>
<li><code>MHz</code> - Instantaneous CPU clock frequency in MHz.</li>
</ul>
<p>With the FAN keyword, statistics about fans speed are reported. The following values are displayed:</p>
<ul>
<li><code>rpm</code> - Fan speed expressed in revolutions per minute.</li>
<li><code>drpm</code> - This field is calculated as the difference between current fan speed (rpm) and its low limit (fan_min).</li>
<li><code>DEVICE</code> - Sensor device name.</li>
</ul>
<p>With the FREQ keyword, statistics about CPU clock frequency are reported. The following value is displayed:</p>
<ul>
<li><code>wghMHz</code> - Weighted average CPU clock frequency in MHz. Note that the cpufreq-stats driver must be compiled in the kernel for this option to work.</li>
</ul>
<p>With the IN keyword, statistics about voltage inputs are reported. The following values are displayed:</p>
<ul>
<li><code>inV</code> - Voltage input expressed in Volts.</li>
<li><code>%in</code> - Relative input value. A value of 100% means that voltage input has reached its high limit (in_max) whereas a value of 0% means that it has reached its low limit (in_min).</li>
<li><code>DEVICE</code> - Sensor device name.</li>
</ul>
<p>With the USB keyword, the sar command takes a snapshot of all the USB devices currently plugged into the system. At the end of the report, sar will display a summary of all those USB devices. The following values are displayed:</p>
<ul>
<li><code>BUS</code> - Root hub number of the USB device.</li>
<li><code>idvendor</code> - Vendor ID number (assigned by USB organization).</li>
<li><code>idprod</code> - Product ID number (assigned by Manufacturer).</li>
<li><code>maxpower</code> - Maximum power consumption of the device (expressed in mA).</li>
<li><code>manufact</code> - Manufacturer name.</li>
<li><code>product</code> - Product name.</li>
</ul></li>
<li><p><code>sar -n DEV</code>:</p>
<ul>
<li><code>IFACE</code> - Name of the network interface for which statistics are reported.</li>
<li><code>rxpck/s</code> - Total number of packets received per second.</li>
<li><code>txpck/s</code> - Total number of packets transmitted per second.</li>
<li><code>rxkB/s</code> - Total number of kilobytes received per second.</li>
<li><code>txkB/s</code> - Total number of kilobytes transmitted per second.</li>
<li><code>rxcmp/s</code> - Number of compressed packets received per second (for cslip etc.).</li>
<li><code>txcmp/s</code> - Number of compressed packets transmitted per second.</li>
<li><code>rxmcst/s</code> - Number of multicast packets received per second.</li>
<li><code>%ifutil</code> - Utilization percentage of the network interface. For half-duplex interfaces, utilization is calculated using the sum of rxkB/s and txkB/s as a percentage of the interface speed. For full-duplex, this is the greater of rxkB/S or txkB/s.</li>
</ul></li>
<li><p><code>sar -n EDEV</code>:</p>
<ul>
<li><code>IFACE</code> - Name of the network interface for which statistics are reported.</li>
<li><code>rxerr/s</code> - Total number of bad packets received per second.</li>
<li><code>txerr/s</code> - Total number of errors that happened per second while transmitting packets.</li>
<li><code>coll/s</code> - Number of collisions that happened per second while transmitting packets.</li>
<li><code>rxdrop/s</code> - Number of received packets dropped per second because of a lack of space in linux buffers.</li>
<li><code>txdrop/s</code> - Number of transmitted packets dropped per second because of a lack of space in linux buffers.</li>
<li><code>txcarr/s</code> - Number of carrier-errors that happened per second while transmitting packets.</li>
<li><code>rxfram/s</code> - Number of frame alignment errors that happened per second on received packets.</li>
<li><code>rxfifo/s</code> - Number of FIFO overrun errors that happened per second on received packets.</li>
<li><code>txfifo/s</code> - Number of FIFO overrun errors that happened per second on transmitted packets.</li>
</ul></li>
<li><p><code>sar -n ICMP</code>:</p>
<ul>
<li><code>imsg/s</code> - The total number of ICMP messages which the entity received per second [icmpInMsgs]. Note that this counter includes all those counted by ierr/s.</li>
<li><code>omsg/s</code> - The total number of ICMP messages which this entity attempted to send per second [icmpOutMsgs]. Note that this counter includes all those counted by oerr/s.</li>
<li><code>iech/s</code> - The number of ICMP Echo (request) messages received per second [icmpInEchos].</li>
<li><code>iechr/s</code> - The number of ICMP Echo Reply messages received per second [icmpInEchoReps].</li>
<li><code>oech/s</code> - The number of ICMP Echo (request) messages sent per second [icmpOutEchos].</li>
<li><code>oechr/s</code> - The number of ICMP Echo Reply messages sent per second [icmpOutEchoReps].</li>
<li><code>itm/s</code> - The number of ICMP Timestamp (request) messages received per second [icmpInTimestamps].</li>
<li><code>itmr/s</code> - The number of ICMP Timestamp Reply messages received per second [icmpInTimestampReps].</li>
<li><code>otm/s</code> - The number of ICMP Timestamp (request) messages sent per second [icmpOutTimestamps].</li>
<li><code>otmr/s</code> - The number of ICMP Timestamp Reply messages sent per second [icmpOutTimestampReps].</li>
<li><code>iadrmk/s</code> - The number of ICMP Address Mask Request messages received per second [icmpInAddrMasks].</li>
<li><code>oadrmk/s</code> - The number of ICMP Address Mask Request messages sent per second [icmpOutAddrMasks].</li>
<li><code>oadrmkr/s</code> - The number of ICMP Address Mask Reply messages sent per second [icmpOutAddrMaskReps].</li>
</ul></li>
<li><p><code>sar -n EICMP</code>: Extended ICMP stats (errors, dest unreachable, time exceeded). Focus on spikes in <code>ierr/s</code> and <code>oerr/s</code>, and patterns in unreachable/time- exceeded when debugging path issues.</p></li>
<li><p><code>sar -n EIP</code>: Extended IPv4 stats (header errors, addr errors, discards, no routes, reassembly, fragment fails). Use to spot header errors and routing/ no-route conditions.</p></li>
<li><p><code>sar -n IP6</code>: IPv6 per-protocol counters (receive/deliver/forward, multicast, fragmentation). Check for anomalies similar to IPv4.</p></li>
<li><p><code>sar -n EIP6</code>: Extended IPv6 errors and routing stats (header/addr errors, discards, no routes, reassembly/frag). Useful for IPv6-specific troubleshooting.</p></li>
<li><p><code>sar -n SOCK</code>:</p>
<ul>
<li><code>totsck</code> - Total number of sockets used by the system.</li>
<li><code>tcpsck</code> - TCP sockets in use; <code>tcp-tw</code> - TIME_WAIT sockets.</li>
</ul></li>
<li><p><code>sar -n SOFT</code>:</p>
<ul>
<li><code>total/s</code> - The total number of network frames processed per second.</li>
<li><code>dropd/s</code> - The total number of network frames dropped per second because there was no room on the processing queue.</li>
<li><code>squeezd/s</code> - The number of times the softirq handler function terminated per second because its budget was consumed or the time limit was reached, but more work could have been done.</li>
<li><code>rx_rps/s</code> - The number of times the CPU has been woken up per second to process packets via an inter-processor interrupt.</li>
<li><code>flw_lim/s</code> - The number of times the flow limit has been reached per second. Flow limiting is an optional RPS feature that can be used to limit the number of packets queued to the backlog for each flow to a certain amount. This can help ensure that smaller flows are processed even though much larger flows are pushing packets in.</li>
</ul></li>
<li><p><code>sar -n TCP</code>:</p>
<ul>
<li><code>active/s</code> - The number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state per second [tcpActiveOpens].</li>
<li><code>passive/s</code> - The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state per second [tcpPassiveOpens].</li>
<li><code>iseg/s</code> - The total number of segments received per second, including those received in error [tcpInSegs]. This count includes segments received on currently established connections.</li>
<li><code>oseg/s</code> - The total number of segments sent per second, including those on current connections but excluding those containing only retransmitted octets [tcpOutSegs].</li>
</ul></li>
<li><p><code>sar -n ETCP</code>:</p>
<ul>
<li><code>atmptf/s</code> - The number of times per second TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times per second TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state [tcpAttemptFails].</li>
<li><code>estres/s</code> - The number of times per second TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state [tcpEstabResets].</li>
<li><code>retrans/s</code> - The total number of segments retransmitted per second - that is, the number of TCP segments transmitted containing one or more previously transmitted octets [tcpRetransSegs].</li>
<li><code>isegerr/s</code> - The total number of segments received in error (e.g., bad TCP checksums) per second [tcpInErrs].</li>
<li><code>orsts/s</code> - The number of TCP segments sent per second containing the RST flag [tcpOutRsts].</li>
</ul></li>
<li><p><code>sar -n UDP</code>:</p>
<ul>
<li><code>idgm/s</code> - The total number of UDP datagrams delivered per second to UDP users [udpInDatagrams].</li>
<li><code>odgm/s</code> - The total number of UDP datagrams sent per second from this entity [udpOutDatagrams].</li>
<li><code>noport/s</code> - The total number of received UDP datagrams per second for which there was no application at the destination port [udpNoPorts].</li>
<li><code>idgmerr/s</code> - The number of received UDP datagrams per second that could not be delivered for reasons other than the lack of an application at the destination port [udpInErrors].</li>
</ul></li>
<li><p><code>sar -n UDP6</code>:</p>
<ul>
<li><code>idgm6/s</code> - The total number of UDP datagrams delivered per second to UDP users [udpInDatagrams].</li>
<li><code>odgm6/s</code> - The total number of UDP datagrams sent per second from this entity [udpOutDatagrams].</li>
<li><code>noport6/s</code> - The total number of received UDP datagrams per second for which there was no application at the destination port [udpNoPorts].</li>
<li><code>idgmer6/s</code> - The number of received UDP datagrams per second that could not be delivered for reasons other than the lack of an application at the destination port [udpInErrors].</li>
</ul></li>
<li><p><code>sar -q</code>:</p>
<ul>
<li><code>runq-sz</code> - Run queue length (number of tasks waiting for run time).</li>
<li><code>plist-sz</code> - Number of tasks in the task list.</li>
<li><code>ldavg-1</code> - System load average for the last minute. The load average is calculated as the average number of runnable or running tasks (R state), and the number of tasks in uninterruptible sleep (D state) over the specified interval.</li>
<li><code>ldavg-5</code> - System load average for the past 5 minutes.</li>
<li><code>ldavg-15</code> - System load average for the past 15 minutes.</li>
<li><code>blocked</code> - Number of tasks currently blocked, waiting for I/O to complete.</li>
</ul></li>
<li><p><code>sar -r</code>:</p>
<ul>
<li><code>kbmemfree</code> - Amount of free memory available in kilobytes.</li>
<li><code>kbavail</code> - Estimate of how much memory in kilobytes is available for starting new applications, without swapping. The estimate takes into account that the system needs some page cache to function well, and that not all reclaimable memory slabs will be reclaimable, due to items being in use. The impact of those factors will vary from system to system.</li>
</ul></li>
<li><p><code>kbmemused</code> - Amount of used memory in kilobytes (calculated as total installed memory - kbmemfree - kbbuffers - kbcached - kbslab).</p>
<ul>
<li><code>%memused</code> - Percentage of used memory.</li>
<li><code>kbbuffers</code> - Amount of memory used as buffers by the kernel in kilobytes.</li>
<li><code>kbcached</code> - Amount of memory used to cache data by the kernel in kilobytes.</li>
</ul></li>
<li><p><code>kbcommit</code> - Amount of memory in kilobytes needed for current workload. This is an estimate of how much RAM/swap is needed to guarantee that there never is out of memory.</p></li>
<li><p><code>%commit</code> - Percentage of memory needed for current workload in relation to the total amount of memory (RAM+swap). This number may be greater than 100% because the kernel usually overcommits memory.</p></li>
<li><p><code>kbactive</code> - Amount of active memory in kilobytes (memory that has been used more recently and usually not reclaimed unless absolutely necessary).</p></li>
<li><p><code>kbinact</code> - Amount of inactive memory in kilobytes (memory which has been less recently used. It is more eligible to be reclaimed for other purposes).</p>
<ul>
<li><code>kbdirty</code> - Amount of memory in kilobytes waiting to get written back to the disk.</li>
<li><code>kbanonpg</code> - Amount of non-file backed pages in kilobytes mapped into userspace page tables.</li>
<li><code>kbslab</code> - Amount of memory in kilobytes used by the kernel to cache data structures for its own use.</li>
<li><code>kbkstack</code> - Amount of memory in kilobytes used for kernel stack space.</li>
<li><code>kbpgtbl</code> - Amount of memory in kilobytes dedicated to the lowest level of page tables.</li>
<li><code>kbvmused</code> - Amount of memory in kilobytes of used virtual address space.</li>
</ul></li>
<li><p><code>sar -S</code>:</p>
<ul>
<li><code>kbswpfree</code> - Amount of free swap space in kilobytes.</li>
<li><code>kbswpused</code> - Amount of used swap space in kilobytes.</li>
<li><code>%swpused</code> - Percentage of used swap space.</li>
</ul></li>
<li><p><code>kbswpcad</code> - Amount of cached swap memory in kilobytes. This is memory that once was swapped out, is swapped back in but still also is in the swap area (if memory is needed it doesn’t need to be swapped out again because it is already in the swap area. This saves I/O).</p>
<ul>
<li><code>%swpcad</code> - Percentage of cached swap memory in relation to the amount of used swap space.</li>
</ul></li>
<li><p><code>sar -u</code>:</p></li>
<li><p><code>%user</code> - Percentage of CPU utilization that occurred while executing at the user level (application). Note that this field includes time spent running virtual processors.</p></li>
<li><p><code>%usr</code> - Percentage of CPU utilization that occurred while executing at the user level (application). Note that this field does NOT include time spent running virtual processors.</p></li>
<li><p><code>%nice</code> - Percentage of CPU utilization that occurred while executing at the user level with nice priority.</p></li>
<li><p><code>%system</code> - Percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this field includes time spent servicing hardware and software interrupts.</p></li>
<li><p><code>%sys</code> - Percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this field does NOT include time spent servicing hardware or software interrupts.</p></li>
<li><p><code>%iowait</code> - Percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.</p></li>
<li><p><code>%steal</code> - Percentage of time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor.</p>
<ul>
<li><code>%irq</code> - Percentage of time spent by the CPU or CPUs to service hardware interrupts.</li>
<li><code>%soft</code> - Percentage of time spent by the CPU or CPUs to service software interrupts.</li>
<li><code>%guest</code> - Percentage of time spent by the CPU or CPUs to run a virtual processor.</li>
<li><code>%gnice</code> - Percentage of time spent by the CPU or CPUs to run a niced guest.</li>
</ul></li>
<li><p><code>%idle</code> - Percentage of time that the CPU or CPUs were idle and the system did not have an outstanding disk I/O request.</p></li>
<li><p><code>sar -v</code>:</p>
<ul>
<li><code>dentunusd</code> - Number of unused cache entries in the directory cache.</li>
<li><code>file-nr</code> - Number of file handles used by the system.</li>
<li><code>inode-nr</code> - Number of inode handlers used by the system.</li>
<li><code>pty-nr</code> - Number of pseudo-terminals used by the system.</li>
</ul></li>
<li><p><code>sar -W</code>: Report swapping statistics. The following values are displayed:</p>
<ul>
<li><code>pswpin/s</code> - Total number of swap pages the system brought in per second.</li>
<li><code>pswpout/s</code> - Total number of swap pages the system brought out per second.</li>
</ul></li>
<li><p><code>sar -w</code>: Report task creation and system switching activity.</p>
<ul>
<li><code>proc/s</code> - Tasks created per second; <code>cswch/s</code> - context switches per second.</li>
</ul></li>
<li><p><code>sar -y</code>: Report TTY devices activity. The following values are displayed:</p></li>
<li><p><code>rcvin/s</code> - Number of receive interrupts per second for current serial line. Serial line number is given in the TTY column.</p>
<ul>
<li><code>xmtin/s</code> - Number of transmit interrupts per second for current serial line.</li>
<li><code>framerr/s</code> - Number of frame errors per second for current serial line.</li>
<li><code>prtyerr/s</code> - Number of parity errors per second for current serial line.</li>
<li><code>brk/s</code> - Number of breaks per second for current serial line.</li>
<li><code>ovrun/s</code> - Number of overrun errors per second for current serial line.</li>
</ul></li>
</ul>
</details>
<h2 id="pidstat">45. pidstat</h2>
<ul>
<li><p>Compat: Linux; Requires: sysstat.</p></li>
<li><p>monitor individual tasks currently being managed Requires: sysstat.</p></li>
</ul>
<p>Cheat Card - CPU by PID: <code>pidstat -u 1 -p &lt;pid&gt;</code> (watch <code>%usr/%system/%wait</code>) - IO by PID: <code>pidstat -d 1 -p &lt;pid&gt;</code> (check <code>kB_rd/s</code>, <code>kB_wr/s</code>, <code>iodelay</code>) - Memory faults: <code>pidstat -r 1 -p &lt;pid&gt;</code> (watch <code>majflt/s</code>) - Threads: <code>pidstat -t -u 1 -p &lt;pid&gt;</code></p>
<ul>
<li><p><code>pidstat -d</code>:</p>
<ul>
<li>Key fields: <code>kB_rd/s</code>, <code>kB_wr/s</code>, <code>iodelay</code> (IO wait), <code>kB_ccwr/s</code> (cancelled writes).</li>
</ul></li>
<li><p><code>pidstat -R</code>: Report realtime priority and scheduling policy information. The following values may be displayed:</p>
<ul>
<li>Key fields: <code>prio</code>, <code>policy</code>.</li>
</ul></li>
<li><p><code>pidstat -r</code>: Report page faults and memory utilization.</p>
<p>When reporting statistics for individual tasks, the following values may be displayed:</p>
<ul>
<li>Key fields: <code>majflt/s</code> (major faults), <code>RSS</code>, <code>%MEM</code>.</li>
</ul>
<p>When reporting global statistics for tasks and all their children, the following values may be displayed:</p>
<ul>
<li>With children: <code>majflt-nr</code>, <code>minflt-nr</code> summarize faults.</li>
</ul></li>
<li><p><code>pidstat -s</code>: Report stack utilization. The following values may be displayed:</p>
<ul>
<li>Key fields: <code>StkRef</code> (used), <code>StkSize</code> (reserved).</li>
</ul></li>
<li><p><code>pidstat -t</code>: Also display statistics for threads associated with selected tasks. List process and threads</p></li>
<li><p><code>pidstat -u</code>: Report CPU utilization.</p>
<p>When reporting statistics for individual tasks, the following values may be displayed:</p>
<ul>
<li>Key fields: <code>%usr</code>, <code>%system</code>, <code>%wait</code>, <code>%CPU</code>, <code>CPU</code>.</li>
</ul>
<p>When reporting global statistics for tasks and all their children, the following values may be displayed:</p>
<ul>
<li>With children: <code>usr-ms</code>, <code>system-ms</code>, <code>guest-ms</code> summarize CPU time.</li>
</ul></li>
</ul>
<h2 id="lsof">46. lsof</h2>
<ul>
<li>Compat: Linux; May require root to see all descriptors; Requires: lsof.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># List all open files</span><br><span class="line">lsof</span><br><span class="line"></span><br><span class="line"># Processes using a file? (fuser equivalent)</span><br><span class="line">lsof /path/to/file</span><br><span class="line"></span><br><span class="line"># Open files within a directory</span><br><span class="line">lsof +D /path</span><br><span class="line"></span><br><span class="line"># Files by user</span><br><span class="line">lsof -u name</span><br><span class="line">lsof -u name1,name2</span><br><span class="line">lsof -u name1 -u name2</span><br><span class="line"></span><br><span class="line"># By program name</span><br><span class="line">lsof -c apache</span><br><span class="line"></span><br><span class="line"># AND&#x27;ing selection conditions</span><br><span class="line">lsof -u www-data -c apache</span><br><span class="line"></span><br><span class="line"># By pid</span><br><span class="line">lsof -p 1</span><br><span class="line"></span><br><span class="line"># Except certain pids</span><br><span class="line">lsof -p ^1</span><br><span class="line"></span><br><span class="line"># TCP and UDP connections</span><br><span class="line">lsof -i</span><br><span class="line">lsof -i tcp # TCP connections</span><br><span class="line">lsof -i udp # UDP connections</span><br><span class="line"></span><br><span class="line"># By port</span><br><span class="line">lsof -i :25</span><br><span class="line">lsof -i :smtp</span><br><span class="line">lsof -i udp:53</span><br><span class="line">lsof -i tcp:80</span><br><span class="line"></span><br><span class="line"># All network activity by a user</span><br><span class="line">lsof -a -u name1 -i</span><br><span class="line"></span><br><span class="line">lsof -N # NFS use</span><br><span class="line">lsof -U # UNIX domain socket use</span><br><span class="line"></span><br><span class="line"># List PIDs</span><br><span class="line">lsof -t -i</span><br><span class="line"># Danger: broad kill; preview and scope carefully before use</span><br><span class="line">kill -9 $(lsof -t -i) # Kill all programs w/network activity</span><br></pre></td></tr></table></figure>
<p>Requires: lsof.</p>
<h2 id="pmap">51. pmap</h2>
<ul>
<li><p>Compat: Linux; Requires: procps; <code>-X</code> needs procps-ng.</p></li>
<li><p><code>pmap 29740 -X</code>: show Address,Perm,Offset,Device,Inode,Size,Rss,Pss,Referenced,Anonymous,LazyFree, ShmemPmdMapped,Shared_Hugetlb,Private_Hugetlb,Swap,SwapPss,Locked,THPeligible, Mapping Requires: procps.</p></li>
</ul>
<p>Common recipes - Largest mappings first: <code>pmap -x &lt;pid&gt; | sort -nrk 3 | head</code> (by RSS KB) - Totals summary: <code>pmap &lt;pid&gt;</code> (last line shows total)</p>
<h2 id="blktrace">52. blktrace</h2>
<ul>
<li><p>Compat: Linux; Root required; Needs kernel block trace support; Requires: blktrace.</p></li>
<li><p>blktrace is a block layer IO tracing mechanism which provides detailed information about request queue operations up to user space. There are three major components: a kernel component, a utility to record the i/o trace information for the kernel to user space, and utilities to analyse and view the trace information.</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Trace block I/O on /dev/sda and parse</span></span><br><span class="line"><span class="built_in">sudo</span> blktrace -d /dev/sda -o - | blkparse -i -</span><br></pre></td></tr></table></figure>
<p>Requires: blktrace.</p>
<p>outputs: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU0 (8,0):</span><br><span class="line"> Reads Queued:         385,     1540KiB     Writes Queued:           0,        0KiB</span><br><span class="line"> Read Dispatches:       75,     1544KiB     Write Dispatches:        4,       16KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:      681,    15168KiB     Writes Completed:       42,     1208KiB</span><br><span class="line"> Read Merges:          315,     1260KiB     Write Merges:            0,        0KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:            63             Timer unplugs:           0</span><br><span class="line">CPU1 (8,0):</span><br><span class="line"> Reads Queued:         406,     1624KiB     Writes Queued:          13,      996KiB</span><br><span class="line"> Read Dispatches:       71,     1620KiB     Write Dispatches:       10,      992KiB</span><br><span class="line"> Reads Requeued:         1         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:          336,     1344KiB     Write Merges:            2,      200KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:            68             Timer unplugs:           0</span><br><span class="line">CPU2 (8,0):</span><br><span class="line"> Reads Queued:        1531,     6152KiB     Writes Queued:          30,      120KiB</span><br><span class="line"> Read Dispatches:      257,     6152KiB     Write Dispatches:        3,      108KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:         1277,     5108KiB     Write Merges:           24,       96KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:           255             Timer unplugs:           0</span><br><span class="line">CPU3 (8,0):</span><br><span class="line"> Reads Queued:        1266,     5852KiB     Writes Queued:          23,       92KiB</span><br><span class="line"> Read Dispatches:      279,     5852KiB     Write Dispatches:       21,       92KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:          987,     3948KiB     Write Merges:            2,        8KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:           279             Timer unplugs:           1</span><br><span class="line"></span><br><span class="line">Total (8,0):</span><br><span class="line"> Reads Queued:        3588,    15168KiB     Writes Queued:          66,     1208KiB</span><br><span class="line"> Read Dispatches:      682,    15168KiB     Write Dispatches:       38,     1208KiB</span><br><span class="line"> Reads Requeued:         1         Writes Requeued:         0</span><br><span class="line"> Reads Completed:      681,    15168KiB     Writes Completed:       42,     1208KiB</span><br><span class="line"> Read Merges:         2915,    11660KiB     Write Merges:           28,      304KiB</span><br><span class="line"> IO unplugs:           665             Timer unplugs:           1</span><br></pre></td></tr></table></figure></p>
<h2 id="btrace">53. btrace</h2>
<ul>
<li><p>Compat: Linux; Wrapper script from blktrace; Root required.</p></li>
<li><p>The btrace script provides a quick and easy way to do live tracing of block devices. It calls blktrace on the specified devices and pipes the output through blkparse for formatting. See blktrace (8) for more in-depth information about how blktrace works.</p></li>
<li><p><code>btrace /dev/sda</code> Requires: blktrace.</p></li>
</ul>
<h2 id="tr">54. tr</h2>
<ul>
<li>Compat: Linux; Requires: coreutils.</li>
</ul>
<p>Translate, squeeze, and/or delete characters from standard input, writing to standard output.</p>
<ul>
<li><code>tr '\n' ','</code>: convert new lines to commas</li>
<li>squeeze repeats: <code>tr -s ' ' &lt; file</code> (collapse runs of spaces)</li>
<li>delete chars: <code>tr -d '\r' &lt; file</code> (remove CR)</li>
<li>keep only printable: <code>tr -cd '[:print:]\n' &lt; file</code></li>
<li>case convert: <code>tr '[:upper:]' '[:lower:]' &lt; file</code></li>
</ul>
<h2 id="cut">55. cut</h2>
<ul>
<li><p>Compat: Linux; Requires: coreutils.</p></li>
<li><p>select CSV fields: <code>cut -d, -f1,3 file.csv</code></p></li>
<li><p>ranges: <code>cut -d: -f1-3 /etc/passwd</code></p></li>
<li><p>bytes/chars: <code>cut -b1-10 file</code>; <code>cut -c1-20 file</code></p></li>
<li><p>complement: <code>cut -d, -f1 --complement file.csv</code></p></li>
<li><p>with headers: pair with <code>head -1</code> to see column indexes ## 56. xargs</p></li>
<li><p>Compat: Linux; Requires: findutils; GNU <code>-r</code> may vary on BusyBox.</p></li>
</ul>
<p>Build and run argument lists; combine with <code>find</code> and null-terminated records for safety.</p>
<ul>
<li>safe null delim: <code>find . -type f -name '*.log' -print0 | xargs -0 rm -f</code></li>
<li>limit args per call: <code>xargs -n 1 -I{} sh -c 'echo {}'</code></li>
<li>parallelism: <code>xargs -P 4 -n 1 cmd</code> (run 4 at a time)</li>
<li>interactive confirm: <code>xargs -p rm</code> (ask before each batch)</li>
<li>do nothing on empty input: <code>xargs -r cmd</code> (GNU)</li>
</ul>
<h2 id="logs-systemd">Logs &amp; Systemd</h2>
<p>Cheat Card - Unit status: <code>systemctl status &lt;unit&gt;</code>; failed: <code>systemctl list-units --failed</code> - Hot errors: <code>journalctl -xeu &lt;unit&gt;</code>; follow: <code>journalctl -fu &lt;unit&gt;</code> - Boot scoping: <code>journalctl -b</code> and <code>-b -1</code>; size: <code>journalctl --disk-usage</code></p>
<p>Systemd basics <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Unit status and enablement</span></span><br><span class="line">systemctl status &lt;unit&gt;</span><br><span class="line">systemctl is-active &lt;unit&gt;</span><br><span class="line">systemctl is-enabled &lt;unit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Failed units overview</span></span><br><span class="line">systemctl list-units --failed</span><br><span class="line">journalctl -xe  <span class="comment"># recent critical logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Restart and verify logs from this boot</span></span><br><span class="line">systemctl restart &lt;unit&gt;</span><br><span class="line">journalctl -u &lt;unit&gt; -b -n 50</span><br></pre></td></tr></table></figure></p>
<p>Journal essentials <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Recent errors for a unit and live follow</span></span><br><span class="line">journalctl -xeu &lt;unit&gt;</span><br><span class="line">journalctl -fu &lt;unit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Time window and priority</span></span><br><span class="line">journalctl -u &lt;unit&gt; --since <span class="string">&quot;1 hour ago&quot;</span> --<span class="keyword">until</span> now</span><br><span class="line">journalctl -p err..alert -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># Previous boot</span></span><br><span class="line">journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON output piped to jq (Requires: jq)</span></span><br><span class="line">journalctl -u &lt;unit&gt; -o json | jq -r <span class="string">&#x27;.MESSAGE&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>Journal management <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Disk usage and vacuum</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line">journalctl --vacuum-size=1G</span><br><span class="line">journalctl --vacuum-time=7d</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make logs persistent (requires root; edit journald.conf)</span></span><br><span class="line"><span class="comment"># /etc/systemd/journald.conf: set Storage=persistent</span></span><br><span class="line">systemctl restart systemd-journald</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tip: tune RateLimitIntervalSec/RateLimitBurst to manage log storms</span></span><br></pre></td></tr></table></figure></p>
<p>Resolved (DNS) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Overall resolver status</span></span><br><span class="line">resolvectl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query using systemd-resolved</span></span><br><span class="line">resolvectl query example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># Flush caches</span></span><br><span class="line">resolvectl flush-caches</span><br></pre></td></tr></table></figure></p>
<h2 id="security-audit">Security &amp; Audit</h2>
<p>Cheat Card - SELinux mode: <code>getenforce</code>; recent denials: <code>ausearch -m AVC -ts recent</code> - AppArmor status: <code>aa-status</code>; set complain/enforce on a profile - Audit rule example: <code>auditctl -w /etc/ssh/sshd_config -p wa -k sshcfg</code></p>
<p>SELinux <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Current mode and temporary permissive (diagnostic; requires root)</span></span><br><span class="line">getenforce</span><br><span class="line">setenforce 0  <span class="comment"># Caution: reduces enforcement</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Contexts and recent denials</span></span><br><span class="line"><span class="built_in">ls</span> -Z</span><br><span class="line">ps -eZ | <span class="built_in">head</span></span><br><span class="line">ausearch -m AVC -ts recent</span><br><span class="line">journalctl -t setroubleshoot</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manage booleans (example: allow httpd network connect)</span></span><br><span class="line">getsebool -a | grep httpd</span><br><span class="line">setsebool -P httpd_can_network_connect on</span><br><span class="line"><span class="comment"># Requires: selinux-utils/policycoreutils; setroubleshoot (optional)</span></span><br></pre></td></tr></table></figure></p>
<p>AppArmor <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Status and service</span></span><br><span class="line">aa-status</span><br><span class="line">systemctl status apparmor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle a profile mode</span></span><br><span class="line">aa-complain /path/to/bin</span><br><span class="line">aa-enforce /path/to/bin</span><br><span class="line"><span class="comment"># Requires: apparmor-utils</span></span><br></pre></td></tr></table></figure></p>
<p>Auditd <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Service and rules</span></span><br><span class="line">systemctl status auditd</span><br><span class="line">auditctl -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search recent denials / by PID</span></span><br><span class="line">ausearch -m avc -ts recent</span><br><span class="line">ausearch -p &lt;pid&gt; -ts recent</span><br><span class="line"></span><br><span class="line"><span class="comment"># Watch a file for writes/attr changes (key: sshcfg)</span></span><br><span class="line">auditctl -w /etc/ssh/sshd_config -p wa -k sshcfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Summary report</span></span><br><span class="line">aureport --summary -ts today</span><br><span class="line"><span class="comment"># Requires: auditd (auditd, auditctl, ausearch, aureport)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="containers-namespaces">Containers &amp; Namespaces</h2>
<p>Cheat Card - Enter container namespace: <code>nsenter --target &lt;pid&gt; --mount --uts --ipc --net --pid -- bash</code> - Docker triage: <code>docker ps</code>, <code>docker logs --tail=200 -f &lt;id&gt;</code>, <code>docker exec -it &lt;id&gt; sh</code> - K8s triage: <code>kubectl get pods -A</code>, <code>kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</code>, <code>kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</code></p>
<p>nsenter (enter namespaces of a PID) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Get target PID (e.g., container process)</span></span><br><span class="line">pidof &lt;proc&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enter multiple namespaces of a PID</span></span><br><span class="line">nsenter --target &lt;pid&gt; --mount --uts --ipc --net --pid -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inspect and chroot-like into the process rootfs</span></span><br><span class="line"><span class="built_in">ls</span> -l /proc/&lt;pid&gt;/root</span><br><span class="line">nsenter --target &lt;pid&gt; --mount -- <span class="built_in">chroot</span> /proc/&lt;pid&gt;/root bash</span><br></pre></td></tr></table></figure></p>
<p>Docker (if present) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List, exec, inspect PID, and tail logs</span></span><br><span class="line">docker ps --format <span class="string">&#x27;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125; &#123;&#123;.Status&#125;&#125;&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;<span class="built_in">id</span>|name&gt; bash  <span class="comment"># or sh</span></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> &lt;<span class="built_in">id</span>&gt;</span><br><span class="line">docker logs --<span class="built_in">tail</span>=200 -f &lt;<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>Kubernetes (if present) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pods and events</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line">kubectl get events -A --sort-by=.lastTimestamp | <span class="built_in">tail</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe, logs, and exec</span></span><br><span class="line">kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --<span class="built_in">tail</span>=200</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod&gt; -n &lt;ns&gt; -- bash</span><br></pre></td></tr></table></figure></p>
<p>CRI/containerd (if present) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List, inspect, and logs via crictl</span></span><br><span class="line">crictl ps -a</span><br><span class="line">crictl inspect &lt;<span class="built_in">id</span>&gt;</span><br><span class="line">crictl logs &lt;<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>Notes - Without runtime CLIs, use <code>nsenter</code> by PID from <code>ps</code>/<code>systemctl</code>. - Requires: docker or podman for Docker-like commands; kubectl; crictl for containerd/CRI.</p>
<h2 id="incident-playbooks">Incident Playbooks</h2>
<p>High CPU <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Top CPU processes and hot threads</span></span><br><span class="line">ps -eo pid,ppid,user,%cpu,%mem,cmd --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span></span><br><span class="line">top -H</span><br><span class="line">ps -Lp &lt;pid&gt; -o pid,tid,pcpu,<span class="built_in">comm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-process CPU over time; optional perf if available</span></span><br><span class="line">pidstat -u 1 -p &lt;pid&gt;</span><br><span class="line">perf top  <span class="comment"># if installed</span></span><br></pre></td></tr></table></figure></p>
<p>High IO wait / Disk latency <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Device saturation and per-process IO</span></span><br><span class="line">iostat -xz 1   <span class="comment"># watch await, %util, r/s, w/s</span></span><br><span class="line">pidstat -d 1</span><br><span class="line">iotop -oPa</span><br><span class="line"></span><br><span class="line"><span class="comment"># Device/FS inventory and kernel errors</span></span><br><span class="line">lsblk -o NAME,TYPE,SIZE,ROTA,MOUNTPOINT,MODEL</span><br><span class="line">dmesg -T | egrep -i <span class="string">&#x27;error|reset|blk|nvme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional deep dive</span></span><br><span class="line">blktrace -d /dev/sdX -o - | blkparse -i -</span><br></pre></td></tr></table></figure></p>
<p>Memory leak / OOM <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Snapshot and top RSS processes</span></span><br><span class="line">free -h</span><br><span class="line">ps aux --<span class="built_in">sort</span>=-rss | <span class="built_in">head</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Per-process mappings and over-time faults</span></span><br><span class="line">pmap -x &lt;pid&gt; | <span class="built_in">sort</span> -nrk 3 | <span class="built_in">head</span></span><br><span class="line">pidstat -r 1 -p &lt;pid&gt;</span><br><span class="line">smem -r  <span class="comment"># if installed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OOM evidence</span></span><br><span class="line">dmesg -T | grep -i oom || journalctl -k -g OOM</span><br></pre></td></tr></table></figure></p>
<p>Packet loss / High latency <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Path and end-to-end latency</span></span><br><span class="line">ip route get &lt;dest&gt;</span><br><span class="line">mtr -ezbw &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface health and TCP details</span></span><br><span class="line">ip -s <span class="built_in">link</span> show &lt;iface&gt;</span><br><span class="line">ethtool -S &lt;iface&gt;</span><br><span class="line">ss -i dst &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targeted capture samples</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; host &lt;dest&gt; and icmp</span><br><span class="line">tcpdump -ni &lt;iface&gt; tcp port 443 and <span class="string">&#x27;tcp[tcpflags] &amp; tcp-syn != 0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>DNS failures <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Resolve via systemd-resolved (or dig if available)</span></span><br><span class="line">resolvectl query example.com</span><br><span class="line">resolvectl status</span><br><span class="line">dig @8.8.8.8 example.com A +<span class="keyword">time</span>=2 +tries=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reachability and captures</span></span><br><span class="line">ss -u <span class="string">&#x27;sport = :53 or dport = :53&#x27;</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; port 53</span><br><span class="line"></span><br><span class="line"><span class="comment"># Config checks</span></span><br><span class="line"><span class="built_in">ls</span> -l /etc/resolv.conf</span><br><span class="line">resolvectl flush-caches</span><br><span class="line"><span class="comment"># Check firewall rules as appropriate</span></span><br></pre></td></tr></table></figure></p>
<p>TLS handshake issues <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inspect handshake/cert chain (TLS1.2 example)</span></span><br><span class="line">openssl s_client -connect host:443 -servername host -tls1_2 -showcerts</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check expiry/subject/issuer quickly</span></span><br><span class="line"><span class="built_in">echo</span> | openssl s_client -connect host:443 -servername host 2&gt;/dev/null \</span><br><span class="line">  | openssl x509 -noout -dates -subject -issuer</span><br><span class="line"></span><br><span class="line"><span class="comment"># App behavior (SNI, ALPN, protocols)</span></span><br><span class="line">curl -v https://host/</span><br><span class="line"></span><br><span class="line"><span class="comment"># If proxy/MTLS: verify CA path and client certs; check time skew</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure></p>
<p>Disk full / Inode exhaustion <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Space vs inodes</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="built_in">df</span> -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find biggest dirs on same filesystem</span></span><br><span class="line"><span class="built_in">du</span> -xhd1 /path | <span class="built_in">sort</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deleted-but-open files</span></span><br><span class="line">lsof +L1</span><br><span class="line">journalctl --vacuum-size=1G  <span class="comment"># cull journal size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Many small files</span></span><br><span class="line">find /path -xdev -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></p>
<p>Syscall slowness <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Trace syscalls and timings</span></span><br><span class="line">strace -ttT -p &lt;pid&gt; -f -e trace=network,file,fsync,clock,nanosleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional CPU hotspot profiling</span></span><br><span class="line">perf record -g -p &lt;pid&gt;; perf report</span><br></pre></td></tr></table></figure></p>
<p>Container restart loops <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker restart loops</span></span><br><span class="line">docker ps --filter <span class="string">&#x27;status=restarting&#x27;</span></span><br><span class="line">docker logs &lt;<span class="built_in">id</span>&gt; --<span class="built_in">tail</span>=200</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes restart loops</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line">kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</span><br><span class="line"></span><br><span class="line"><span class="comment"># Node/agent issues</span></span><br><span class="line">journalctl -u kubelet</span><br></pre></td></tr></table></figure></p>
<ul>
<li>modify priority of running process</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP学习-NS3模拟环境搭建</title>
    <url>/2025/12/15/TCP%E5%AD%A6%E4%B9%A0/TCP%E5%AD%A6%E4%B9%A0-NS3%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>参考https://github.com/ituring/tcp-book/?tab=readme-ov-file</p>
</blockquote>
<h1 id="前置工具下载">前置工具下载</h1>
<h2 id="virtualbox最新版本即可">virtualBox（最新版本即可）</h2>
<p><a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VirtualBox 图形用户界面</span><br><span class="line">版本 7.0.22 r165102 (Qt5.15.2)</span><br><span class="line">Copyright © 2024 Oracle and/or its affiliates</span><br></pre></td></tr></table></figure></p>
<h2 id="vagrant最新版本即可">Vagrant（最新版本即可）</h2>
<p><a href="https://developer.hashicorp.com/vagrant">https://developer.hashicorp.com/vagrant</a> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\dushenda&gt; vagrant.exe -v</span><br><span class="line">Vagrant 2.4.9</span><br></pre></td></tr></table></figure></p>
<h2 id="powershell">Powershell</h2>
<p><a href="https://learn.microsoft.com/en-us/powershell/scripting/install/install-powershell-on-windows?view=powershell-7.5">https://learn.microsoft.com/en-us/powershell/scripting/install/install-powershell-on-windows?view=powershell-7.5</a> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS C:\Users\dushenda&gt; pwsh.exe -v</span><br><span class="line">PowerShell 7.1.4</span><br></pre></td></tr></table></figure></p>
<h2 id="x-server">X server</h2>
<h3 id="下载并安装-vcxsrv">下载并安装 VcXsrv：</h3>
<ol type="1">
<li>访问：https://sourceforge.net/projects/vcxsrv/</li>
<li>下载并安装 VcXsrv Windows X Server</li>
</ol>
<h3 id="配置-vcxsrv">配置 VcXsrv：</h3>
<ol type="1">
<li>启动 “XLaunch”</li>
<li>选择 “Multiple windows”</li>
<li>Display number 设为 “0” 或 “-1”（自动）</li>
<li>选择 “Start no client”</li>
<li>在 “Extra settings” 中勾选 “Disable access control”（重要！）</li>
<li>完成设置，VcXsrv 会在系统托盘运行</li>
</ol>
<h3 id="设置-powershell-环境变量">设置 PowerShell 环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在启动 Vagrant 前设置 DISPLAY</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:DISPLAY = <span class="string">&quot;localhost:0.0&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者尝试</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:DISPLAY = <span class="string">&quot;127.0.0.1:0.0&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="修改-vagrantfile-配置">修改 Vagrantfile 配置</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.define &quot;guest1&quot; do |guest1|</span><br><span class="line">    guest1.vm.box = &quot;ubuntu/xenial64&quot;</span><br><span class="line">    </span><br><span class="line">    # 关键配置：启用 X11 转发</span><br><span class="line">    guest1.ssh.forward_x11 = true</span><br><span class="line">    guest1.ssh.forward_agent = true</span><br><span class="line">    guest1.ssh.forward_x11_trusted = true</span><br><span class="line">    guest1.ssh.keep_alive = true</span><br><span class="line">    </span><br><span class="line">    # 网络配置</span><br><span class="line">    guest1.vm.network &quot;private_network&quot;, type: &quot;dhcp&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="安装wireshark虚拟机">安装wireshark虚拟机</h1>
<h2 id="配置环境">配置环境</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/ituring/tcp-book.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tcp-book/wireshark/vagrant</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vagrant up</span></span><br></pre></td></tr></table></figure>
<h2 id="登录虚拟机">登录虚拟机</h2>
<p>使用以下的命令，ssh连接到Guest操作系统上。在登录消息显示之后，命令行提示会变成<code>vagrant@guest1:~$</code>。</p>
<p>在<code>powershell</code>中运行<code>vagrant ssh guest1</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vagrant ssh guest1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic x86_64)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">* Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">* Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; Get cloud support with Ubuntu Advantage Cloud Guest:</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">http://www.ubuntu.com/business/services/cloud</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; 0 packages can be updated.</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">0 updates are security updates.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; New release <span class="string">&#x27;18.04.1 LTS&#x27;</span> available.</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Run <span class="string">&#x27;do-release-upgrade&#x27;</span> to upgrade to it.</span></span><br><span class="line"></span><br><span class="line">vagrant@guest1:~$</span><br></pre></td></tr></table></figure>
<p>启动Wireshark。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant@guest1:~$ wireshark</span><br></pre></td></tr></table></figure> <img src="环境搭建wireshark.png" /></p>
<h1 id="安装ns3虚拟机">安装ns3虚拟机</h1>
<p>当确认已经准备好VirtualBox和Vagrant的环境之后，请将<a href="https://github.com/ituring/tcp-book">此Github代码库</a>克隆到任意目录。打开其中的<code>ns3/vagrant</code>目录，执行<code>vagrant up</code>命令。如此一来，就在虚拟机上完成了安装Ubuntu 16.04，并搭建ns-3的过程。另外，在2019年4月1日的时间点，第5章和第6章所使用的CUBIC和BBR模块不支持ns-3.28以上版本，因此本书使用ns-3.27版本。由于搭建ns-3环境相当花时间，请务必耐心等待 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/ituring/tcp-book.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tcp-book/ns3/vagrant</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vagrant up</span></span><br></pre></td></tr></table></figure>
<p><img src="安装虚拟机.png" /> 在<code>powershell</code>中运行<code>vagrant ssh</code> <img src="ns3环境搭建.png" /></p>
]]></content>
      <tags>
        <tag>TCP</tag>
        <tag>NS3</tag>
        <tag>仿真器</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下EDK2开发环境搭建</title>
    <url>/2024/01/22/Ubuntu%E4%B8%8BEDK2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Ubuntu%E4%B8%8BEDK2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="背景介绍">背景介绍</h2>
<p>编译edk2代码，配置开发环境，服务器使用华为云耀云服务器，OS信息如下 <img src="Ubuntu下EDK2开发环境搭建_20240122_1.png" /></p>
<p>特点</p>
<ul>
<li>apt-get源可以访问</li>
<li>github不能访问</li>
<li>gitee可以访问</li>
</ul>
<h2 id="远程仓库迁移">远程仓库迁移</h2>
<p>因为编译需要clone相关仓库到指定路径，并且为了今后的同步方便，所以把github仓库迁移到gitee后再配置相关环境。配置流程如下</p>
<ol type="1">
<li><p>建立组织，用来合并仓库环境</p>
<p><img src="Ubuntu下EDK2开发环境搭建_20240122_2.png" /></p></li>
<li><p>迁移主仓库</p>
<p><img src="Ubuntu下EDK2开发环境搭建_20240122_3.png" /></p></li>
<li><p>导入submodule，因为edk2后续编译还需要一些子模块，找到如下仓库的路径，按照2导入到组织</p>
<p><img src="Ubuntu下EDK2开发环境搭建_20240122_4.png" /></p></li>
<li><p>修改主仓库的submodule路径</p>
<p><img src="Ubuntu下EDK2开发环境搭建_20240122_5.png" /></p></li>
</ol>
<h2 id="下载">下载</h2>
<p>下载edk2代码仓 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git clone git@gitee.com:edk2_back/edk2.git</span><br></pre></td></tr></table></figure> 下载子模块到对应路径，可以看到地址都替换了gitee路径 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure> <img src="Ubuntu下EDK2开发环境搭建_20240122_6.png" /></p>
<h2 id="编译工具链安装">编译工具链安装</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># apt-get install build-essential uuid-dev iasl git gcc nasm python3</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># python3 --version</span></span></span><br><span class="line">Python 3.10.12</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># ln -s /usr/bin/python3.10 /usr/bin/python</span></span></span><br></pre></td></tr></table></figure>
<h2 id="编译">编译</h2>
<h3 id="基本工具">基本工具</h3>
<p>看一下当前的目录结构，使用<code>make -C BaseTools</code>编译基本工具 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># ls</span></span></span><br><span class="line">ArmPkg           CryptoPkg         FatPkg               Maintainers.txt  pip-requirements.txt  SignedCapsulePkg</span><br><span class="line">ArmPlatformPkg   DynamicTablesPkg  FmpDevicePkg         MdeModulePkg     PrmPkg                SourceLevelDebugPkg</span><br><span class="line">ArmVirtPkg       edksetup.bat      IntelFsp2Pkg         MdePkg           ReadMe.rst            StandaloneMmPkg</span><br><span class="line">BaseTools        edksetup.sh       IntelFsp2WrapperPkg  NetworkPkg       RedfishPkg            UefiCpuPkg</span><br><span class="line">Conf             EmbeddedPkg       License-History.txt  OvmfPkg          SecurityPkg           UefiPayloadPkg</span><br><span class="line">CONTRIBUTING.md  EmulatorPkg       License.txt          PcAtChipsetPkg   ShellPkg              UnitTestFrameworkPkg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># make -C BaseTools</span></span></span><br></pre></td></tr></table></figure> 编译基本工具完成 <img src="Ubuntu下EDK2开发环境搭建_20240122_7.png" /></p>
<h3 id="编译目标文件">编译目标文件</h3>
<p>设置环境变量，<code>path/to/edk/BaseTools</code>需要换成当前的<code>BaseTools</code>所在路径。 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># export EDK_TOOLS_PATH=`path/to/edk/BaseTools`</span></span></span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># ./edksetup.sh --help</span></span></span><br><span class="line">Usage: edksetup.sh [Options]</span><br><span class="line"></span><br><span class="line">The system environment variable, WORKSPACE, is always set to the current</span><br><span class="line">working directory.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --help, -h, -?        Print this help screen and exit.</span><br><span class="line"></span><br><span class="line">  --reconfig            Overwrite the WORKSPACE/Conf/*.txt files with the</span><br><span class="line">                        template files from the BaseTools/Conf directory.</span><br><span class="line"></span><br><span class="line">Please note: This script must be &#x27;sourced&#x27; so the environment can be changed.</span><br><span class="line">. edksetup.sh</span><br><span class="line">source edksetup.sh</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># source edksetup.sh BaseTools</span></span></span><br></pre></td></tr></table></figure> <img src="Ubuntu下EDK2开发环境搭建_20240122_8.png" /> 在<code>edk</code>目录下使用<code>build</code>命令编译 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># build</span></span></span><br></pre></td></tr></table></figure> <img src="Ubuntu下EDK2开发环境搭建_20240122_9.png" /></p>
]]></content>
      <tags>
        <tag>环境搭建</tag>
        <tag>EDK2</tag>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能IO-blktrace工具</title>
    <url>/2025/12/11/Linux%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/Linux%E6%80%A7%E8%83%BDIO-blktrace%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="快速分析">快速分析</h1>
<p>使用命令组合 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装工具</span></span><br><span class="line">yum install blktrace -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">采集数据：（监控30秒）</span></span><br><span class="line">blktrace -d /dev/nvme0n1 -w 30</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并数据：</span></span><br><span class="line">blkparse -i nvme0n1 -d nvme_trace.bin。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解析分析：，重点查看 <span class="string">&quot;ALL&quot;</span> 统计区和 <span class="string">&quot;Device Overhead&quot;</span> 分布</span></span><br><span class="line">btt -i nvme_trace.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">组合命令</span></span><br><span class="line">blktrace -d /dev/sdf -w 5 -o - | blkparse -i - -d btt.bin &gt; blkparse.txt</span><br><span class="line">btt -i btt.bin</span><br></pre></td></tr></table></figure> btrace组合 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追踪设备/dev/sda并输出blkparse数据</span></span><br><span class="line">btrace /dev/sda</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>实际上btrace是调用了blktarce和blkparse组合出来的脚本文件，位于/usr/bin/btrace</p>
</blockquote>
<h1 id="理论分析">理论分析</h1>
<p>一个I/O请求，从应用层到底层块设备，路径如下图所示： <img src="Linux-storage-stack-diagram_v4.0.png" /> 我们将IO路径简化一下： <img src="io_path_simple.png" /> 一个I/O请求进入block layer之后，可能会经历下面的过程：</p>
<ul>
<li>Remap: 可能被DM(Device Mapper)或MD(Multiple Device, Software RAID) remap到其它设备</li>
<li>Split: 可能会因为I/O请求与扇区边界未对齐、或者size太大而被分拆(split)成多个物理I/O</li>
<li>Merge: 可能会因为与其它I/O请求的物理位置相邻而合并(merge)成一个I/O</li>
<li>被IO Scheduler依照调度策略发送给driver</li>
<li>被driver提交给硬件，经过HBA、电缆（光纤、网线等）、交换机（SAN或网络）、最后到达存储设备，设备完成IO请求之后再把结果发回。</li>
</ul>
<p>blktrace 能够记录下IO所经历的各个步骤: <img src="blktrace_architecture.png" /> 我们一起看下blktrace的输出长什么样子： <img src="blktrace_out.png" /></p>
<ul>
<li>第一个字段：8,0 这个字段是设备号 major device ID和minor device ID。</li>
<li>第二个字段：3 表示CPU</li>
<li>第三个字段：11 序列号</li>
<li>第四个字段：0.009507758 Time Stamp是时间偏移</li>
<li>第五个字段：PID 本次IO对应的进程ID</li>
<li>第六个字段：Event，这个字段非常重要，反映了IO进行到了那一步</li>
<li>第七个字段：R表示 Read， W是Write，D表示block，B表示Barrier Operation</li>
<li>第八个字段：223490+56，表示的是起始block number 和 number of blocks，即我们常说的Offset 和 Size</li>
<li>第九个字段： 进程名</li>
</ul>
<p><code>blkparse</code>的输出包含了每个 I/O 请求事件的详细信息，理解这些字段是分析的关键：</p>
<table>
<thead>
<tr class="header">
<th>字段</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>设备号 (Major, Minor)</strong>​</td>
<td>如 <code>8,0</code>通常指 <code>/dev/sda</code></td>
</tr>
<tr class="even">
<td><strong>CPU ID</strong>​</td>
<td>处理此事件的 CPU 核心编号</td>
</tr>
<tr class="odd">
<td><strong>序列号</strong>​</td>
<td>事件的序列号</td>
</tr>
<tr class="even">
<td><strong>时间戳</strong>​</td>
<td>事件发生的时间（通常为相对时间）</td>
</tr>
<tr class="odd">
<td><strong>进程ID (PID)</strong>​</td>
<td>发起 I/O 操作的进程 ID</td>
</tr>
<tr class="even">
<td><strong>事件类型 (Action)</strong>​</td>
<td><strong>核心字段</strong>，表示 I/O 请求所处的阶段</td>
</tr>
<tr class="odd">
<td><strong>RWBS 描述符</strong>​</td>
<td>描述 I/O 类型：R(读)/W(写)/B(屏障)/S(同步)</td>
</tr>
<tr class="even">
<td><strong>扇区信息</strong>​</td>
<td>如 <code>2048 + 8</code>，表示起始扇区号及连续扇区数</td>
</tr>
<tr class="odd">
<td><strong>进程名</strong>​</td>
<td>发起 I/O 的进程名称</td>
</tr>
</tbody>
</table>
<p>其中，<strong>事件类型 (Action)</strong>​ 是理解 I/O 路径的关键，它记录了请求从产生到完成的各个阶段：</p>
<ul>
<li><strong>Q</strong>​ (Queued): I/O 请求进入块层。</li>
<li><strong>G</strong>​ (Get request): 分配请求结构。</li>
<li><strong>I</strong>​ (Inserted): 请求插入 I/O 调度器队列。</li>
<li><strong>D</strong>​ (Issued): 请求提交给设备驱动。</li>
<li><strong>C</strong>​ (Completed): 请求完成。</li>
</ul>
<p>根据这些事件的时间戳，可以计算出 I/O 路径各阶段的耗时，例如：</p>
<ul>
<li><strong>D2C</strong>: 请求在驱动和硬件上消耗的时间，是评估<strong>硬件性能</strong>的关键指标。</li>
<li><strong>I2D</strong>: 请求在 I/O 调度队列中等待的时间，反映<strong>调度器性能</strong>。</li>
<li><strong>Q2C</strong>: 整个 I/O 请求的总时间，近似于 <code>iostat</code>中的 <code>await</code>。</li>
</ul>
<p>其中第六个字段非常有用：每一个字母都代表了IO请求所经历的某个阶段。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Q – 即将生成IO请求</span><br><span class="line">|</span><br><span class="line">G – IO请求生成</span><br><span class="line">|</span><br><span class="line">I – IO请求进入IO Scheduler队列</span><br><span class="line">|</span><br><span class="line">D – IO请求进入driver</span><br><span class="line">|</span><br><span class="line">C – IO请求执行完毕</span><br></pre></td></tr></table></figure> 注意，整个IO路径，分成很多段，每一段开始的时候，都会有一个时间戳，根据上一段开始的时间和下一段开始的时间，就可以得到IO 路径各段花费的时间。</p>
<p>注意，我们心心念念的service time，也就是反应块设备处理能力的指标，就是从D到C所花费的时间，简称D2C。</p>
<p>而iostat输出中的await，即整个IO从生成请求到IO请求执行完毕，即从Q到C所花费的时间，我们简称Q2C。</p>
<p>我们知道Linux 有I/O scheduler，调度器的效率如何，I2D是重要的指标。</p>
<p>注意，这只是blktrace输出的一个部分，很明显，我们还能拿到offset和size，根据offset，我们能拿到某一段时间里，应用程序都访问了整个块设备的那些block，从而绘制出块设备访问轨迹图。</p>
<p>另外还有size和第七个字段（Read or Write），我们可以知道IO size的分布直方图。对于本文来讲，我们就是要根据blktrace来获取这些信息。 # 工具使用</p>
<p>我们接下来简单介绍这些工具的使用，其中这三个命令都是属于blktrace这个包的，他们是一家人。</p>
<p>首先通过如下命令，可以查看磁盘上的实时信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blktrace -d /dev/sdb -o – | blkparse -i –</span><br></pre></td></tr></table></figure>
<p>这个命令会连绵不绝地出现很多输出，当你输入ctrl＋C的时候，会停止。</p>
<p>当然了，你也可以先用如下命令采集信息，待所有信息采集完毕后，统一分析所有采集到的数据。搜集信息的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blktrace -d /dev/sdb</span><br></pre></td></tr></table></figure>
<p>注意，这个命令并不是只输出一个文件，他会根据CPU的个数上，每一个CPU都会输出一个文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 manu manu  1.3M Jul  6 19:58 sdb.blktrace.0</span><br><span class="line">-rw-r--r-- 1 manu manu  823K Jul  6 19:58 sdb.blktrace.1</span><br><span class="line">-rw-r--r-- 1 manu manu  2.8M Jul  6 19:58 sdb.blktrace.10</span><br><span class="line">-rw-r--r-- 1 manu manu  1.9M Jul  6 19:58 sdb.blktrace.11</span><br><span class="line">-rw-r--r-- 1 manu manu  474K Jul  6 19:58 sdb.blktrace.12</span><br><span class="line">-rw-r--r-- 1 manu manu  271K Jul  6 19:58 sdb.blktrace.13</span><br><span class="line">-rw-r--r-- 1 manu manu  578K Jul  6 19:58 sdb.blktrace.14</span><br><span class="line">-rw-r--r-- 1 manu manu  375K Jul  6 19:58 sdb.blktrace.15</span><br><span class="line">-rw-r--r-- 1 manu manu  382K Jul  6 19:58 sdb.blktrace.16</span><br><span class="line">-rw-r--r-- 1 manu manu  478K Jul  6 19:58 sdb.blktrace.17</span><br><span class="line">-rw-r--r-- 1 manu manu  839K Jul  6 19:58 sdb.blktrace.18</span><br><span class="line">-rw-r--r-- 1 manu manu  848K Jul  6 19:58 sdb.blktrace.19</span><br><span class="line">-rw-r--r-- 1 manu manu  1.6M Jul  6 19:58 sdb.blktrace.2</span><br><span class="line">-rw-r--r-- 1 manu manu  652K Jul  6 19:58 sdb.blktrace.20</span><br><span class="line">-rw-r--r-- 1 manu manu  738K Jul  6 19:58 sdb.blktrace.21</span><br><span class="line">-rw-r--r-- 1 manu manu  594K Jul  6 19:58 sdb.blktrace.22</span><br><span class="line">-rw-r--r-- 1 manu manu  527K Jul  6 19:58 sdb.blktrace.23</span><br><span class="line">-rw-r--r-- 1 manu manu 1005K Jul  6 19:58 sdb.blktrace.3</span><br><span class="line">-rw-r--r-- 1 manu manu  1.2M Jul  6 19:58 sdb.blktrace.4</span><br><span class="line">-rw-r--r-- 1 manu manu  511K Jul  6 19:58 sdb.blktrace.5</span><br><span class="line">-rw-r--r-- 1 manu manu  2.3M Jul  6 19:58 sdb.blktrace.6</span><br><span class="line">-rw-r--r-- 1 manu manu  1.3M Jul  6 19:58 sdb.blktrace.7</span><br><span class="line">-rw-r--r-- 1 manu manu  2.1M Jul  6 19:58 sdb.blktrace.8</span><br><span class="line">-rw-r--r-- 1 manu manu  1.1M Jul  6 19:58 sdb.blktrace.9</span><br></pre></td></tr></table></figure>
<p>有了输出，我们可以通过blkparse -i sdb来分析采集的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8,16   7     2147     0.999400390 630169  I   W 447379872 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2148     0.999400653 630169  I   W 447380040 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2149     0.999401057 630169  I   W 447380088 + 16 [kworker/u482:0]</span><br><span class="line">8,16   7     2150     0.999401364 630169  I   W 447380176 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2151     0.999401521 630169  I   W 453543312 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2152     0.999401843 630169  I   W 453543328 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2153     0.999402195 630169  U   N [kworker/u482:0] 14</span><br><span class="line">8,16   6     5648     0.999403047 16921  C   W 347875880 + 8 [0]</span><br><span class="line">8,16   6     5649     0.999406293 16921  D   W 301856632 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5650     0.999421040 16921  C   W 354834456 + 8 [0]</span><br><span class="line">8,16   6     5651     0.999423900 16921  D   W 301857280 + 8 [ceph-osd]</span><br><span class="line">8,16   7     2154     0.999442195 630169  A   W 425409840 + 8 &lt;- (8,22) 131806512</span><br><span class="line">8,16   7     2155     0.999442601 630169  Q   W 425409840 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2156     0.999444277 630169  G   W 425409840 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2157     0.999445177 630169  P   N [kworker/u482:0]</span><br><span class="line">8,16   7     2158     0.999446341 630169  I   W 425409840 + 8 [kworker/u482:0]</span><br><span class="line">8,16   7     2159     0.999446773 630169 UT   N [kworker/u482:0] 1</span><br><span class="line">8,16   6     5652     0.999452685 16921  C   W 354834520 + 8 [0]</span><br><span class="line">8,16   6     5653     0.999455613 16921  D   W 301857336 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5654     0.999470425 16921  C   W 393228176 + 8 [0]</span><br><span class="line">8,16   6     5655     0.999474127 16921  D   W 411554968 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5656     0.999488551 16921  C   W 393228560 + 8 [0]</span><br><span class="line">8,16   6     5657     0.999491549 16921  D   W 411556112 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5658     0.999594849 16923  C   W 393230152 + 16 [0]</span><br><span class="line">8,16   6     5659     0.999604038 16923  D   W 432877368 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5660     0.999610322 16923  C   W 487390128 + 8 [0]</span><br><span class="line">8,16   6     5661     0.999614654 16923  D   W 432879632 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5662     0.999628284 16923  C   W 487391344 + 8 [0]</span><br><span class="line">8,16   6     5663     0.999632014 16923  D   W 432879680 + 8 [ceph-osd]</span><br><span class="line">8,16   6     5664     0.999646122 16923  C   W 293759504 + 8 [0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，blkparse仅仅是将blktrace输出的信息转化成人可以阅读和理解的输出，但是，信息太多，太杂，人完全没法得到关键信息。 这时候btt就横空出世了，这个工具可以将blktrace采集回来的数据，进行分析，得到对人更有用的信息。事实上，btt也是我们的终点。</p>
<h1 id="获取个阶段的延迟信息">获取个阶段的延迟信息</h1>
<p>注意，btt已经可以很自如地生成这部分统计信息，我们可以很容易得到如下的表格： <img src="latency_distribution_table.png" /> <img src="ioflow.png" /></p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 50%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>阶段缩写</th>
<th>全称与含义</th>
<th>性能指标解读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Q2Q</strong>​</td>
<td><strong>Queue to Queue</strong> <br>衡量上一个I/O完成到当前I/O抵达块层的<strong>时间间隔</strong>，反映了I/O请求的<strong>到达速率</strong>。</td>
<td>间隔时间短表示I/O负载很重，请求密集；间隔时间长则表示I/O负载较轻<br><br>。</td>
</tr>
<tr class="even">
<td><strong>Q2G</strong>​</td>
<td><strong>Queue to Get</strong> <br>I/O请求进入块层后，等待系统为其分配一个<code>request</code>结构体的时间。</td>
<td>此阶段通常极短。如果时间较长，可能表示系统内存紧张或内核在分配数据结构时遇到瓶颈。</td>
</tr>
<tr class="odd">
<td><strong>G2I</strong>​</td>
<td><strong>Get to Insert</strong> <br>获取<code>request</code>结构体后，准备并将其插入到I/O调度器队列所花费的时间。</td>
<td>此阶段也非常短暂。它反映了I/O调度器处理请求的初始开销。</td>
</tr>
<tr class="even">
<td><strong>I2D</strong>​</td>
<td><strong>Insert to Issue</strong> <br>请求在<strong>I/O调度器队列</strong>中等待以及被调度（合并、排序）后，派发（Issue）到设备驱动程序的时间。这是分析<strong>操作系统层面瓶颈</strong>的关键指标<br><br>。</td>
<td><strong>这是判断I/O调度器和系统负载的关键指标</strong>。如果I2D时间很长，说明： <br>1. 存储设备速度跟不上请求速率，队列中有大量请求在排队。 <br>2. I/O调度策略可能不适合当前负载。</td>
</tr>
<tr class="odd">
<td><strong>D2C</strong>​</td>
<td><strong>Issue to Complete</strong> <br>请求被提交给设备驱动后，在<strong>物理硬件上真正执行</strong>所花费的时间（包括在设备自身的缓存和介质上的读写时间）。这是评估<strong>硬件性能</strong>最直接的指标<br><br>。</td>
<td><strong>这是判断硬件瓶颈的核心指标</strong>。如果D2C时间很长，通常意味着： <br>1. <strong>存储设备本身性能不足</strong>（如机械硬盘随机读写慢）。 <br>2. 设备可能处于高负载或存在故障。</td>
</tr>
<tr class="even">
<td><strong>Q2C</strong>​</td>
<td><strong>Queue to Complete</strong> <br>一个I/O请求在块层处理的<strong>总时间</strong>。它近似等于 <code>Q2I + I2D + D2C</code>（Q2I可再细分为Q2G+G2I）<br><br>。</td>
<td>这大致相当于 <code>iostat</code>命令输出的 <code>await</code>值。反映了一个I/O请求从进入系统到完成的总延迟<br><br>。</td>
</tr>
</tbody>
</table>
<p>方法如下：</p>
<p>首先blkparse可以将对应不同cpu的多个文件聚合成一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blkparse -i sdb -d sdb.blktrace.bin</span><br></pre></td></tr></table></figure>
<p>然后btt就可以分析这个sdb.blktrace.bin了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==================== All Devices ====================</span><br><span class="line"></span><br><span class="line">            ALL           MIN           AVG           MAX           N</span><br><span class="line">--------------- ------------- ------------- ------------- -----------</span><br><span class="line"></span><br><span class="line">Q2Q               0.000000001   0.000159747   0.025292639       62150</span><br><span class="line">Q2G               0.000000233   0.000001380   0.000056343       52423</span><br><span class="line">G2I               0.000000146   0.000027084   0.005031317       48516</span><br><span class="line">Q2M               0.000000142   0.000000751   0.000021613        9728</span><br><span class="line">I2D               0.000000096   0.001534463   0.022469688       52423</span><br><span class="line">M2D               0.000000647   0.002617691   0.022445412        5821</span><br><span class="line">D2C               0.000046189   0.000779355   0.007860766       62151</span><br><span class="line">Q2C               0.000051089   0.002522832   0.026096657       62151</span><br><span class="line"></span><br><span class="line">==================== Device Overhead ====================</span><br><span class="line"></span><br><span class="line">       DEV |       Q2G       G2I       Q2M       I2D       D2C</span><br><span class="line">---------- | --------- --------- --------- --------- ---------</span><br><span class="line"> (  8, 16) |   0.0461%   0.8380%   0.0047%  51.3029%  30.8921%</span><br><span class="line">---------- | --------- --------- --------- --------- ---------</span><br><span class="line">   Overall |   0.0461%   0.8380%   0.0047%  51.3029%  30.8921%</span><br><span class="line"></span><br><span class="line">==================== Device Merge Information ====================</span><br><span class="line"></span><br><span class="line">       DEV |       #Q       #D   Ratio |   BLKmin   BLKavg   BLKmax    Total</span><br><span class="line">---------- | -------- -------- ------- | -------- -------- -------- --------</span><br><span class="line"> (  8, 16) |    62151    52246     1.2 |        1       20      664  1051700</span><br><span class="line"></span><br><span class="line">==================== Device Q2Q Seek Information ====================</span><br><span class="line"></span><br><span class="line">       DEV |          NSEEKS            MEAN          MEDIAN | MODE           </span><br><span class="line">---------- | --------------- --------------- --------------- | ---------------</span><br><span class="line"> (  8, 16) |           62151      42079658.0               0 | 0(17159)</span><br><span class="line">---------- | --------------- --------------- --------------- | ---------------</span><br><span class="line">   Overall |          NSEEKS            MEAN          MEDIAN | MODE           </span><br><span class="line">   Average |           62151      42079658.0               0 | 0(17159)</span><br><span class="line"></span><br><span class="line">==================== Device D2D Seek Information ====================</span><br><span class="line"></span><br><span class="line">       DEV |          NSEEKS            MEAN          MEDIAN | MODE           </span><br><span class="line">---------- | --------------- --------------- --------------- | ---------------</span><br><span class="line"> (  8, 16) |           52246      39892356.2               0 | 0(9249)</span><br><span class="line">---------- | --------------- --------------- --------------- | ---------------</span><br><span class="line">   Overall |          NSEEKS            MEAN          MEDIAN | MODE           </span><br><span class="line">   Average |           52246      39892356.2               0 | 0(9249)</span><br></pre></td></tr></table></figure>
<p>注意： D2C和Q2C，一个是表征块设备性能的关键指标，另一个是客户发起请求到收到响应的时间，我们可以看出，</p>
<p>D2C 平均在0.000779355 秒，即0.7毫秒 Q2C 平均在0.002522832 秒，即2.5毫秒，</p>
<p>无论是service time 还是客户感知到的await time，都是非常短的，表现非常不俗。但是D2C花费的时间只占整个Q2C的30%， 51%以上的时间花费在I2D。</p>
<h1 id="参考搬运">参考/搬运</h1>
<p>https://bean-li.github.io/blktrace-to-report/</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>性能分析-Windows（一）</title>
    <url>/2020/10/20/Windows%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Windows%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="windows运行参数分析">Windows运行参数分析</h1>
<p>这篇文章较为简单，主要是使用 Windows Performance Record 和 Windows Performance Analysis 来分析在运行一段时间内的各个参数的变化，记录详细的信息。</p>
<p>一般大家都是从任务管理器上面来看机器当前的运行状态，但是，如果我想要了解的更详细一些，并且需要一段特定时间的运行参数，任务管理器仿佛就无能为力了，这时候，可以使用 Windows 测试框架里面的两个小工具来记录分析机器的运行状态。</p>
<p><img src="任务管理.png" /></p>
<span id="more"></span>
<blockquote>
<p>Windows Hardware Lab Kit (Windows HLK) 是一个测试框架，用于测试 Windows 10 以及从 Windows Server 2016 开始的所有 Windows Server 版本的硬件设备。 你的产品必须通过使用 Windows HLK 进行的某些测试，才有资格加入 <a href="https://docs.microsoft.com/en-us/windows-hardware/design/compatibility/">Windows 硬件兼容性计划</a>。</p>
<p>Windows 性能工具包位于 <a href="https://aka.ms/adk">Windows 评估和部署工具包</a>中，其中包含各种性能监控工具，这些工具可生成有关 Windows 操作系统和应用程序的详细性能概况。 本文档同时讨论了 Windows Performance Recorder (WPR) 和 Windows Performance Analyzer (WPA)。</p>
<p>包含在<a href="https://go.microsoft.com/fwlink/p/?LinkId=526740">Windows 评估和部署工具包 (Windows ADK)</a>，Windows 性能记录器 (WPR) 是一种性能录制工具为基础上事件跟踪 Windows (ETW)。 它记录系统事件，然后可以通过使用 Windows Performance Analyzer (WPA) 进行分析。</p>
<p>包含在<a href="https://go.microsoft.com/fwlink/p/?LinkId=526740">Windows 评估和部署工具包 (Windows ADK)</a>，Windows Performance Analyzer (WPA) 是一种工具，创建的事件跟踪 Windows (ETW) 事件所记录的 Windows 性能的关系图和数据表记录器 (WPR)、 Xperf 或评估运行评估平台中。 WPA 可以打开任何事件跟踪日志 (ETL) 文件进行分析。</p>
</blockquote>
<h2 id="windows-performance-record">Windows Performance Record</h2>
<ol type="1">
<li><p>在程序中搜索到 Windows Performance Record 并且打开， <img src="wpr_start.png" /></p></li>
<li><p>从当前时刻开始记录，记录完成后保存文件 <img src="wpr_save.png" /> <img src="wpr_save_finish.png" /></p></li>
<li><p>记下文件保存位置</p></li>
</ol>
<h2 id="windows-performance-analysis">Windows Performance Analysis</h2>
<ol type="1">
<li><p>在程序中找到 Windows Performance Analysis 并且打开 <img src="wpa_open.png" /></p></li>
<li><p>File-&gt;Open，打开前面保存的文件 <img src="wpa_file_in1.png" /> <img src="wpafileincpu.png" /> <img src="wpafileincpumem.png" /></p></li>
</ol>
]]></content>
      <tags>
        <tag>性能</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>性能分析-Windows（二）</title>
    <url>/2025/12/17/Windows%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-Windows%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="overview">Overview</h1>
<p>介绍几款Windows下的性能分析工具。</p>
<h1 id="工具介绍">工具介绍</h1>
<ul>
<li>Perfmon（性能监视器）：是Windows自带的性能监控工具，可以通过它来查看CPU、内存、硬盘、网络等系统性能指标的实时数据，也可以将数据保存到文件中进行后续分析。</li>
<li>Sysinternals Suite：是一个由微软官方提供的一组系统工具集合，其中包括了很多用于性能监控的工具，例如Process Monitor、DiskMon、TCPView等。</li>
<li>Windows Performance Toolkit：是一组高级性能监控工具，可用于性能分析和故障排查，包括xperf、WPR、WPA等。</li>
<li>perfview：Perfview是一个开源的CPU和内存性能分析工具，也包括一些针对.NET的分析功能，例如GC分析，JIT分析，甚至ASP.NET中的请求统计等等。</li>
<li>System Informer：系统资源监控工具，支持windows10、windows11。</li>
</ul>
<h1 id="工具概览">工具概览</h1>
<h2 id="perfmon">Perfmon</h2>
<p>Windows自带的，详细使用方法，参考官方<a href="https://techcommunity.microsoft.com/t5/ask-the-performance-team/windows-performance-monitor-overview/ba-p/375481">链接</a> <img src="perfmon.png" /></p>
<h2 id="sysinternals">Sysinternals</h2>
<p>下载后即可使用的工具集，官方下链接<a href="https://learn.microsoft.com/zh-cn/sysinternals/">下载</a>，如常用的process monitor也包括在内 <img src="sysinternal.png" /></p>
<h2 id="windows-performance-toolkit">Windows Performance Toolkit</h2>
<p>这个是Windows下的性能工具合集，见<a href="https://learn.microsoft.com/zh-cn/windows-hardware/test/wpt/windows-performance-toolkit-technical-reference">官网</a>，Windows 性能工具包包含两个独立的工具：Windows Performance Recorder (WPR) 和 Windows Performance Analyzer (WPA) 此外，还保留了对以前的命令行工具 Xperf 的支持。 但是，不再支持 Xperfview。 所有记录都必须使用 WPA 来打开和分析。</p>
<p>需要使用WPR收集数据，再使用WPA分析数据。 <img src="wpa.png" /></p>
<h2 id="perfview">perfview</h2>
<p>perfview<a href="https://github.com/microsoft/perfview">下载地址</a>。Perfview是一个开源的CPU和内存性能分析工具，也包括一些针对.NET的分析功能，例如GC分析，JIT分析，甚至ASP.NET中的请求统计等等。Perfview是一个Windows应用程序，但也能对在Linux系统上采集的数据进行分析（<a href="https://blogs.msdn.microsoft.com/vancem/2016/02/20/analyzing-cpu-traces-from-linux-with-perfview/">参考</a>）。Perfview免安装，而且只是一个14M的.exe文件，非常容易部署到需要进行性能分析的机器上，例如生产环境的服务器。而且在性能数据收集的过程中不需要重启应用程序或者服务器，而且收集的性能数据日志（.etl文件）可以被拷贝到其他Windows机器上，再进行分析工作，对业务的影响非常少。 <img src="perfview.png" /></p>
<h2 id="system-informer">System Informer</h2>
<p>系统资源监控工具，支持windows10、windows11，官网<a href="https://systeminformer.sourceforge.io/">地址</a>。 <img src="sysinformer.png" /></p>
]]></content>
      <tags>
        <tag>性能</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu调试linux（一）</title>
    <url>/2024/01/24/qemu/qemu%E8%B0%83%E8%AF%95linux%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="编译内核">编译内核</h2>
<h3 id="下载">下载</h3>
<p>kernel：https://mirrors.edge.kernel.org/pub/linux/kernel/</p>
<p>镜像：https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/</p>
<h3 id="编译">编译</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">root@dushenda:/home/dsd/Code/linux-5.18.10# make menuconfig</span><br><span class="line">root@dushenda:/home/dsd/Code/linux-5.18.10# make -j`nproc`</span><br></pre></td></tr></table></figure>
<p><img src="qemu调试linux（一）_20240124_1.png" /> 编译完成得到 <img src="qemu调试linux（一）_20240124_2.png" /></p>
<h2 id="制作initramfs">制作initramfs</h2>
<h3 id="使用busybox">使用busybox</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">root@dushenda:/home/dsd/Code/busybox-1.36.1# make menuconfig</span><br><span class="line">root@dushenda:/home/dsd/Code/busybox-1.36.1# make -j`nproc`</span><br><span class="line">root@dushenda:/home/dsd/Code/busybox-1.36.1# make install</span><br></pre></td></tr></table></figure>
<p><img src="qemu调试linux（一）_20240124_3.png" /> 编译完成得到 <img src="qemu调试linux（一）_20240124_4.png" /> <img src="qemu调试linux（一）_20240124_5.png" /> 制作initramfs.img，首先构造如下的目录结构 <img src="qemu调试linux（一）_20240124_6.png" /> init文件内容如下： <img src="qemu调试linux（一）_20240124_10.png" /> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@dushenda:/home/dsd/Code/initramfs_dir# find . -print0 | cpio -ov --null --format=newc | gzip -9 &gt; ../initramfs.img</span><br></pre></td></tr></table></figure> 最后生成文件 <img src="qemu调试linux（一）_20240124_7.png" /> qemu运行新内核 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">root@dushenda:/home/dsd/Code/initramfs_dir# qemu-system-x86_64 \  </span><br><span class="line">											-kernel bzImage \  </span><br><span class="line">											-initrd initramfs.img \  </span><br><span class="line">											-m 1G \  </span><br><span class="line">											-nographic \  </span><br><span class="line">											-append &quot;earlyprintk=serial,ttyS0 console=ttyS0&quot;</span><br></pre></td></tr></table></figure> 运行结果如下 <img src="qemu调试linux（一）_20240124_9.png" /> <img src="qemu调试linux（一）_20240124_8.png" /></p>
<h2 id="注意">注意</h2>
<p><code>init</code>需要设置为可执行权限</p>
<p>qemu退出快捷键ctrl+a按下后释放，再按x</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>环境搭建</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu调试linux（二）</title>
    <url>/2024/03/19/qemu/qemu%E8%B0%83%E8%AF%95linux%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="gdb调试">GDB调试</h2>
<p>当前文件夹目录 <img src="qemu调试linux（二）_20240319_1.png" /> Makefile文件 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">cpvmlinux:  </span></span><br><span class="line">cp /home/dsd/Code/linux-5.18.10/vmlinux vmlinux  </span><br><span class="line">  </span><br><span class="line"><span class="section">cpimage:  </span></span><br><span class="line">cp /home/dsd/Code/linux-5.18.10/arch/x86/boot/bzImage ./bzImage  </span><br><span class="line">  </span><br><span class="line"><span class="section">initramfs:  </span></span><br><span class="line">cd ./initramfs_dir &amp;&amp; find . -print0 | cpio -ov --null --format=newc | gzip -9 &gt; ../initramfs.img  </span><br><span class="line">  </span><br><span class="line"><span class="section">run:  </span></span><br><span class="line">qemu-system-x86_64 \  </span><br><span class="line">-kernel bzImage \  </span><br><span class="line">-initrd initramfs.img \  </span><br><span class="line">-m 1G \  </span><br><span class="line">-nographic \  </span><br><span class="line">-append <span class="string">&quot;earlyprintk=serial,ttyS0 console=ttyS0&quot;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="section">debug:  </span></span><br><span class="line">qemu-system-x86_64 \  </span><br><span class="line">-kernel bzImage \  </span><br><span class="line">-initrd initramfs.img \  </span><br><span class="line">-m 1G \  </span><br><span class="line">-nographic \  </span><br><span class="line">-append <span class="string">&quot;earlyprintk=serial,ttyS0 console=ttyS0 nokaslr&quot;</span> \  </span><br><span class="line">-S \  </span><br><span class="line">-gdb tcp::9000</span><br></pre></td></tr></table></figure> 此目录下新建<code>.gdbinit</code>文件 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">target remote :9000  </span><br><span class="line">break start_kernel  </span><br><span class="line">continue  </span><br><span class="line">step</span><br></pre></td></tr></table></figure> 在<code>root/.gdbinit</code>文件增加<code>add-auto-load-safe-path /home/dsd/Code/qemu_linux_x86_5.18_space/.gdbinit</code> <img src="qemu调试linux（二）_20240319_2.png" /> 运行指令，任选一条 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">gdb vmlinux</span><br><span class="line">gdb-multiarch vmlinux --tui</span><br></pre></td></tr></table></figure> <img src="qemu调试linux（二）_20240319_3.png" /></p>
<h2 id="vscode调试">vscode调试</h2>
<p>wsl权限问题，目录往外多一些 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown 755 &lt;usr&gt; *</span><br></pre></td></tr></table></figure> 生成编译指令信息，此时linux源码根目录下增加文件<code>compile_commands.json</code> <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">./scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure> 配置<code>.vscode/lanuch.json</code> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu-kernel-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:9000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;/vmlinux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure> 配置<code>.vscode/c_cpp_properties.json</code> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compileCommands&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/compile_commands.json&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure> 开始调试 <img src="qemu调试linux（二）_20240319_4.png" /></p>
<h3 id="附调试qemu虚拟机模板">附：调试qemu虚拟机模板</h3>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug.elf&quot;</span><span class="punctuation">,</span><span class="comment">//vmlinux路径，debug的文件 &lt;--修改这里</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//启动参数,如果需要记录日志可以自己增加参数。因为gdbsever已经有了参数，这里可以不用设置</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//会自动停在main,不需要则设置为false</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span> <span class="comment">//运行模式</span></span><br><span class="line">            <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;moduleLoad&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//命令</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set architecture aarch64&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set architecture aarch64&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span><span class="string">&quot;gdb-multiarch&quot;</span><span class="punctuation">,</span><span class="comment">//工具链gdb，arm下要使用多分支</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span><span class="string">&quot;localhost:1234&quot;</span><span class="comment">//远程端口</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>环境搭建</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>audit审计工具使用</title>
    <url>/2024/04/11/audit%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/audit%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="audit用途">audit用途</h2>
<p>监控文件、命令、网络等，生成监控报告。</p>
<h2 id="安装启动audit">安装启动audit</h2>
<p>安装audit工具 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">yum install audit</span><br></pre></td></tr></table></figure> 配置了 <code>auditd</code> 后，启动服务以收集 审计信息，并将它存储在日志文件中。以 root 用户身份运行以下命令来启动 <code>auditd</code> ：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">service auditd start</span><br></pre></td></tr></table></figure>
<p>将 <code>auditd</code> 配置为在引导时启动：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">systemctl enable auditd</span><br></pre></td></tr></table></figure>
<p>可以使用 <code># auditctl -e 0</code> 命令临时禁用 <code>auditd</code>，并使用 <code># auditctl -e 1</code> 重新启用它。</p>
<p>可以使用 <code>service auditd _&lt;action&gt;_</code> 命令对 <code>auditd</code> 执行其他操作，其中 <code>_&lt;action&gt;_</code>可以是以下之一：</p>
<p><code>stop</code> ：停止 <code>auditd</code>。</p>
<p><code>restart</code>：重新启动 <code>auditd</code>。</p>
<p><code>reload</code> 或 <code>force-reload</code>：重新加载 <code>/etc/audit/auditd.conf</code> 文件中 <code>auditd</code> 的配置。</p>
<p><code>rotate</code>：轮转 <code>/var/log/audit/</code> 目录中的日志文件。</p>
<p><code>resume</code>：在其之前被暂停后重新恢复审计事件记录，例如，当保存审计日志文件的磁盘分区中没有足够的可用空间时。</p>
<p><code>condrestart</code> 或 <code>try-restart</code>：只有当 <code>auditd</code> 运行时才重新启动它。</p>
<p><code>status</code>：显示 <code>auditd</code> 的运行状态。</p>
<h2 id="配置规则">配置规则</h2>
<p>举例说明，监控<code>/home/test_audit/</code>文件夹（文件）的变更选项为rwxa（<strong>r</strong>=read, <strong>w</strong>=write, <strong>x</strong>=execute, <strong>a</strong>=attribute），设置关键字<code>dushnda_watch</code> <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">auditctl -w /home/test_audit/ -p rwxa -k dushnda_watch</span><br></pre></td></tr></table></figure> 配置完后查询规则 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[root@172 ~]# auditctl -l</span><br><span class="line">-w /home/test_audit -p rwxa -k dushnda_watch</span><br></pre></td></tr></table></figure> 之后做一些权限改变，增改文件操，查看日志<code>ausearch</code>，查看报告<code>areport</code> <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">ausearch -i -k dushnda_watch</span><br></pre></td></tr></table></figure></p>
<p><img src="audit审计工具使用_20240411_3.png" /></p>
<p>这里的每个type是一个一次的一条记录，具体的含义查看参考链接<code>[1]</code>，这里主要关注对文件的操作，这段日志含义是使用vim打开了文件（syscall），当前文件权限是644。</p>
<p><img src="audit审计工具使用_20240411_1.png" /></p>
<p>删除路径监控 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">auditctl -W /home/test_audit -p rwxa -k dushnda_watch</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中，<code>auditctl -d</code>的删除和<code>auditctl -a</code>的添加对应，<code>auditctl -W</code>的删除和<code>auditctl -w</code>的添加对应，<code>auditctl -D</code>删除所有规则。</p>
</blockquote>
<h2 id="参考链接">参考链接</h2>
<p>[1] https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/security_hardening/auditing-the-system_security-hardening#linux-audit_auditing-the-system</p>
<p>[2] https://deepinout.com/linux-cmd/linux-audit-system-related-cmd/linux-cmd-auditctl.html</p>
]]></content>
      <tags>
        <tag>监控</tag>
        <tag>audit</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Trouble Shooting</title>
    <url>/2025/12/21/shells/Linux%20Troubleshooting/</url>
    <content><![CDATA[<blockquote>
<p>转载：https://github.com/rahulrajaram/linux_troubleshooting</p>
</blockquote>
<p>Purpose: a single-page, production-ready cheatsheet for Linux/SRE triage. Optimized for fast on-call</p>
<p>use: concise flags, copy-paste recipes, brief notes, and clear risk callouts.</p>
<h1 id="binaries-elf">Binaries &amp; ELF</h1>
<p>Cheat Card</p>
<ul>
<li>Linked libs: <code>ldd /path/to/bin</code> (security caveat: may execute code in rare cases)</li>
<li>ELF headers/sections: <code>readelf -h /bin/ls</code>; sections: <code>readelf -S /bin/ls</code></li>
<li>Symbols (prefer readelf): <code>readelf -Ws /bin/ls | grep ' FUNC '</code>; dynamic: <code>readelf -Ws -d /bin/ls</code></li>
<li>Disassemble: <code>objdump -d /bin/ls | less</code> (add <code>-M intel</code> for Intel syntax)</li>
<li>Symbols via nm: <code>nm -D /bin/ls | grep symbol_name</code></li>
<li>Requires: binutils (readelf/objdump/nm)</li>
</ul>
<h2 id="ldd">1. ldd</h2>
<p>List shared library dependencies of executables and shared objects.</p>
<ul>
<li>Basic: <code>ldd /path/to/bin</code></li>
<li>Security caveat: may execute code in rare cases; avoid on untrusted binaries.</li>
<li>Alternative: <code>LD_TRACE_LOADED_OBJECTS=1 /lib64/ld-linux-x86-64.so.2 /path/to/bin</code> (still uses loader)</li>
</ul>
<h3 id="text-data-utilities">Text &amp; Data Utilities</h3>
<p>Cheat Card</p>
<ul>
<li>Search recursively: <code>grep -RIn --exclude-dir .git 'pattern' .</code>; context: <code>-C2</code></li>
<li>Edit in-place: <code>sed -i.bak -E 's/old/new/g' file</code> (backup)</li>
<li>Summarize data: <code>awk -F, '{a[$1]+=$2} END{for(k in a) print k,a[k]}' file.csv</code></li>
<li>JSON parse: <code>jq -r '.items[].metadata.name' file.json</code></li>
<li>Compare dirs: <code>diff -ruN dir_old dir_new | less -R</code></li>
<li>Transform text: <code>tr -s ' ' | cut -d, -f1,3 | xargs -n1 echo</code></li>
<li>Safe temp: <code>mktemp -d</code> for dirs; files: <code>mktemp</code></li>
<li>Reverse lines: <code>rev &lt;file</code> (quick visual check)</li>
</ul>
<h2 id="grep">2. grep</h2>
<ul>
<li>search for one or more expressions: <code>grep -E 'hello|world' temp</code></li>
<li>search for one or more words: <code>grep -Ew 'hello|world' temp</code></li>
<li>search for suffix matches: <code>grep -E 'hello(world|lolo)' temp</code></li>
<li>search for suffixes matching regex: <code>grep -E 'hello[0-9]{3,}' temp</code></li>
<li>recursive search in tree: <code>grep -RIn --exclude-dir .git --exclude='*.log' 'pattern' .</code></li>
<li>fixed strings (fast) and ignore case: <code>grep -Fni 'literal text' file</code></li>
<li>context lines: <code>grep -R --color -n -C2 'pattern' .</code> (or <code>-A</code> after, <code>-B</code> before)</li>
<li>binary-skip and file names only: <code>grep -rI -l 'pattern' .</code></li>
</ul>
<h2 id="sed">3. sed</h2>
<p>What it does: stream editor for non-interactive find/replace, line edits, and range selections.</p>
<ul>
<li>In-place with backup: <code>sed -i.bak -E 's/old/new/g' file</code></li>
<li>Delete matching lines: <code>sed -i '/pattern/d' file</code></li>
<li>Print lines between markers: <code>sed -n '/BEGIN/,/END/p' file</code></li>
<li>Replace with capture groups: <code>sed -E 's/([0-9]{4})-([0-9]{2})-([0-9]{2})/\3-\2-\1/' file</code></li>
<li>Insert before/after match:
<ul>
<li>Before: <code>sed '/pattern/i\\inserted before' file</code></li>
<li>After: <code>sed '/pattern/a\\appended after' file</code></li>
</ul></li>
<li>Trim trailing spaces: <code>sed -i 's/[ \t]\+$//' file</code></li>
<li>Multiple edits: <code>sed -E -e 's/foo/bar/g' -e '/tmp/d' file</code></li>
</ul>
<h2 id="awk">4. awk</h2>
<p>What it does: text processing and quick data summarization using fields and expressions.</p>
<ul>
<li>Default FS is whitespace; set CSV FS: <code>awk -F, '...' file.csv</code></li>
<li>Select fields: <code>awk '{print $1, $3}' file</code></li>
<li>Filter rows: <code>awk '$5 &gt; 100 {print $1, $5}' file</code></li>
<li>Sum a column: <code>awk '{s+=$3} END{print s}' file</code></li>
<li>Group and sum by key: <code>awk '{a[$1]+=$2} END{for (k in a) print k, a[k]}' file</code></li>
<li>Pretty print: <code>awk '{printf "%-20s %10d\n", $1, $2}' file</code></li>
<li>Count unique values: <code>awk '{c[$1]++} END{for (k in c) print k, c[k]}' file</code></li>
</ul>
<h1 id="networking">Networking</h1>
<p>Cheat Card</p>
<ul>
<li>Ports→PIDs: <code>ss -ltnp</code>; established only: <code>ss -tn state established</code></li>
<li>TCP detail: <code>ss -i dst &lt;ip&gt;</code> (rtt, cwnd, retrans)</li>
<li>Path/source IP: <code>ip route get &lt;dest&gt;</code>; counters: <code>ip -s link show &lt;iface&gt;</code></li>
<li>Latency/loss: <code>mtr -ezbw &lt;dest&gt;</code>; quick traceroute ICMP: <code>traceroute -I &lt;dest&gt;</code></li>
<li>Targeted capture: <code>tcpdump -ni &lt;iface&gt; tcp port 443</code> (or <code>port 53</code>, <code>icmp</code>)</li>
<li>DNS: <code>resolvectl query &lt;name&gt;</code> or <code>dig &lt;name&gt; A +short</code></li>
</ul>
<h2 id="ping">5. ping</h2>
<ul>
<li>Compat: Linux; Root: may require CAP_NET_RAW depending on system; Requires: iputils-ping.</li>
<li><code>-4</code>: ping IPv4 only</li>
<li><code>-6</code>: ping IPv6 only</li>
<li><code>-A</code>: adapts to roundtrip time</li>
<li><code>-b</code>: allow pinging broadcast addresses</li>
<li><code>-I</code>: ping through an interface</li>
<li><code>-M</code>: set PMTU strategy</li>
<li><code>-s</code>: set packetsize (default is 56B)</li>
<li><code>-t</code>: set IP time-to-live</li>
<li><code>ping 224.0.0.1</code>: ping multicast address</li>
</ul>
<p>Notes: - Using average <code>rtt</code> values, you can determine whether there are huge variations causing jitter, especially in RT applications - ping will report duplications, however, duplicate packets should never occur, and seem to be caused by inappropriate link-level retransmissions - ping will report damaged packets, suggesting broken hardware in the network Requires: iputils-ping.</p>
<h2 id="ip">6. ip</h2>
<ul>
<li>Compat: Linux; Root: not required for reads; Requires: iproute2.</li>
<li><code>ip addr</code>: Show information for all addresses</li>
<li><code>ip addr show dev wlo1</code>: Display information only for device wlo1</li>
<li><code>ip link</code>: Show information for all interfaces</li>
<li><code>ip link show dev wlo1</code>: Display information only for device wlo1</li>
<li><code>ip -s</code>: Display interface statistics (packets dropped, received, sent, etc.)</li>
<li>Quick recipes:
<ul>
<li>Path and source IP: <code>ip route get &lt;dest&gt;</code></li>
<li>Interface counters: <code>ip -s link show &lt;iface&gt;</code> (rx/tx errors, drops)</li>
<li>Neighbors/ARP: <code>ip neigh</code> and <code>ip neigh show dev &lt;iface&gt;</code></li>
<li>Multicast: <code>ip maddr</code> or <code>ip maddr show dev &lt;iface&gt;</code></li>
</ul></li>
</ul>
<p>Example <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Query path and chosen <span class="built_in">source</span> IP</span></span><br><span class="line">ip route get 8.8.8.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Expect: 8.8.8.8 via 192.168.1.1 dev wlo1 src 192.168.1.23</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>ip route</code>: List all of the route entries in the kernel</li>
<li><code>ip route add</code>: Add a route entry to the kernel routing table</li>
<li><code>ip route replace</code>: Replace an existing route (add if not present)</li>
<li><code>ip maddr</code>: Display multicast information for all devices</li>
<li><code>ip maddr show dev wlo1</code></li>
<li><code>ip neigh show dev wlo1</code>: check for reachability of specific interfaces Requires: iproute2.</li>
</ul>
<h2 id="arp">7. arp</h2>
<ul>
<li>Compat: Legacy; prefer <code>ip neigh</code>; Requires: net-tools.</li>
<li><code>arp</code>: show all ARP table entries</li>
<li><code>arp -d address</code>: delete ARP entry for address</li>
<li><code>arp -s address hw_addr</code>: set up new table entry Note: legacy from net-tools; prefer <code>ip neigh</code>. Requires: net-tools.</li>
</ul>
<h2 id="arping">8. arping</h2>
<ul>
<li>Compat: Linux; Root/CAP_NET_RAW required; Package: arping (iputils-arping on some distros).</li>
<li><code>arping -I wlo1 192.168.0.1</code>: send ARP requests to host</li>
<li><code>arping -D -I wlo1 192.168.0.15</code>: check for duplicate MAC address Requires: arping (iputils-arping on some distros).</li>
</ul>
<h2 id="ethtool">9. ethtool</h2>
<ul>
<li>Compat: Linux; Root for changing settings, read stats usually ok; Requires: ethtool.</li>
<li><code>ethtool -S wlo1</code>: print network statistics Requires: ethtool.</li>
</ul>
<h2 id="ss">10. ss</h2>
<ul>
<li>Compat: Linux; Modern replacement for netstat; Requires: iproute2.</li>
<li><code>ss -a</code>: show all sockets</li>
<li><code>ss -o</code>: show all sockets with timer information</li>
<li><code>ss -p</code>: show process using the socket</li>
<li><code>ss -t|-u|-4|-6</code></li>
<li><code>ss -ltnp</code>: list listening TCP sockets with PIDs</li>
<li><code>ss -tn state established</code>: show established TCP only</li>
<li><code>ss -tn sport = :443</code> or <code>ss -tn dport = :443</code>: filter by port</li>
<li><code>ss -s</code>: summary stats (TCP states, mem)</li>
<li><code>ss -i</code>:
<ul>
<li><code>ts</code>: show string “ts” if the timestamp option is set</li>
<li><code>sack</code>: show string “sack” if the sack option is set</li>
<li><code>ecn</code>: show string “ecn” if the explicit congestion notification option is set</li>
<li><code>ecnseen</code>: show string “ecnseen” if the saw ecn flag is found in received packets</li>
<li><code>fastopen</code>: show string “fastopen” if the fastopen option is set</li>
<li><code>cong_alg</code>: the congestion algorithm name, the default congestion algorithm is “cubic”</li>
<li><code>wscale:&lt;snd_wscale&gt;:&lt;rcv_wscale&gt;</code>: if window scale option is used, this field shows the send scale factor and receive scale factor</li>
<li><code>rto:&lt;icsk_rto&gt;</code>: tcp re-transmission timeout value, the unit is millisecond</li>
<li><code>backoff:&lt;icsk_backoff&gt;</code>: used for exponential backoff re-transmission, the actual re-transmission timeout value is icsk_rto &lt;&lt; icsk_backoff</li>
<li><code>rtt:&lt;rtt&gt;/&lt;rttvar&gt;</code>: rtt is the average round trip time, rttvar is the mean deviation of rtt, their units are millisecond</li>
<li><code>ato:&lt;ato&gt;</code>: ack timeout, unit is millisecond, used for delay ack mode</li>
<li><code>mss:&lt;mss&gt;</code>: max segment size</li>
<li><code>cwnd:&lt;cwnd&gt;</code>: congestion window size</li>
<li><code>pmtu:&lt;pmtu&gt;</code>: path MTU value</li>
<li><code>ssthresh:&lt;ssthresh&gt;</code>: tcp congestion window slow start threshold</li>
<li><code>bytes_acked:&lt;bytes_acked&gt;</code>: bytes acked</li>
<li><code>bytes_received:&lt;bytes_received&gt;</code>: bytes received</li>
<li><code>segs_out:&lt;segs_out&gt;</code>: segments sent out</li>
<li><code>segs_in:&lt;segs_in&gt;</code>: segments received</li>
<li><code>send &lt;send_bps&gt;bps</code>: egress bps</li>
<li><code>lastsnd:&lt;lastsnd&gt;</code>: how long time since the last packet sent, the unit is millisecond</li>
<li><code>lastrcv:&lt;lastrcv&gt;</code>: how long time since the last packet received, the unit is millisecond</li>
<li><code>lastack:&lt;lastack&gt;</code>: how long time since the last ack received, the unit is millisecond</li>
</ul></li>
<li><code>ss -A tcp,udp</code>: dump socket tables Requires: iproute2.</li>
</ul>
<h2 id="tcpdump">37. tcpdump</h2>
<p>Compat: Linux; Root/CAP_NET_RAW required for captures; Requires: tcpdump. What it does: capture packets for inspection and troubleshooting. Requires: tcpdump.</p>
<ul>
<li><p>Interface and no name resolution: <code>tcpdump -ni &lt;iface&gt;</code></p></li>
<li><p>Host or subnet: <code>tcpdump -ni &lt;iface&gt; host &lt;ip&gt;</code>; <code>tcpdump -ni &lt;iface&gt; net 10.0.0.0/8</code></p></li>
<li><p>Ports/protocols: <code>tcpdump -ni &lt;iface&gt; tcp port 443</code> or <code>udp port 53</code></p></li>
<li><p>SYNs only (new TCP handshakes): <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">New TCP handshakes only (SYN without ACK)</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; &#x27;tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) == 0&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p>DNS queries: <code>tcpdump -ni &lt;iface&gt; port 53</code></p></li>
<li><p>ICMP reachability: <code>tcpdump -ni &lt;iface&gt; icmp</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Requires: tcpdump</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Capture full packets to a file</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; -s 0 -w capture.pcap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rotate captures every 5m, keep 6 files</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; -s 0 -G 300 -W 6 -w &#x27;cap-%Y%m%d%H%M%S.pcap&#x27;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="mtr">38. mtr</h2>
<p>Compat: Linux; May need root/CAP_NET_RAW for certain probe types; Requires: mtr. What it does: combines ping and traceroute to visualize latency and loss per hop.</p>
<ul>
<li>Run with extra info: <code>mtr -ezbw &lt;dest&gt;</code></li>
<li>Report mode (one-off): <code>mtr -ezbwrc 10 &lt;dest&gt;</code> Requires: mtr.</li>
</ul>
<h2 id="traceroute">39. traceroute</h2>
<ul>
<li>Compat: Linux; Requires: traceroute; TCP mode may need CAP_NET_RAW/root.</li>
<li><code>traceroute -I</code>: use ICMP echo for probes</li>
<li><code>traceroute -T</code>: use TCP SYN for probes Requires: traceroute.</li>
</ul>
<h2 id="nicstat">40. nicstat</h2>
<ul>
<li>Compat: Linux; Not widely packaged; Consider <code>sar -n</code>/<code>ethtool -S</code> alternatives.</li>
<li>nicstat prints out network statistics for all network cards (NICs), including packets, kilobytes per second, average packet sizes and more.</li>
<li><code>nicstat -t</code>: show CPU stats</li>
<li><code>nicstat</code>: show network interface stats Requires: nicstat (may need third-party repo/source on some distros).</li>
</ul>
<p>Metrics reference (click to expand)</p>
<ul>
<li><code>Time</code> - The time corresponding to the end of the sample shown, in HH:MM:SS format (24-hour clock).</li>
<li><code>Int</code> - The interface name.</li>
<li><code>rKB/s, InKB</code> - Kilobytes/second read (received).</li>
<li><code>wKB/s, OutKB</code> - Kilobytes/second written (transmitted).</li>
<li><code>rMbps, RdMbps</code> - Megabits/second read (received).</li>
<li><code>wMbps, WrMbps</code> - Megabits/second written (transmitted).</li>
<li><code>rPk/s, InSeg, InDG</code> - Packets (TCP Segments, UDP Datagrams)/second read (received).</li>
<li><code>wPk/s, OutSeg, OutDG</code> - Packets (TCP Segments, UDP Datagrams)/second written (transmitted).</li>
<li><code>rAvs</code> - Average size of packets read (received).</li>
<li><code>wAvs</code> - Average size of packets written (transmitted).</li>
<li><code>%Util</code> - Percentage utilization of the interface. For full-duplex interfaces, this is the greater of rKB/s or wKB/s as a percentage of the interface speed. For half-duplex interfaces, rKB/s and wKB/s are summed.</li>
<li><code>%rUtil, %wUtil</code> - Percentage utilization for bytes read and written, respectively.</li>
<li><code>Sat</code> - Saturation. This the number of errors/second seen for the interface
<ul>
<li>an indicator the interface may be approaching saturation. This statistic is combined from a number of kernel statistics. It is recommended to use the ‘-x’ option to see more individual statistics (those mentioned below) when attempting to diagnose a network issue.</li>
</ul></li>
<li><code>IErr</code> - Packets received that could not be processed because they contained errors</li>
<li><code>OErr</code> - Packets that were not successfully transmitted because of errors</li>
<li><code>Coll</code> - Ethernet collisions during transmit.</li>
<li><code>NoCP</code> - No-can-puts. This is when an incoming packet can not be put to the process reading the socket. This suggests the local process is unable to process incoming packets in a timely manner.</li>
<li><code>Defer</code> - Defer Transmits. Packets without collisions where first transmit attempt was delayed because the medium was busy.</li>
<li><code>Reset</code> - tcpEstabResets. The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.</li>
<li><code>AttF</code> - tcpAttemptFails - The number of times that TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.</li>
<li><code>%ReTX</code> - Percentage of TCP segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets.</li>
<li><code>InConn</code> - tcpPassiveOpens - The number of times that TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state.</li>
<li><code>OutCon</code> - tcpActiveOpens - The number of times that TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state.</li>
<li><code>Drops</code> - tcpHalfOpenDrop + tcpListenDrop + tcpListenDropQ0. tcpListenDrop and tcpListenDropQ0 - Number of connections dropped from the completed connection queue and incomplete connection queue, respectively. tcpHalfOpenDrops - Number of connections dropped after the initial SYN packet was received.</li>
</ul>
<h2 id="nslookup">41. nslookup</h2>
<ul>
<li>Compat: Legacy; prefer <code>dig</code>/<code>resolvectl</code>; Requires: dnsutils/bind-utils.query Internet name servers interactively</li>
<li><code>nslookup &lt;domain&gt;</code></li>
<li>Note: legacy tool. Prefer <code>dig</code> for detailed queries or <code>resolvectl</code> on systemd-based systems. Requires: dnsutils/bind-utils (for nslookup/dig).</li>
<li>Quick equivalents: <code>dig &lt;domain&gt; A +short</code>; <code>resolvectl query &lt;domain&gt;</code></li>
</ul>
<h2 id="host">42. host</h2>
<ul>
<li>Compat: Linux; Requires: bind9-host/bind-utils. host is a simple utility for performing DNS lookups. It is normally used to convert names to IP addresses and vice versa.</li>
<li><code>host &lt;domain&gt;</code></li>
<li>Examples: <code>host -t A &lt;domain&gt;</code>; reverse lookup: <code>host &lt;ip&gt;</code></li>
<li>Tip: for more control, use <code>dig</code> (if installed) or <code>resolvectl</code>. Requires: bind9-host (Debian/Ubuntu) or bind-utils.</li>
</ul>
<h2 id="iwconfig">43. iwconfig</h2>
<ul>
<li>Compat: Legacy; prefer <code>iw</code>; Requires: wireless-tools.</li>
<li><code>iwconfig wlo1</code>: show WLAN config:</li>
<li>Note: <code>iwconfig</code> is legacy (wireless-tools). Prefer <code>iw</code> for modern drivers, e.g., <code>iw dev</code>, <code>iw dev wlo1 link</code>. Requires: wireless-tools. Modern alternative: iw. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wlo1      IEEE 802.11  ESSID:&quot;NETGEAR97&quot;  </span><br><span class="line">      Mode:Managed  Frequency:2.462 GHz  Access Point: C4:04:15:58:60:C7   </span><br><span class="line">      Bit Rate=72.2 Mb/s   Tx-Power=20 dBm   </span><br><span class="line">      Retry short limit:7   RTS thr=2347 B   Fragment thr:off</span><br><span class="line">      Power Management:off</span><br><span class="line">      Link Quality=70/70  Signal level=-32 dBm  </span><br><span class="line">      Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0</span><br><span class="line">      Tx excessive retries:0  Invalid misc:22932   Missed beacon:0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="brctl">44. brctl</h2>
<ul>
<li>Compat: Legacy; prefer <code>ip link</code> and <code>bridge</code>; Requires: bridge-utils.</li>
<li>brctl is used to set up, maintain, and inspect the ethernet bridge configuration in the linux kernel. Legacy: prefer <code>ip link add name br0 type bridge</code> and <code>bridge</code> (iproute2) tooling. Requires: bridge-utils.</li>
</ul>
<h1 id="kernel-tracing">Kernel &amp; Tracing</h1>
<p>Cheat Card</p>
<ul>
<li>Kernel logs: <code>dmesg -T -l err,crit,alert,emerg</code></li>
<li>Syscalls: <code>strace -ttT -p &lt;pid&gt; -f -e trace=network,file</code></li>
<li>Modules: <code>lsmod | head</code>, <code>modprobe &lt;name&gt;</code> (caution), <code>sysctl -a | grep tcp</code></li>
<li>Optional advanced: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">perf (<span class="keyword">if</span> installed)</span></span><br><span class="line">perf top</span><br><span class="line">perf record -g -p &lt;pid&gt;; perf report</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bpftrace one-liner (Requires: bpftrace)</span></span><br><span class="line">bpftrace -e &#x27;tracepoint:syscalls:sys_enter_openat &#123; @[comm] = count(); &#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="dmesg">11. dmesg</h2>
<ul>
<li><p>Compat: Linux; May be restricted by <code>kernel.dmesg_restrict</code>; Requires: util-linux.</p></li>
<li><p><code>dmesg --level=&lt;LEVEL&gt;</code> where <code>&lt;LEVEL&gt;</code> is:</p>
<ul>
<li><code>emerg</code> - system is unusable.</li>
<li><code>alert</code> - action must be taken immediately.</li>
<li><code>crit</code> - critical conditions.</li>
<li><code>err</code> - error conditions.</li>
<li><code>warn</code> - warning conditions.</li>
<li><code>notice</code> - normal but significant condition.</li>
<li><code>info</code> - informational.</li>
<li><code>debug</code> - debug-level messages.</li>
</ul></li>
<li><p><code>dmesg -k</code>: print kernel messages</p></li>
<li><p><code>dmesg -f=&lt;FACILITY&gt;</code> where <code>&lt;FACILITY&gt;</code> is:</p>
<ul>
<li><code>kern</code>: Kernel messages.</li>
<li><code>user</code>: User-level messages.</li>
<li><code>mail</code>: Mail system.</li>
<li><code>daemon</code>: System daemons.</li>
<li><code>auth</code>: Security/authorization messages.</li>
<li><code>syslog</code>: Internal syslogd messages.</li>
<li><code>lpr</code>: Line printer subsystem.</li>
<li><code>news</code>: Network news subsystem.</li>
</ul></li>
<li><p><code>dmesg -T</code>: human readable timestamps</p></li>
</ul>
<h2 id="lsmod">12. lsmod</h2>
<ul>
<li>Compat: Linux; Lists modules without root; Requires: kmod.</li>
<li>Show loaded kernel modules and sizes/dependencies.</li>
<li>Quick peek: <code>lsmod | head</code></li>
<li>Module info (version, params): <code>modinfo &lt;module&gt;</code></li>
</ul>
<h2 id="modprobe">13. modprobe</h2>
<ul>
<li>Compat: Linux; Root required; Caution: can destabilize systems; Requires: kmod.Add or remove modules from the Linux kernel.</li>
<li>Load: <code>modprobe &lt;module&gt;</code>; with params: <code>modprobe &lt;module&gt; key=value</code></li>
<li>Unload: <code>modprobe -r &lt;module&gt;</code> (fails if in use)</li>
<li>Caution: loading/unloading modules can destabilize systems; prefer persistent config and ensure module compatibility.</li>
</ul>
<h1 id="disk-filesystems">Disk &amp; Filesystems</h1>
<p>Cheat Card</p>
<ul>
<li>Space/inodes: <code>df -h</code> and <code>df -i</code>; biggest dirs: <code>du -xhd1 /path | sort -h</code></li>
<li>IO saturation: <code>iostat -xz 1</code>; per-proc IO: <code>pidstat -d 1</code>, <code>iotop -oPa</code></li>
<li>Devices/FS: <code>lsblk -o NAME,TYPE,SIZE,ROTA,MOUNTPOINT,MODEL</code>; mounts: <code>findmnt</code></li>
<li>Mount ops: <code>mount --bind olddir newdir</code>; remount ro: <code>mount -o remount,ro /mnt</code></li>
</ul>
<p>Inventory and health</p>
<ul>
<li>Device tree: <code>lsblk -o NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,MODEL</code></li>
<li>Identify filesystem UUID/TYPE: <code>blkid</code></li>
<li>SMART check (if supported): <code>smartctl -H /dev/sdX</code> and <code>smartctl -a /dev/sdX</code> (Requires: smartmontools)</li>
<li>NVMe info: <code>nvme list</code>; <code>nvme smart-log /dev/nvme0</code> (Requires: nvme-cli)</li>
</ul>
<p><strong>Notes</strong></p>
<ul>
<li>iostat quick view (Requires: sysstat): <code>iostat -xz 1</code> (watch <code>await</code>, <code>%util</code>, <code>r/s</code>, <code>w/s</code>)</li>
<li>findmnt: show mount hierarchy or lookup by target: <code>findmnt /mount/point</code></li>
<li>adds or removes modules from the Linux Kernel</li>
<li>Caution: loading/unloading modules can destabilize systems; prefer persistent config and ensure module compatibility.</li>
</ul>
<h2 id="dd-danger-destructive-read-first">14. dd (DANGER: DESTRUCTIVE — READ FIRST)</h2>
<ul>
<li>Compat: Linux; Root required for raw devices; Highly destructive when writing; Requires: coreutils.</li>
<li>Danger: dd will overwrite data with no confirmation. Double-check devices (e.g., <code>/dev/sdX</code>) and consider read-only or safer alternatives first. Use <code>lsblk</code>, <code>blkid</code> to verify targets.</li>
<li>Safer tips: for copies, consider <code>pv</code> to visualize throughput; for imaging, <code>dcfldd</code>; for testing, prefer non-destructive reads. <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Danger: wipes target disk. Verify device with lsblk/blkid.</span></span><br><span class="line">dd if=/dev/zero of=/dev/sda bs=4k status=progress</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Verify a drive is zeroed (non-zero bytes check)</span></span><br><span class="line">dd if=/dev/sda status=none | hexdump -C | grep -q &#x27;[^00]&#x27; || echo &quot;All zeros&quot;</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fill a file with random data (example size)</span></span><br><span class="line">dd if=/dev/urandom of=myfile bs=6703104 count=1 status=progress</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Danger: <span class="built_in">clone</span> a partition to another (same size/align). Verify both!</span></span><br><span class="line">dd if=/dev/sda3 of=/dev/sdb3 bs=4096 status=progress conv=fsync</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Danger: write an image to a USB device. Verify device path first!</span></span><br><span class="line">dd if=/path/to/bootimage.img of=/dev/sdc bs=4M status=progress conv=fsync</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Quick r/w benchmark <span class="keyword">for</span> a file (non-destructive <span class="built_in">read</span> + temp write)</span></span><br><span class="line">dd if=/home/$user/bigfile of=/dev/null status=progress</span><br><span class="line">dd if=/dev/zero of=/home/$user/bigfile bs=1M count=1000 oflag=dsync status=progress</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sequential device <span class="built_in">read</span> throughput sample (approx 1 GiB)</span></span><br><span class="line">dd if=/dev/sda of=/dev/null bs=1024k count=1024 status=progress</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Create a swapfile (example: 8 GiB), <span class="keyword">then</span> mkswap + swapon</span></span><br><span class="line">dd if=/dev/zero of=swapfile bs=1MiB count=$((8*1024)) status=progress</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jq">15. jq</h2>
<ul>
<li><p>Compat: Linux; Requires: jq package. What it does: parse/query/transform JSON on the command line. Requires: jq.</p></li>
<li><p>Pretty-print: <code>jq . file.json</code></p></li>
<li><p>Extract field list: <code>jq -r '.items[].metadata.name' file.json</code></p></li>
<li><p>Filter by condition: <code>jq '.[] | select(.status=="RUNNING")' file.json</code></p></li>
<li><p>Transform and count: <code>jq '[.[] | .level] | group_by(.) | map({level: .[0], count: length})' file.json</code></p></li>
<li><p>Sort and top N: <code>jq 'sort_by(.time) | reverse | .[0:5]' file.json</code></p></li>
<li><p>From journald: <code>journalctl -o json | jq -r 'select(.PRIORITY&lt;=3) | .MESSAGE'</code> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Requires: jq — show high-priority messages from journald</span></span><br><span class="line">journalctl -o json | jq -r &#x27;select(.PRIORITY&lt;=3) | .MESSAGE&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Keys and length: <code>jq 'keys, length' file.json</code></p></li>
</ul>
<h2 id="diff">16. diff</h2>
<ul>
<li>Compat: Linux; Requires: diffutils.</li>
<li>unified diff: <code>diff -u old.txt new.txt</code></li>
<li>recursive dirs: <code>diff -ruN dir_old dir_new</code></li>
<li>ignore whitespace changes: <code>diff -u -w old new</code></li>
<li>handle CRLF: <code>diff -u --strip-trailing-cr a b</code></li>
<li>color (if supported): <code>diff --color=auto -u a b</code></li>
<li>apply a patch: <code>patch -p1 &lt; change.diff</code></li>
</ul>
<h2 id="uname">17. uname</h2>
<ul>
<li>Compat: Linux; Requires: coreutils.</li>
<li>get all details about the computer</li>
</ul>
<h2 id="syncfsync">18. sync/fsync</h2>
<ul>
<li>Compat: Linux; <code>sync</code> is user command; <code>fsync</code> is a syscall.</li>
<li><code>fsync</code> is a syscall that flushes a file’s in-memory data and metadata to storage. From the shell, use <code>sync</code> (flush all dirty data) or <code>syncfs</code> (flush a filesystem) when available.</li>
</ul>
<h2 id="mkswap">19. mkswap</h2>
<ul>
<li>Compat: Linux; Root required; Requires: util-linux.</li>
<li><code>-c</code>: check if blocks are corrupted</li>
<li><code>-p</code>: set pagesize</li>
</ul>
<h2 id="fsck">20. fsck</h2>
<ul>
<li>Compat: Linux; Root required; Avoid on mounted filesystems; Requires: e2fsprogs for ext*.</li>
<li>check for file system consistency:
<ul>
<li>The superblock is checked for inconsistencies in:
<ul>
<li>File system size</li>
<li>Number of inodes</li>
<li>Free-block count</li>
<li>Free-inode count</li>
</ul></li>
<li>Each inode is checked for inconsistencies in:
<ul>
<li>Format and type</li>
<li>Link count</li>
<li>Duplicate block</li>
<li>Bad block numbers</li>
<li>Inode size</li>
</ul></li>
</ul></li>
<li>see: <a href="https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7uf0e/index.html">https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7uf0e/index.html</a></li>
<li>Caution: avoid running fsck on a mounted filesystem (except with specific fs support); prefer read-only mounts or maintenance windows.</li>
</ul>
<p>Extended notes</p>
<ul>
<li>ext* specifics: <code>e2fsck</code> checks ext2/3/4; use <code>-f</code> to force, <code>-n</code> for read-only, <code>-p</code> for preen (auto-fix safe issues). Requires: e2fsprogs.</li>
<li>Bad blocks (DANGER): <code>badblocks</code> scans devices for bad sectors; write-mode is destructive. Prefer read-only first.</li>
</ul>
<p>Examples <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Read-only badblocks scan (non-destructive)</span></span><br><span class="line">sudo badblocks -sv /dev/sdX</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DANGER: write-mode destructive scan — data loss</span></span><br><span class="line">sudo badblocks -wsv /dev/sdX</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ext* filesystem check (read-only)</span></span><br><span class="line">sudo e2fsck -fn /dev/sdXN</span><br></pre></td></tr></table></figure></p>
<h2 id="mount">21. mount</h2>
<ul>
<li>Compat: Linux; Root required unless user mounts configured; Requires: util-linux.</li>
<li><code>mount -a [-t type] [-O optlist]</code>: mount all FSs mentioned in fstab to be mounted</li>
<li><code>-o</code>: override the settings in fstab</li>
<li><code>mount --bind olddir newdir</code>: remount part of the hierarchy elsewhere</li>
<li><code>mount --move</code>: move mounted tree to another place</li>
<li>Caution: <code>--bind/--move</code> and remounts can impact running services; ensure correct <code>fstab</code> for persistence and have rollback plan.</li>
</ul>
<h2 id="umount">22. umount</h2>
<ul>
<li>Compat: Linux; Root required for system mounts; Requires: util-linux.</li>
<li>unmount from a mountpoint</li>
</ul>
<h2 id="chown">23. chown</h2>
<ul>
<li><code>chown root:staff /u</code>: change owner and group</li>
</ul>
<h2 id="sysctl">24. sysctl</h2>
<ul>
<li>Compat: Linux; Root required for <code>-w</code>; Persistence via <code>/etc/sysctl.d</code>; Requires: procps.</li>
<li>configure kernel parameters at runtime</li>
<li><code>sysctl -a | grep "tcp"</code></li>
<li>Caution: <code>sysctl -w</code> changes take effect immediately; persist only via <code>/etc/sysctl.d/*.conf</code> after validation.</li>
<li>Read a key: <code>sysctl net.ipv4.tcp_congestion_control</code></li>
<li>Set a key (runtime): <code>sysctl -w vm.swappiness=10</code></li>
<li>Persist: create <code>/etc/sysctl.d/99-local.conf</code> with <code>vm.swappiness = 10</code>, then <code>sysctl --system</code></li>
</ul>
<h2 id="iotop">25. iotop</h2>
<ul>
<li>Compat: Linux; Root required; Needs kernel taskstats/delay accounting; Python tool.</li>
<li><code>iotop -o</code>: only show threads doing I/O</li>
<li><code>iotop -p &lt;PID1&gt;,&lt;PID2&gt;,...</code>: list of processes to monitor</li>
<li><code>iotop -a</code>: show accumulated IO rather than diff Requires: iotop.</li>
</ul>
<h2 id="netstat">26. netstat</h2>
<ul>
<li>Compat: Legacy; prefer <code>ss</code>; Requires: net-tools.</li>
</ul>
<h1 id="processes-scheduling">Processes &amp; Scheduling</h1>
<p>Cheat Card</p>
<ul>
<li><p>Top offenders: <code>ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%cpu | head</code></p></li>
<li><p>Threads view: <code>top -H</code> or <code>ps -Lp &lt;pid&gt; -o pid,tid,pcpu,comm</code></p></li>
<li><p>Target processes: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Preview before signaling</span></span><br><span class="line">pgrep -a &lt;name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Then send a scoped, safe signal (example: TERM)</span></span><br><span class="line">pkill -TERM -u &lt;user&gt; -f &#x27;&lt;exact-pattern&gt;&#x27;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Over time: <code>pidstat -u 1 -p &lt;pid&gt;</code> (CPU) and <code>pidstat -d 1</code> (IO)</p></li>
<li><p>Find PIDs: <code>pidof &lt;proc&gt;</code>; list threads: <code>ps -Lp &lt;pid&gt;</code></p></li>
<li><p>Niceness: start <code>nice -n 10 cmd</code>; adjust: <code>renice -n 10 -p &lt;pid&gt;</code></p></li>
<li><p>Locks: <code>/proc/locks</code> shows current file locks (read-only)</p></li>
<li><p>Sessions: users <code>who</code>; recent logins <code>last | head</code></p></li>
<li><p>Schedule: <code>crontab -l</code> list; <code>crontab -e</code> edit</p></li>
<li><p>Deprecated in many distros; prefer <code>ss</code>.</p></li>
<li><p>Common mappings:</p>
<ul>
<li><code>netstat -tulpn</code> -&gt; <code>ss -tulpn</code></li>
<li><code>netstat -anp</code> -&gt; <code>ss -anp</code></li>
<li><code>netstat -s</code> -&gt; <code>ss -s</code></li>
</ul></li>
</ul>
<h2 id="top">27. top</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
<li>Dynamic process view with CPU, memory, and load summaries.</li>
<li>Key CPU line fields: <code>us</code> (user), <code>sy</code> (system), <code>ni</code>, <code>id</code> (idle), <code>wa</code> (iowait), <code>hi/si</code> (IRQ/softIRQ), <code>st</code> (steal).</li>
<li>Key per-proc fields: <code>%CPU</code>, <code>%MEM</code>, <code>VIRT</code> (virtual), <code>RES</code> (resident), <code>SHR</code> (shared), <code>TIME+</code> (CPU time).</li>
<li><code>top -E m|g</code>: scale as mega|giga bytes</li>
<li><code>top -H</code>: thread-mode</li>
<li><code>top -i</code>: show idle processes</li>
<li><code>top -o RES|VIRT|SWAP</code>, etc: sort by attribute</li>
<li><code>top -O</code>: output fields: print all available sort-attributes</li>
<li><code>top -p pid1,pid2,...</code>: monitor only these PIDs</li>
<li><code>top -1</code>: show per-CPU stats</li>
</ul>
<h2 id="vmstat">28. vmstat</h2>
<ul>
<li>Compat: Linux; Requires: procps. Useful to get so/si information</li>
<li>Report virtual memory statistics</li>
<li><code>vmstat -a</code>: number active/inactive memory</li>
<li><code>vmstat --stats</code>: various statistics</li>
</ul>
<p>Interpretation tips</p>
<ul>
<li><code>r</code> runnable &gt; number of CPUs indicates run-queue contention.</li>
<li><code>b</code> blocked processes (often IO wait); correlate with <code>%wa</code> in top/mpstat.</li>
<li><code>si/so</code> swap in/out: sustained non-zero values indicate memory pressure.</li>
<li>Use <code>vmstat 1</code> for near-real-time view.</li>
</ul>
<h2 id="strace">29. strace</h2>
<ul>
<li>Compat: Linux; May be restricted by ptrace scope; Requires: strace. Trace system calls and signals.</li>
<li>Attach to a PID: <code>strace -ttT -p &lt;pid&gt; -f -e trace=network,file,fsync,clock,nanosleep</code></li>
<li>Run a program under strace: <code>strace -o strace.log -s 200 -vv -f -ttT your_cmd --arg</code></li>
<li>Syscall time summary: <code>strace -c -p &lt;pid&gt;</code></li>
<li>Filter a path: <code>strace -ttT -e trace=file -P /etc/resolv.conf -p &lt;pid&gt;</code></li>
<li>Notes: <code>-f</code> follows forks; <code>-ttT</code> adds timestamps and syscall durations; <code>-s</code> increases string size.</li>
<li>trace system calls and signals</li>
</ul>
<h2 id="slabtop">30. slabtop</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
<li><code>slabtop</code>: display kernel slab cache information in real time</li>
<li>Sort by size: <code>slabtop -s c</code>; one-shot: <code>slabtop -o</code></li>
</ul>
<h2 id="uptime">31. uptime</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
<li>information about how long the system has been up, and load averages</li>
</ul>
<h2 id="htop">32. htop</h2>
<ul>
<li>Compat: Linux; Requires: htop package.</li>
<li>like top, but prettier</li>
</ul>
<h2 id="ps">33. ps</h2>
<ul>
<li>Compat: Linux; Requires: procps. Cheat Card</li>
<li>Top CPU: <code>ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%cpu | head</code></li>
<li>Top RSS: <code>ps -eo pid,user,rss,cmd --sort=-rss | head</code></li>
<li>Tree view: <code>ps -ejH</code> (or <code>ps axjf</code>)</li>
<li>By command: <code>ps -C nginx -o pid,ppid,cmd,%mem,%cpu</code></li>
<li>Threads of a PID: <code>ps -Lp &lt;pid&gt; -o pid,tid,pcpu,comm</code></li>
<li><code>ps aux</code>: show all processes</li>
<li><code>ps axjf</code> - print process tree</li>
<li><code>ps a</code> - Lift the BSD-style “only yourself” restriction</li>
<li><code>ps -A</code> - select all processes</li>
<li><code>ps -d</code> - select all processes except session leaders</li>
<li><code>ps g</code> - select all processes including session leaders</li>
<li><code>ps Ta</code> - all process associated with this terminal</li>
<li><code>ps r</code> - restrict to running processes</li>
<li><code>ps --pid pidlist</code> - restrict to pidlist processes</li>
<li><code>ps -s|--sid</code> - select by session ID</li>
<li><code>ps t ttylist</code> - select by TTY list</li>
<li><code>ps U|-U</code> - select by effective user-id</li>
<li><code>ps s</code> - display signals</li>
<li><code>ps f</code> - ASCII art process hierarchy</li>
<li><code>ps ax -o rss,pid,user,pcpu,command --sort -%cpu</code>: sort by %cpu</li>
<li><code>ps ax -o rss,pid,user,pcpu,command --sort -rss</code>: sort by rss</li>
</ul>
<p>process states:</p>
<ul>
<li><code>D</code> - uninterruptible sleep (usually IO)</li>
<li><code>I</code> - Idle kernel thread</li>
<li><code>R</code> - running or runnable (on run queue)</li>
<li><code>S</code> - interruptible sleep (waiting for an event to complete)</li>
<li><code>T</code> - stopped by job control signal</li>
<li><code>t</code> - stopped by debugger during the tracing</li>
<li><code>W</code> - paging (not valid since the 2.6.xx kernel)</li>
<li><code>X</code> - dead (should never be seen)</li>
<li><code>Z</code> - defunct (“zombie”) process, terminated but not reaped by its parent</li>
</ul>
<p>see STANDARD FORMAT SPECIFIERS in <code>man ps</code></p>
<h1 id="cpu">CPU</h1>
<p>Cheat Card</p>
<ul>
<li>CPU saturation: <code>mpstat -P ALL 1</code> (sys/iowait/irq/soft)</li>
<li>Per-core view in top: <code>top -1</code>; over time per PID: <code>pidstat -u 1 -p &lt;pid&gt;</code></li>
<li>Interrupt spikes: <code>mpstat -I CPU 1</code></li>
</ul>
<h2 id="mpstat">34. mpstat</h2>
<ul>
<li>Compat: Linux; Requires: sysstat.</li>
</ul>
<p>The mpstat command writes to standard output activities for each available processor, processor 0 being the first one. Global average activities among all processors are also reported. Requires: sysstat.</p>
<p>Interpretation tips</p>
<ul>
<li>High <code>%iowait</code>: CPUs idle while waiting on disk IO (check iostat).</li>
<li>High <code>%irq/%soft</code>: heavy interrupts/softirqs (often network or storage).</li>
<li>High <code>%steal</code>: hypervisor stealing time (noisy neighbor in a VM).</li>
<li>Compare per-core: hotspots can be isolated to specific cores (affinity).</li>
<li><code>CPU</code>: Processor number. The keyword all indicates that statistics are calculated as averages among all processors.</li>
<li><code>%usr</code>: Show the percentage of CPU utilization that occurred while executing at the user level (application).</li>
<li><code>%nice</code>: Show the percentage of CPU utilization that occurred while executing at the user level with nice priority.</li>
<li><code>%sys</code>: Show the percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this does not include time spent servicing hardware and software interrupts.</li>
<li><code>%iowait</code>: Show the percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.</li>
<li><code>%irq</code>: Show the percentage of time spent by the CPU or CPUs to service hardware interrupts.</li>
<li><code>%soft</code>: Show the percentage of time spent by the CPU or CPUs to service software interrupts.</li>
<li><code>%steal</code>: Show the percentage of time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor.</li>
<li><code>%guest</code>: Show the percentage of time spent by the CPU or CPUs to run a virtual processor.</li>
<li><code>%gnice</code>: Show the percentage of time spent by the CPU or CPUs to run a niced guest.</li>
<li><code>mpstat -I</code>: report interrupt stats
<ul>
<li>of interrupts per CPU</li>
<li>of times a particular interrupt occurred</li>
</ul></li>
</ul>
<h3 id="memory">Memory</h3>
<p>Cheat Card</p>
<ul>
<li>Snapshot: <code>free -h --wide</code>; paging: <code>vmstat -a 1</code> (si/so)</li>
<li>Per-proc memory: <code>ps -eo pid,user,rss,cmd --sort=-rss | head</code>; deep dive: <code>pmap -x &lt;pid&gt;</code></li>
<li>OOM evidence: <code>dmesg -T | grep -i oom</code> or <code>journalctl -k -g OOM</code></li>
</ul>
<h2 id="free">35. free</h2>
<ul>
<li>Compat: Linux; Requires: procps.</li>
<li><code>used</code> - Used memory (calculated as total - free - buffers - cache)</li>
<li><code>free</code> - Unused memory (MemFree and SwapFree in /proc/meminfo)</li>
<li><code>shared</code> - Memory used (mostly) by tmpfs (Shmem in /proc/meminfo)</li>
<li><code>buffers</code> - Memory used by kernel buffers (Buffers in /proc/meminfo)</li>
<li><code>cache</code> - Memory used by the page cache and slabs (Cached and SReclaimable in /proc/meminfo)</li>
<li><code>buff/cache</code> - Sum of buffers and cache</li>
<li><code>available</code> - Estimation of how much memory is available for starting new applications, without swapping. Unlike the data provided by the cache or free fields, this field takes into account page cache and also that not all reclaimable memory slabs will be reclaimed due to items being in use (MemAvailable in /proc/meminfo, available on kernels 3.14, emulated on kernels 2.6.27+, otherwise the same as free)</li>
<li><code>free -l</code>: show low-high memory breakdown</li>
<li><code>free --wide</code>: show free memory stats Interpretation tips</li>
<li><code>available</code> approximates memory free for new apps without swapping; don’t confuse <code>free</code> with usable memory.</li>
<li>High <code>buff/cache</code> is normal; it’s the page cache and reclaimable slabs. Examples</li>
<li>Human-readable snapshot: <code>free -h --wide</code></li>
<li>Example output: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           31Gi        2.1Gi       22Gi        312Mi       7.2Gi        28Gi</span><br><span class="line">Swap:           8Gi           0B        8Gi</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sar">36. sar</h2>
<ul>
<li><p>Compat: Linux; Requires: sysstat; history needs <code>sadc</code> enabled. Cheat Card</p></li>
<li><p>CPU load/queue: <code>sar -q 1 5</code>; memory: <code>sar -r 1 5</code></p></li>
<li><p>IO bw/ops: <code>sar -b 1 5</code>; per-device: <code>sar -d 1 5</code> (watch <code>await</code>, <code>%util</code>)</p></li>
<li><p>Network: <code>sar -n DEV 1 5</code>; TCP: <code>sar -n TCP,ETCP 1 5</code></p></li>
<li><p>Paging: <code>sar -B 1 5</code> (<code>pgsteal</code>, <code>pgscan</code>, <code>majflt/s</code>) Requires: sysstat (includes pidstat). Field reference (click to expand)</p></li>
<li><p><code>sar -B</code>: report paging stats</p>
<ul>
<li><code>gpgin/s</code> - Total number of kilobytes the system paged in from disk per second.</li>
<li><code>pgpgout/s</code> - Total number of kilobytes the system paged out to disk per second.</li>
</ul></li>
<li><p><code>fault/s</code> - Number of page faults (major + minor) made by the system per second. This is not a count of page faults that generate I/O, because some page faults can be resolved without I/O.</p>
<ul>
<li><code>majflt/s</code> - Number of major faults the system has made per second, those which have required loading a memory page from disk.</li>
<li><code>pgfree/s</code> - Number of pages placed on the free list by the system per second.</li>
<li><code>pgscank/s</code> - Number of pages scanned by the kswapd daemon per second.</li>
<li><code>pgscand/s</code> - Number of pages scanned directly per second.</li>
<li><code>pgsteal/s</code> - Number of pages the system has reclaimed from cache (pagecache and swapcache) per second to satisfy its memory demands.</li>
<li><code>%vmeff</code> - Calculated as pgsteal / pgscan, this is a metric of the efficiency of page reclaim. If it is near 100% then almost every page coming off the tail of the inactive list is being reaped. If it gets too low (e.g. less than 30%) then the virtual memory is having some difficulty. This field is displayed as zero if no pages have been scanned during the interval of time.</li>
</ul></li>
<li><p><code>sar -b</code>: Report I/O and transfer rate statistics.</p>
<ul>
<li><code>tps</code> - Total number of transfers per second that were issued to physical devices. A transfer is an I/O request to a physical device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size.</li>
<li><code>rtps</code> - Total number of read requests per second issued to physical devices.</li>
<li><code>wtps</code> - Total number of write requests per second issued to physical devices.</li>
<li><code>bread/s</code> - Total amount of data read from the devices in blocks per second. Blocks are equivalent to sectors and therefore have a size of 512 bytes.</li>
<li><code>bwrtn/s</code> - Total amount of data written to devices in blocks per second.</li>
</ul></li>
<li><p><code>sar -d</code>: report activity for each block device</p></li>
<li><p><code>tps</code> - Total number of transfers per second that were issued to physical devices. A transfer is an I/O request to a physical device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size.</p>
<ul>
<li><code>rkB/s</code> - Number of kilobytes read from the device per second.</li>
<li><code>wkB/s</code> - Number of kilobytes written to the device per second.</li>
<li><code>areq-sz</code> - The average size (in kilobytes) of the I/O requests that were issued to the device. Note: In previous versions, this field was known as avgrq-sz and was expressed in sectors.</li>
<li><code>aqu-sz</code> - The average queue length of the requests that were issued to the device. Note: In previous versions, this field was known as avgqu-sz.</li>
<li><code>await</code> - The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.</li>
<li><code>svctm</code> - The average service time (in milliseconds) for I/O requests that were issued to the device. Warning! Do not trust this field any more. This field will be removed in a future sysstat version.</li>
<li><code>%util</code> - Percentage of elapsed time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100% for devices serving requests serially. But for devices serving requests in parallel, such as RAID arrays and modern SSDs, this number does not reflect their performance limits.</li>
</ul></li>
<li><p><code>sar -F</code>: display stats. for currently mounted FSs:</p>
<ul>
<li><code>MBfsfree</code> - Total amount of free space in megabytes (including space available only to privileged user).</li>
<li><code>MBfsused</code> - Total amount of space used in megabytes.</li>
<li><code>%fsused</code> - Percentage of filesystem space used, as seen by a privileged user.</li>
<li><code>%ufsused</code> - Percentage of filesystem space used, as seen by an unprivileged user.</li>
<li><code>Ifree</code> - Total number of free file nodes in filesystem.</li>
<li><code>Iused</code> - Total number of file nodes used in filesystem.</li>
<li><code>%Iused</code> - Percentage of file nodes used in filesystem.</li>
</ul></li>
<li><p><code>sar -m</code>: power management statistics:</p>
<ul>
<li><code>MHz</code> - Instantaneous CPU clock frequency in MHz. With the FAN keyword, statistics about fans speed are reported. The following values are displayed:</li>
<li><code>rpm</code> - Fan speed expressed in revolutions per minute.</li>
<li><code>drpm</code> - This field is calculated as the difference between current fan speed (rpm) and its low limit (fan_min).</li>
<li><code>DEVICE</code> - Sensor device name. With the FREQ keyword, statistics about CPU clock frequency are reported. The following value is displayed:</li>
<li><code>wghMHz</code> - Weighted average CPU clock frequency in MHz. Note that the cpufreq-stats driver must be compiled in the kernel for this option to work.</li>
</ul>
<p>With the IN keyword, statistics about voltage inputs are reported. The following values are displayed:</p>
<ul>
<li><code>inV</code> - Voltage input expressed in Volts.</li>
<li><code>%in</code> - Relative input value. A value of 100% means that voltage input has reached its high limit (in_max) whereas a value of 0% means that it has reached its low limit (in_min).</li>
<li><code>DEVICE</code> - Sensor device name.</li>
</ul>
<p>With the USB keyword, the sar command takes a snapshot of all the USB devices currently plugged into the system. At the end of the report, sar will display a summary of all those USB devices. The following values are displayed:</p>
<ul>
<li><code>BUS</code> - Root hub number of the USB device.</li>
<li><code>idvendor</code> - Vendor ID number (assigned by USB organization).</li>
<li><code>idprod</code> - Product ID number (assigned by Manufacturer).</li>
<li><code>maxpower</code> - Maximum power consumption of the device (expressed in mA).</li>
<li><code>manufact</code> - Manufacturer name.</li>
<li><code>product</code> - Product name.</li>
</ul></li>
<li><p><code>sar -n DEV</code>:</p>
<ul>
<li><code>IFACE</code> - Name of the network interface for which statistics are reported.</li>
<li><code>rxpck/s</code> - Total number of packets received per second.</li>
<li><code>txpck/s</code> - Total number of packets transmitted per second.</li>
<li><code>rxkB/s</code> - Total number of kilobytes received per second.</li>
<li><code>txkB/s</code> - Total number of kilobytes transmitted per second.</li>
<li><code>rxcmp/s</code> - Number of compressed packets received per second (for cslip etc.).</li>
<li><code>txcmp/s</code> - Number of compressed packets transmitted per second.</li>
<li><code>rxmcst/s</code> - Number of multicast packets received per second.</li>
<li><code>%ifutil</code> - Utilization percentage of the network interface. For half-duplex interfaces, utilization is calculated using the sum of rxkB/s and txkB/s as a percentage of the interface speed. For full-duplex, this is the greater of rxkB/S or txkB/s.</li>
</ul></li>
<li><p><code>sar -n EDEV</code>:</p>
<ul>
<li><code>IFACE</code> - Name of the network interface for which statistics are reported.</li>
<li><code>rxerr/s</code> - Total number of bad packets received per second.</li>
<li><code>txerr/s</code> - Total number of errors that happened per second while transmitting packets.</li>
<li><code>coll/s</code> - Number of collisions that happened per second while transmitting packets.</li>
<li><code>rxdrop/s</code> - Number of received packets dropped per second because of a lack of space in linux buffers.</li>
<li><code>txdrop/s</code> - Number of transmitted packets dropped per second because of a lack of space in linux buffers.</li>
<li><code>txcarr/s</code> - Number of carrier-errors that happened per second while transmitting packets.</li>
<li><code>rxfram/s</code> - Number of frame alignment errors that happened per second on received packets.</li>
<li><code>rxfifo/s</code> - Number of FIFO overrun errors that happened per second on received packets.</li>
<li><code>txfifo/s</code> - Number of FIFO overrun errors that happened per second on transmitted packets.</li>
</ul></li>
<li><p><code>sar -n ICMP</code>:</p>
<ul>
<li><code>imsg/s</code> - The total number of ICMP messages which the entity received per second [icmpInMsgs]. Note that this counter includes all those counted by ierr/s.</li>
<li><code>omsg/s</code> - The total number of ICMP messages which this entity attempted to send per second [icmpOutMsgs]. Note that this counter includes all those counted by oerr/s.</li>
<li><code>iech/s</code> - The number of ICMP Echo (request) messages received per second [icmpInEchos].</li>
<li><code>iechr/s</code> - The number of ICMP Echo Reply messages received per second [icmpInEchoReps].</li>
<li><code>oech/s</code> - The number of ICMP Echo (request) messages sent per second [icmpOutEchos].</li>
<li><code>oechr/s</code> - The number of ICMP Echo Reply messages sent per second [icmpOutEchoReps].</li>
<li><code>itm/s</code> - The number of ICMP Timestamp (request) messages received per second [icmpInTimestamps].</li>
<li><code>itmr/s</code> - The number of ICMP Timestamp Reply messages received per second [icmpInTimestampReps].</li>
<li><code>otm/s</code> - The number of ICMP Timestamp (request) messages sent per second [icmpOutTimestamps].</li>
<li><code>otmr/s</code> - The number of ICMP Timestamp Reply messages sent per second [icmpOutTimestampReps].</li>
<li><code>iadrmk/s</code> - The number of ICMP Address Mask Request messages received per second [icmpInAddrMasks].</li>
<li><code>oadrmk/s</code> - The number of ICMP Address Mask Request messages sent per second [icmpOutAddrMasks].</li>
<li><code>oadrmkr/s</code> - The number of ICMP Address Mask Reply messages sent per second [icmpOutAddrMaskReps].</li>
</ul></li>
<li><p><code>sar -n EICMP</code>: Extended ICMP stats (errors, dest unreachable, time exceeded). Focus on spikes in <code>ierr/s</code> and <code>oerr/s</code>, and patterns in unreachable/time- exceeded when debugging path issues.</p></li>
<li><p><code>sar -n EIP</code>: Extended IPv4 stats (header errors, addr errors, discards, no routes, reassembly, fragment fails). Use to spot header errors and routing/ no-route conditions.</p></li>
<li><p><code>sar -n IP6</code>: IPv6 per-protocol counters (receive/deliver/forward, multicast, fragmentation). Check for anomalies similar to IPv4.</p></li>
<li><p><code>sar -n EIP6</code>: Extended IPv6 errors and routing stats (header/addr errors, discards, no routes, reassembly/frag). Useful for IPv6-specific troubleshooting.</p></li>
<li><p><code>sar -n SOCK</code>:</p>
<ul>
<li><code>totsck</code> - Total number of sockets used by the system.</li>
<li><code>tcpsck</code> - TCP sockets in use; <code>tcp-tw</code> - TIME_WAIT sockets.</li>
</ul></li>
<li><p><code>sar -n SOFT</code>:</p>
<ul>
<li><code>total/s</code> - The total number of network frames processed per second.</li>
<li><code>dropd/s</code> - The total number of network frames dropped per second because there was no room on the processing queue.</li>
<li><code>squeezd/s</code> - The number of times the softirq handler function terminated per second because its budget was consumed or the time limit was reached, but more work could have been done.</li>
<li><code>rx_rps/s</code> - The number of times the CPU has been woken up per second to process packets via an inter-processor interrupt.</li>
<li><code>flw_lim/s</code> - The number of times the flow limit has been reached per second. Flow limiting is an optional RPS feature that can be used to limit the number of packets queued to the backlog for each flow to a certain amount. This can help ensure that smaller flows are processed even though much larger flows are pushing packets in.</li>
</ul></li>
<li><p><code>sar -n TCP</code>:</p>
<ul>
<li><code>active/s</code> - The number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state per second [tcpActiveOpens].</li>
<li><code>passive/s</code> - The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state per second [tcpPassiveOpens].</li>
<li><code>iseg/s</code> - The total number of segments received per second, including those received in error [tcpInSegs]. This count includes segments received on currently established connections.</li>
<li><code>oseg/s</code> - The total number of segments sent per second, including those on current connections but excluding those containing only retransmitted octets [tcpOutSegs].</li>
</ul></li>
<li><p><code>sar -n ETCP</code>:</p>
<ul>
<li><code>atmptf/s</code> - The number of times per second TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times per second TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state [tcpAttemptFails].</li>
<li><code>estres/s</code> - The number of times per second TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state [tcpEstabResets].</li>
<li><code>retrans/s</code> - The total number of segments retransmitted per second - that is, the number of TCP segments transmitted containing one or more previously transmitted octets [tcpRetransSegs].</li>
<li><code>isegerr/s</code> - The total number of segments received in error (e.g., bad TCP checksums) per second [tcpInErrs].</li>
<li><code>orsts/s</code> - The number of TCP segments sent per second containing the RST flag [tcpOutRsts].</li>
</ul></li>
<li><p><code>sar -n UDP</code>:</p>
<ul>
<li><code>idgm/s</code> - The total number of UDP datagrams delivered per second to UDP users [udpInDatagrams].</li>
<li><code>odgm/s</code> - The total number of UDP datagrams sent per second from this entity [udpOutDatagrams].</li>
<li><code>noport/s</code> - The total number of received UDP datagrams per second for which there was no application at the destination port [udpNoPorts].</li>
<li><code>idgmerr/s</code> - The number of received UDP datagrams per second that could not be delivered for reasons other than the lack of an application at the destination port [udpInErrors].</li>
</ul></li>
<li><p><code>sar -n UDP6</code>:</p>
<ul>
<li><code>idgm6/s</code> - The total number of UDP datagrams delivered per second to UDP users [udpInDatagrams].</li>
<li><code>odgm6/s</code> - The total number of UDP datagrams sent per second from this entity [udpOutDatagrams].</li>
<li><code>noport6/s</code> - The total number of received UDP datagrams per second for which there was no application at the destination port [udpNoPorts].</li>
<li><code>idgmer6/s</code> - The number of received UDP datagrams per second that could not be delivered for reasons other than the lack of an application at the destination port [udpInErrors].</li>
</ul></li>
<li><p><code>sar -q</code>:</p>
<ul>
<li><code>runq-sz</code> - Run queue length (number of tasks waiting for run time).</li>
<li><code>plist-sz</code> - Number of tasks in the task list.</li>
<li><code>ldavg-1</code> - System load average for the last minute. The load average is calculated as the average number of runnable or running tasks (R state), and the number of tasks in uninterruptible sleep (D state) over the specified interval.</li>
<li><code>ldavg-5</code> - System load average for the past 5 minutes.</li>
<li><code>ldavg-15</code> - System load average for the past 15 minutes.</li>
<li><code>blocked</code> - Number of tasks currently blocked, waiting for I/O to complete.</li>
</ul></li>
<li><p><code>sar -r</code>:</p>
<ul>
<li><code>kbmemfree</code> - Amount of free memory available in kilobytes.</li>
<li><code>kbavail</code> - Estimate of how much memory in kilobytes is available for starting new applications, without swapping. The estimate takes into account that the system needs some page cache to function well, and that not all reclaimable memory slabs will be reclaimable, due to items being in use. The impact of those factors will vary from system to system.</li>
</ul></li>
<li><p><code>kbmemused</code> - Amount of used memory in kilobytes (calculated as total installed memory - kbmemfree - kbbuffers - kbcached - kbslab).</p>
<ul>
<li><code>%memused</code> - Percentage of used memory.</li>
<li><code>kbbuffers</code> - Amount of memory used as buffers by the kernel in kilobytes.</li>
<li><code>kbcached</code> - Amount of memory used to cache data by the kernel in kilobytes.</li>
</ul></li>
<li><p><code>kbcommit</code> - Amount of memory in kilobytes needed for current workload. This is an estimate of how much RAM/swap is needed to guarantee that there never is out of memory.</p></li>
<li><p><code>%commit</code> - Percentage of memory needed for current workload in relation to the total amount of memory (RAM+swap). This number may be greater than 100% because the kernel usually overcommits memory.</p></li>
<li><p><code>kbactive</code> - Amount of active memory in kilobytes (memory that has been used more recently and usually not reclaimed unless absolutely necessary).</p></li>
<li><p><code>kbinact</code> - Amount of inactive memory in kilobytes (memory which has been less recently used. It is more eligible to be reclaimed for other purposes).</p>
<ul>
<li><code>kbdirty</code> - Amount of memory in kilobytes waiting to get written back to the disk.</li>
<li><code>kbanonpg</code> - Amount of non-file backed pages in kilobytes mapped into userspace page tables.</li>
<li><code>kbslab</code> - Amount of memory in kilobytes used by the kernel to cache data structures for its own use.</li>
<li><code>kbkstack</code> - Amount of memory in kilobytes used for kernel stack space.</li>
<li><code>kbpgtbl</code> - Amount of memory in kilobytes dedicated to the lowest level of page tables.</li>
<li><code>kbvmused</code> - Amount of memory in kilobytes of used virtual address space.</li>
</ul></li>
<li><p><code>sar -S</code>:</p>
<ul>
<li><code>kbswpfree</code> - Amount of free swap space in kilobytes.</li>
<li><code>kbswpused</code> - Amount of used swap space in kilobytes.</li>
<li><code>%swpused</code> - Percentage of used swap space.</li>
</ul></li>
<li><p><code>kbswpcad</code> - Amount of cached swap memory in kilobytes. This is memory that once was swapped out, is swapped back in but still also is in the swap area (if memory is needed it doesn’t need to be swapped out again because it is already in the swap area. This saves I/O).</p>
<ul>
<li><code>%swpcad</code> - Percentage of cached swap memory in relation to the amount of used swap space.</li>
</ul></li>
<li><p><code>sar -u</code>:</p></li>
<li><p><code>%user</code> - Percentage of CPU utilization that occurred while executing at the user level (application). Note that this field includes time spent running virtual processors.</p></li>
<li><p><code>%usr</code> - Percentage of CPU utilization that occurred while executing at the user level (application). Note that this field does NOT include time spent running virtual processors.</p></li>
<li><p><code>%nice</code> - Percentage of CPU utilization that occurred while executing at the user level with nice priority.</p></li>
<li><p><code>%system</code> - Percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this field includes time spent servicing hardware and software interrupts.</p></li>
<li><p><code>%sys</code> - Percentage of CPU utilization that occurred while executing at the system level (kernel). Note that this field does NOT include time spent servicing hardware or software interrupts.</p></li>
<li><p><code>%iowait</code> - Percentage of time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request.</p></li>
<li><p><code>%steal</code> - Percentage of time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor.</p>
<ul>
<li><code>%irq</code> - Percentage of time spent by the CPU or CPUs to service hardware interrupts.</li>
<li><code>%soft</code> - Percentage of time spent by the CPU or CPUs to service software interrupts.</li>
<li><code>%guest</code> - Percentage of time spent by the CPU or CPUs to run a virtual processor.</li>
<li><code>%gnice</code> - Percentage of time spent by the CPU or CPUs to run a niced guest.</li>
</ul></li>
<li><p><code>%idle</code> - Percentage of time that the CPU or CPUs were idle and the system did not have an outstanding disk I/O request.</p></li>
<li><p><code>sar -v</code>:</p>
<ul>
<li><code>dentunusd</code> - Number of unused cache entries in the directory cache.</li>
<li><code>file-nr</code> - Number of file handles used by the system.</li>
<li><code>inode-nr</code> - Number of inode handlers used by the system.</li>
<li><code>pty-nr</code> - Number of pseudo-terminals used by the system.</li>
</ul></li>
<li><p><code>sar -W</code>: Report swapping statistics. The following values are displayed:</p>
<ul>
<li><code>pswpin/s</code> - Total number of swap pages the system brought in per second.</li>
<li><code>pswpout/s</code> - Total number of swap pages the system brought out per second.</li>
</ul></li>
<li><p><code>sar -w</code>: Report task creation and system switching activity.</p>
<ul>
<li><code>proc/s</code> - Tasks created per second; <code>cswch/s</code> - context switches per second.</li>
</ul></li>
<li><p><code>sar -y</code>: Report TTY devices activity. The following values are displayed:</p></li>
<li><p><code>rcvin/s</code> - Number of receive interrupts per second for current serial line. Serial line number is given in the TTY column.</p>
<ul>
<li><code>xmtin/s</code> - Number of transmit interrupts per second for current serial line.</li>
<li><code>framerr/s</code> - Number of frame errors per second for current serial line.</li>
<li><code>prtyerr/s</code> - Number of parity errors per second for current serial line.</li>
<li><code>brk/s</code> - Number of breaks per second for current serial line.</li>
<li><code>ovrun/s</code> - Number of overrun errors per second for current serial line.</li>
</ul></li>
</ul>
<h2 id="pidstat">45. pidstat</h2>
<ul>
<li>Compat: Linux; Requires: sysstat.</li>
<li>monitor individual tasks currently being managed Requires: sysstat.</li>
</ul>
<p>Cheat Card - CPU by PID: <code>pidstat -u 1 -p &lt;pid&gt;</code> (watch <code>%usr/%system/%wait</code>) - IO by PID: <code>pidstat -d 1 -p &lt;pid&gt;</code> (check <code>kB_rd/s</code>, <code>kB_wr/s</code>, <code>iodelay</code>) - Memory faults: <code>pidstat -r 1 -p &lt;pid&gt;</code> (watch <code>majflt/s</code>) - Threads: <code>pidstat -t -u 1 -p &lt;pid&gt;</code> - <code>pidstat -d</code>: - Key fields: <code>kB_rd/s</code>, <code>kB_wr/s</code>, <code>iodelay</code> (IO wait), <code>kB_ccwr/s</code> (cancelled writes). - <code>pidstat -R</code>: Report realtime priority and scheduling policy information. The following values may be displayed: - Key fields: <code>prio</code>, <code>policy</code>. - <code>pidstat -r</code>: Report page faults and memory utilization. When reporting statistics for individual tasks, the following values may be displayed: - Key fields: <code>majflt/s</code> (major faults), <code>RSS</code>, <code>%MEM</code>. When reporting global statistics for tasks and all their children, the following values may be displayed: - With children: <code>majflt-nr</code>, <code>minflt-nr</code> summarize faults. - <code>pidstat -s</code>: Report stack utilization. The following values may be displayed: - Key fields: <code>StkRef</code> (used), <code>StkSize</code> (reserved). - <code>pidstat -t</code>: Also display statistics for threads associated with selected tasks. List process and threads - <code>pidstat -u</code>: Report CPU utilization. When reporting statistics for individual tasks, the following values may be displayed: - Key fields: <code>%usr</code>, <code>%system</code>, <code>%wait</code>, <code>%CPU</code>, <code>CPU</code>. When reporting global statistics for tasks and all their children, the following values may be displayed: - With children: <code>usr-ms</code>, <code>system-ms</code>, <code>guest-ms</code> summarize CPU time.</p>
<h2 id="lsof">46. lsof</h2>
<ul>
<li>Compat: Linux; May require root to see all descriptors; Requires: lsof. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># List all open files</span><br><span class="line">lsof</span><br><span class="line"></span><br><span class="line"># Processes using a file? (fuser equivalent)</span><br><span class="line">lsof /path/to/file</span><br><span class="line"></span><br><span class="line"># Open files within a directory</span><br><span class="line">lsof +D /path</span><br><span class="line"></span><br><span class="line"># Files by user</span><br><span class="line">lsof -u name</span><br><span class="line">lsof -u name1,name2</span><br><span class="line">lsof -u name1 -u name2</span><br><span class="line"></span><br><span class="line"># By program name</span><br><span class="line">lsof -c apache</span><br><span class="line"></span><br><span class="line"># AND&#x27;ing selection conditions</span><br><span class="line">lsof -u www-data -c apache</span><br><span class="line"></span><br><span class="line"># By pid</span><br><span class="line">lsof -p 1</span><br><span class="line"></span><br><span class="line"># Except certain pids</span><br><span class="line">lsof -p ^1</span><br><span class="line"></span><br><span class="line"># TCP and UDP connections</span><br><span class="line">lsof -i</span><br><span class="line">lsof -i tcp # TCP connections</span><br><span class="line">lsof -i udp # UDP connections</span><br><span class="line"></span><br><span class="line"># By port</span><br><span class="line">lsof -i :25</span><br><span class="line">lsof -i :smtp</span><br><span class="line">lsof -i udp:53</span><br><span class="line">lsof -i tcp:80</span><br><span class="line"></span><br><span class="line"># All network activity by a user</span><br><span class="line">lsof -a -u name1 -i</span><br><span class="line"></span><br><span class="line">lsof -N # NFS use</span><br><span class="line">lsof -U # UNIX domain socket use</span><br><span class="line"></span><br><span class="line"># List PIDs</span><br><span class="line">lsof -t -i</span><br><span class="line"># Danger: broad kill; preview and scope carefully before use</span><br><span class="line">kill -9 $(lsof -t -i) # Kill all programs w/network activity</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Requires: lsof.</p>
<h2 id="pmap">51. pmap</h2>
<ul>
<li>Compat: Linux; Requires: procps; <code>-X</code> needs procps-ng.</li>
<li><code>pmap 29740 -X</code>: show Address,Perm,Offset,Device,Inode,Size,Rss,Pss,Referenced,Anonymous,LazyFree, ShmemPmdMapped,Shared_Hugetlb,Private_Hugetlb,Swap,SwapPss,Locked,THPeligible, Mapping Requires: procps. Common recipes</li>
<li>Largest mappings first: <code>pmap -x &lt;pid&gt; | sort -nrk 3 | head</code> (by RSS KB)</li>
<li>Totals summary: <code>pmap &lt;pid&gt;</code> (last line shows total)</li>
</ul>
<h2 id="blktrace">52. blktrace</h2>
<ul>
<li>Compat: Linux; Root required; Needs kernel block trace support; Requires: blktrace.</li>
<li>blktrace is a block layer IO tracing mechanism which provides detailed information about request queue operations up to user space. There are three major components: a kernel component, a utility to record the i/o trace information for the kernel to user space, and utilities to analyse and view the trace information. <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Trace block I/O on /dev/sda and parse</span></span><br><span class="line">sudo blktrace -d /dev/sda -o - | blkparse -i -</span><br></pre></td></tr></table></figure> Requires: blktrace. outputs: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU0 (8,0):</span><br><span class="line"> Reads Queued:         385,     1540KiB     Writes Queued:           0,        0KiB</span><br><span class="line"> Read Dispatches:       75,     1544KiB     Write Dispatches:        4,       16KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:      681,    15168KiB     Writes Completed:       42,     1208KiB</span><br><span class="line"> Read Merges:          315,     1260KiB     Write Merges:            0,        0KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:            63             Timer unplugs:           0</span><br><span class="line">CPU1 (8,0):</span><br><span class="line"> Reads Queued:         406,     1624KiB     Writes Queued:          13,      996KiB</span><br><span class="line"> Read Dispatches:       71,     1620KiB     Write Dispatches:       10,      992KiB</span><br><span class="line"> Reads Requeued:         1         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:          336,     1344KiB     Write Merges:            2,      200KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:            68             Timer unplugs:           0</span><br><span class="line">CPU2 (8,0):</span><br><span class="line"> Reads Queued:        1531,     6152KiB     Writes Queued:          30,      120KiB</span><br><span class="line"> Read Dispatches:      257,     6152KiB     Write Dispatches:        3,      108KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:         1277,     5108KiB     Write Merges:           24,       96KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:           255             Timer unplugs:           0</span><br><span class="line">CPU3 (8,0):</span><br><span class="line"> Reads Queued:        1266,     5852KiB     Writes Queued:          23,       92KiB</span><br><span class="line"> Read Dispatches:      279,     5852KiB     Write Dispatches:       21,       92KiB</span><br><span class="line"> Reads Requeued:         0         Writes Requeued:         0</span><br><span class="line"> Reads Completed:        0,        0KiB     Writes Completed:        0,        0KiB</span><br><span class="line"> Read Merges:          987,     3948KiB     Write Merges:            2,        8KiB</span><br><span class="line"> Read depth:            84             Write depth:            21</span><br><span class="line"> IO unplugs:           279             Timer unplugs:           1</span><br><span class="line"></span><br><span class="line">Total (8,0):</span><br><span class="line"> Reads Queued:        3588,    15168KiB     Writes Queued:          66,     1208KiB</span><br><span class="line"> Read Dispatches:      682,    15168KiB     Write Dispatches:       38,     1208KiB</span><br><span class="line"> Reads Requeued:         1         Writes Requeued:         0</span><br><span class="line"> Reads Completed:      681,    15168KiB     Writes Completed:       42,     1208KiB</span><br><span class="line"> Read Merges:         2915,    11660KiB     Write Merges:           28,      304KiB</span><br><span class="line"> IO unplugs:           665             Timer unplugs:           1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="btrace">53. btrace</h2>
<ul>
<li>Compat: Linux; Wrapper script from blktrace; Root required.</li>
<li>The btrace script provides a quick and easy way to do live tracing of block devices. It calls blktrace on the specified devices and pipes the output through blkparse for formatting. See blktrace (8) for more in-depth information about how blktrace works.</li>
<li><code>btrace /dev/sda</code> Requires: blktrace.</li>
</ul>
<h2 id="tr">54. tr</h2>
<ul>
<li>Compat: Linux; Requires: coreutils. Translate, squeeze, and/or delete characters from standard input, writing to standard output.</li>
<li><code>tr '\n' ','</code>: convert new lines to commas</li>
<li>squeeze repeats: <code>tr -s ' ' &lt; file</code> (collapse runs of spaces)</li>
<li>delete chars: <code>tr -d '\r' &lt; file</code> (remove CR)</li>
<li>keep only printable: <code>tr -cd '[:print:]\n' &lt; file</code></li>
<li>case convert: <code>tr '[:upper:]' '[:lower:]' &lt; file</code></li>
</ul>
<h2 id="cut">55. cut</h2>
<ul>
<li>Compat: Linux; Requires: coreutils.</li>
<li>select CSV fields: <code>cut -d, -f1,3 file.csv</code></li>
<li>ranges: <code>cut -d: -f1-3 /etc/passwd</code></li>
<li>bytes/chars: <code>cut -b1-10 file</code>; <code>cut -c1-20 file</code></li>
<li>complement: <code>cut -d, -f1 --complement file.csv</code></li>
<li>with headers: pair with <code>head -1</code> to see column indexes</li>
</ul>
<h2 id="xargs">56. xargs</h2>
<ul>
<li>Compat: Linux; Requires: findutils; GNU <code>-r</code> may vary on BusyBox. Build and run argument lists; combine with <code>find</code> and null-terminated records for safety.</li>
<li>safe null delim: <code>find . -type f -name '*.log' -print0 | xargs -0 rm -f</code></li>
<li>limit args per call: <code>xargs -n 1 -I{} sh -c 'echo {}'</code></li>
<li>parallelism: <code>xargs -P 4 -n 1 cmd</code> (run 4 at a time)</li>
<li>interactive confirm: <code>xargs -p rm</code> (ask before each batch)</li>
<li>do nothing on empty input: <code>xargs -r cmd</code> (GNU)</li>
</ul>
<h1 id="logs-systemd">Logs &amp; Systemd</h1>
<p>Cheat Card</p>
<ul>
<li>Unit status: <code>systemctl status &lt;unit&gt;</code>; failed: <code>systemctl list-units --failed</code></li>
<li>Hot errors: <code>journalctl -xeu &lt;unit&gt;</code>; follow: <code>journalctl -fu &lt;unit&gt;</code></li>
<li>Boot scoping: <code>journalctl -b</code> and <code>-b -1</code>; size: <code>journalctl --disk-usage</code></li>
</ul>
<h2 id="systemd-basics">Systemd basics</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unit status and enablement</span></span><br><span class="line">systemctl status &lt;unit&gt;</span><br><span class="line">systemctl is-active &lt;unit&gt;</span><br><span class="line">systemctl is-enabled &lt;unit&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Failed units overview</span></span><br><span class="line">systemctl list-units --failed</span><br><span class="line">journalctl -xe  # recent critical logs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Restart and verify logs from this boot</span></span><br><span class="line">systemctl restart &lt;unit&gt;</span><br><span class="line">journalctl -u &lt;unit&gt; -b -n 50</span><br></pre></td></tr></table></figure>
<h2 id="journal-essentials">Journal essentials</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Recent errors <span class="keyword">for</span> a unit and live follow</span></span><br><span class="line">journalctl -xeu &lt;unit&gt;</span><br><span class="line">journalctl -fu &lt;unit&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Time window and priority</span></span><br><span class="line">journalctl -u &lt;unit&gt; --since &quot;1 hour ago&quot; --until now</span><br><span class="line">journalctl -p err..alert -b</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Previous boot</span></span><br><span class="line">journalctl -b -1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JSON output piped to jq (Requires: jq)</span></span><br><span class="line">journalctl -u &lt;unit&gt; -o json | jq -r &#x27;.MESSAGE&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="journal-management">Journal management</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Disk usage and vacuum</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line">journalctl --vacuum-size=1G</span><br><span class="line">journalctl --vacuum-time=7d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Make logs persistent (requires root; edit journald.conf)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/systemd/journald.conf: <span class="built_in">set</span> Storage=persistent</span></span><br><span class="line">systemctl restart systemd-journald</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Tip: tune RateLimitIntervalSec/RateLimitBurst to manage <span class="built_in">log</span> storms</span></span><br></pre></td></tr></table></figure>
<h2 id="resolved-dns">Resolved (DNS)</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Overall resolver status</span></span><br><span class="line">resolvectl status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Query using systemd-resolved</span></span><br><span class="line">resolvectl query example.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Flush caches</span></span><br><span class="line">resolvectl flush-caches</span><br></pre></td></tr></table></figure>
<h1 id="security-audit">Security &amp; Audit</h1>
<p>Cheat Card</p>
<ul>
<li>SELinux mode: <code>getenforce</code>; recent denials: <code>ausearch -m AVC -ts recent</code></li>
<li>AppArmor status: <code>aa-status</code>; set complain/enforce on a profile</li>
<li>Audit rule example: <code>auditctl -w /etc/ssh/sshd_config -p wa -k sshcfg</code> SELinux <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Current mode and temporary permissive (diagnostic; requires root)</span></span><br><span class="line">getenforce</span><br><span class="line">setenforce 0  # Caution: reduces enforcement</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Contexts and recent denials</span></span><br><span class="line">ls -Z</span><br><span class="line">ps -eZ | head</span><br><span class="line">ausearch -m AVC -ts recent</span><br><span class="line">journalctl -t setroubleshoot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Manage booleans (example: allow httpd network connect)</span></span><br><span class="line">getsebool -a | grep httpd</span><br><span class="line">setsebool -P httpd_can_network_connect on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Requires: selinux-utils/policycoreutils; setroubleshoot (optional)</span></span><br></pre></td></tr></table></figure> AppArmor <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Status and service</span></span><br><span class="line">aa-status</span><br><span class="line">systemctl status apparmor</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Toggle a profile mode</span></span><br><span class="line">aa-complain /path/to/bin</span><br><span class="line">aa-enforce /path/to/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Requires: apparmor-utils</span></span><br></pre></td></tr></table></figure> Auditd <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Service and rules</span></span><br><span class="line">systemctl status auditd</span><br><span class="line">auditctl -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Search recent denials / by PID</span></span><br><span class="line">ausearch -m avc -ts recent</span><br><span class="line">ausearch -p &lt;pid&gt; -ts recent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Watch a file <span class="keyword">for</span> writes/attr changes (key: sshcfg)</span></span><br><span class="line">auditctl -w /etc/ssh/sshd_config -p wa -k sshcfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Summary report</span></span><br><span class="line">aureport --summary -ts today</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Requires: auditd (auditd, auditctl, ausearch, aureport)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="containers-namespaces">Containers &amp; Namespaces</h1>
<p>Cheat Card</p>
<ul>
<li><p>Enter container namespace: <code>nsenter --target &lt;pid&gt; --mount --uts --ipc --net --pid -- bash</code></p></li>
<li><p>Docker triage: <code>docker ps</code>, <code>docker logs --tail=200 -f &lt;id&gt;</code>, <code>docker exec -it &lt;id&gt; sh</code></p></li>
<li><p>K8s triage: <code>kubectl get pods -A</code>, <code>kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</code>, <code>kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</code> nsenter (enter namespaces of a PID) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get target PID (e.g., container process)</span></span><br><span class="line">pidof &lt;proc&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enter multiple namespaces of a PID</span></span><br><span class="line">nsenter --target &lt;pid&gt; --mount --uts --ipc --net --pid -- bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Inspect and chroot-like into the process rootfs</span></span><br><span class="line">ls -l /proc/&lt;pid&gt;/root</span><br><span class="line">nsenter --target &lt;pid&gt; --mount -- chroot /proc/&lt;pid&gt;/root bash</span><br></pre></td></tr></table></figure> Docker (if present) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">List, <span class="built_in">exec</span>, inspect PID, and <span class="built_in">tail</span> logs</span></span><br><span class="line">docker ps --format &#x27;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125; &#123;&#123;.Status&#125;&#125;&#x27;</span><br><span class="line">docker exec -it &lt;id|name&gt; bash  # or sh</span><br><span class="line">docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; &lt;id&gt;</span><br><span class="line">docker logs --tail=200 -f &lt;id&gt;</span><br></pre></td></tr></table></figure> Kubernetes (if present) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pods and events</span></span><br><span class="line">kubectl get pods -A -o wide</span><br><span class="line">kubectl get events -A --sort-by=.lastTimestamp | tail</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Describe, logs, and <span class="built_in">exec</span></span></span><br><span class="line">kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --tail=200</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</span><br><span class="line">kubectl exec -it &lt;pod&gt; -n &lt;ns&gt; -- bash</span><br></pre></td></tr></table></figure> CRI/containerd (if present) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">List, inspect, and logs via crictl</span></span><br><span class="line">crictl ps -a</span><br><span class="line">crictl inspect &lt;id&gt;</span><br><span class="line">crictl logs &lt;id&gt;</span><br></pre></td></tr></table></figure> Notes</p></li>
<li><p>Without runtime CLIs, use <code>nsenter</code> by PID from <code>ps</code>/<code>systemctl</code>.</p></li>
<li><p>Requires: docker or podman for Docker-like commands; kubectl; crictl for containerd/CRI. # Incident Playbooks</p></li>
</ul>
<h2 id="high-cpu">High CPU</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Top CPU processes and hot threads</span></span><br><span class="line">ps -eo pid,ppid,user,%cpu,%mem,cmd --sort=-%cpu | head</span><br><span class="line">top -H</span><br><span class="line">ps -Lp &lt;pid&gt; -o pid,tid,pcpu,comm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Per-process CPU over <span class="keyword">time</span>; optional perf <span class="keyword">if</span> available</span></span><br><span class="line">pidstat -u 1 -p &lt;pid&gt;</span><br><span class="line">perf top  # if installed</span><br></pre></td></tr></table></figure>
<h2 id="high-io-wait-disk-latency">High IO wait / Disk latency</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Device saturation and per-process IO</span></span><br><span class="line">iostat -xz 1   # watch await, %util, r/s, w/s</span><br><span class="line">pidstat -d 1</span><br><span class="line">iotop -oPa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Device/FS inventory and kernel errors</span></span><br><span class="line">lsblk -o NAME,TYPE,SIZE,ROTA,MOUNTPOINT,MODEL</span><br><span class="line">dmesg -T | egrep -i &#x27;error|reset|blk|nvme&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Optional deep dive</span></span><br><span class="line">blktrace -d /dev/sdX -o - | blkparse -i -</span><br></pre></td></tr></table></figure>
<h2 id="memory-leak-oom">Memory leak / OOM</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Snapshot and top RSS processes</span></span><br><span class="line">free -h</span><br><span class="line">ps aux --sort=-rss | head</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Per-process mappings and over-time faults</span></span><br><span class="line">pmap -x &lt;pid&gt; | sort -nrk 3 | head</span><br><span class="line">pidstat -r 1 -p &lt;pid&gt;</span><br><span class="line">smem -r  # if installed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">OOM evidence</span></span><br><span class="line">dmesg -T | grep -i oom || journalctl -k -g OOM</span><br></pre></td></tr></table></figure>
<h2 id="packet-loss-high-latency">Packet loss / High latency</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Path and end-to-end latency</span></span><br><span class="line">ip route get &lt;dest&gt;</span><br><span class="line">mtr -ezbw &lt;dest&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Interface health and TCP details</span></span><br><span class="line">ip -s link show &lt;iface&gt;</span><br><span class="line">ethtool -S &lt;iface&gt;</span><br><span class="line">ss -i dst &lt;dest&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Targeted capture samples</span></span><br><span class="line">tcpdump -ni &lt;iface&gt; host &lt;dest&gt; and icmp</span><br><span class="line">tcpdump -ni &lt;iface&gt; tcp port 443 and &#x27;tcp[tcpflags] &amp; tcp-syn != 0&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="dns-failures">DNS failures</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Resolve via systemd-resolved (or dig <span class="keyword">if</span> available)</span></span><br><span class="line">resolvectl query example.com</span><br><span class="line">resolvectl status</span><br><span class="line">dig @8.8.8.8 example.com A +time=2 +tries=1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Reachability and captures</span></span><br><span class="line">ss -u &#x27;sport = :53 or dport = :53&#x27;</span><br><span class="line">tcpdump -ni &lt;iface&gt; port 53</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Config checks</span></span><br><span class="line">ls -l /etc/resolv.conf</span><br><span class="line">resolvectl flush-caches</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check firewall rules as appropriate</span></span><br></pre></td></tr></table></figure>
<h2 id="tls-handshake-issues">TLS handshake issues</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Inspect handshake/cert chain (TLS1.2 example)</span></span><br><span class="line">openssl s_client -connect host:443 -servername host -tls1_2 -showcerts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Check expiry/subject/issuer quickly</span></span><br><span class="line">echo | openssl s_client -connect host:443 -servername host 2&gt;/dev/null \</span><br><span class="line">  | openssl x509 -noout -dates -subject -issuer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">App behavior (SNI, ALPN, protocols)</span></span><br><span class="line">curl -v https://host/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If proxy/MTLS: verify CA path and client certs; check <span class="keyword">time</span> skew</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure>
<h2 id="disk-full-inode-exhaustion">Disk full / Inode exhaustion</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Space vs inodes</span></span><br><span class="line">df -h</span><br><span class="line">df -i</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find biggest <span class="built_in">dirs</span> on same filesystem</span></span><br><span class="line">du -xhd1 /path | sort -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deleted-but-open files</span></span><br><span class="line">lsof +L1</span><br><span class="line">journalctl --vacuum-size=1G  # cull journal size</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Many small files</span></span><br><span class="line">find /path -xdev -type f | wc -l</span><br></pre></td></tr></table></figure>
<h2 id="syscall-slowness">Syscall slowness</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Trace syscalls and timings</span></span><br><span class="line">strace -ttT -p &lt;pid&gt; -f -e trace=network,file,fsync,clock,nanosleep</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Optional CPU hotspot profiling</span></span><br><span class="line">perf record -g -p &lt;pid&gt;; perf report</span><br></pre></td></tr></table></figure>
<h2 id="container-restart-loops">Container restart loops</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker restart loops</span></span><br><span class="line">docker ps --filter &#x27;status=restarting&#x27;</span><br><span class="line">docker logs &lt;id&gt; --tail=200</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kubernetes restart loops</span></span><br><span class="line">kubectl get pods -A</span><br><span class="line">kubectl describe pod &lt;pod&gt; -n &lt;ns&gt;</span><br><span class="line">kubectl logs &lt;pod&gt; -n &lt;ns&gt; --previous</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Node/agent issues</span></span><br><span class="line">journalctl -u kubelet</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>xv6-vscode调试</title>
    <url>/2025/12/10/xv6%E5%AD%A6%E4%B9%A0/xv6-vscode%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="gdbinit">.gdbinit</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set $lastcs = -1</span><br><span class="line"></span><br><span class="line">define hook-stop</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">There doesn<span class="string">&#x27;t seem to be a good way to detect if we&#x27;</span>re <span class="keyword">in</span> 16- or</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">32-bit mode, but <span class="keyword">in</span> 32-bit mode we always run with CS == 8 <span class="keyword">in</span> the</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">kernel and CS == 35 <span class="keyword">in</span> user space</span></span><br><span class="line">  if $cs == 8 || $cs == 35</span><br><span class="line">    if $lastcs != 8 &amp;&amp; $lastcs != 35</span><br><span class="line">      set architecture i386</span><br><span class="line">    end</span><br><span class="line">    x/i $pc</span><br><span class="line">  else</span><br><span class="line">    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35</span><br><span class="line">      set architecture i8086</span><br><span class="line">    end</span><br><span class="line">    # Translate the segment:offset into a physical address</span><br><span class="line">    printf &quot;[%4x:%4x] &quot;, $cs, $eip</span><br><span class="line">    x/i $cs*16+$eip</span><br><span class="line">  end</span><br><span class="line">  set $lastcs = $cs</span><br><span class="line">end</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注释掉</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> + target remote localhost:25000\n</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">target remote localhost:25000</span></span><br><span class="line"></span><br><span class="line">echo + symbol-file kernel\n</span><br><span class="line">symbol-file kernel</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="launch.json">launch.json</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug xv6 x86&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:25000&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set architecture i386:x86-64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set disassemble-next-line auto&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-print for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;traceResponse&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="tasks.json">tasks.json</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xv6build&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make qemu-nox-gdb&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;beginsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.* Now run &#x27;gdb&#x27;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;endsPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>环境搭建</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>xv6-增加系统调用</title>
    <url>/2025/12/09/xv6%E5%AD%A6%E4%B9%A0/%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="panic">panic</h1>
<p>以下代码报错 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lapicid 2: panic: mycpu called with interrupts enabled</span><br><span class="line">80103937 8010394f 80104a7d 80105b51 8010589e 0 0 0 0 0</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line">	<span class="title function_">getcpuid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> cpuid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原因：<code>mycpu()</code>要求在关闭中断时调用（函数开头检查 IF），而某处（这里是 scheduler 开头）在中断允许的情况下调用了它，导致 panic。</li>
<li>修复：在调用 <code>mycpu()</code>前禁用中断<code>（pushcli）</code>，调用后恢复<code>（popcli）</code>。把 scheduler 开头修改如下。</li>
<li>说明：这样能保证在读取/比较本 CPU 的 <code>LAPIC id</code> 时不会被中断重入。若还有其它在未禁中断情况下直接调用 <code>mycpu()</code> 的地方，也请同样处理或确保调用者已禁中断。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">getcpuid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  pushcli();</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  popcli();</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>三种大气质量和一个公式的计算方法</title>
    <url>/2019/10/04/%E4%B8%89%E7%A7%8D%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/%E4%B8%89%E7%A7%8D%E5%A4%A7%E6%B0%94%E5%85%89%E5%AD%A6%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="三种大气质量和一个公式的计算方法">三种大气质量和一个公式的计算方法</h1>
<h2 id="简介">简介</h2>
<p>​ 整理的文献为 <em>Revised optical air mass tables and approximation formula</em> 。</p>
<p>​ 文章一开始介绍了一个由 Karsten 在1965年发表的并且广泛被世界所采用的关于大气质量的近似公式，并且讨论了一些由于各个学科对于不同的物理量符号和术语的不同使得读者经常由此而困惑。</p>
<p>​ 其后介绍了一个计算大气光学质量的近似公式，然后说明了在公式中存在的一种不定情况，之后又对这个近似公式用非线性最小二乘法进行修正得到了一组新的系数。后面又根据索引文献[1]文中也多次提到这篇文献，很多都是从这篇文献里面来的。</p>
<p>​ 还有从一篇《基于遥感与地面监测数据的城市气溶胶定量反演研究》，作者是王耀庭，南京师范大学博士论文。</p>
<h2 id="一个通用的计算公式">一个通用的计算公式</h2>
<p><span class="math display">$$
m(\gamma)=\frac{m_{abs}(\gamma)}{m_{abs}(90^{\circ})}
$$</span></p>
<p><span class="math display">$$
m_{abs}(\gamma)=\rho_{0}\int^{\infty}_{0} \frac{\rho}{\rho_{0}}([1-[1+2\delta_{0}(1-\frac{\rho}{\rho_{0}})]]\times
    [\frac{\cos \gamma}{1+\frac{h}{R}}]^{2})^{-\frac{1}{2}}dh
$$</span> <span class="math inline"><em>h</em></span>是相对于海平面的平均高度；</p>
<p><span class="math inline"><em>ρ</em> = <em>ρ</em>(<em>h</em>)</span>，是在高度<span class="math inline"><em>h</em></span>处的大气质量；</p>
<figure>
<img src="Table1.png" alt="表格1" /><figcaption aria-hidden="true">表格1</figcaption>
</figure>
<p>​ 根据以上的式子 (1),(2) 和已知的参数表1。要计算这个定积分，那就还需要知道 <span class="math inline"><em>ρ</em></span>, 也就是 <span class="math inline"><em>ρ</em>(<em>h</em>)</span> 在高度 h 处的大气密度，但是我在文献中找不到，这是个问题，不知道是不是需要再去别的地方找这个 <span class="math inline"><em>ρ</em></span>，看完了这篇文章之后，知道了这个 <span class="math inline"><em>ρ</em></span> 还是没有找到，但是文章已经给出了计算得到的结果的表格。</p>
<h2 id="近似计算公式和不同的系数">近似计算公式和不同的系数</h2>
<p><span class="math display"><em>f</em>(<em>γ</em>) = [sin<em>γ</em>+<em>a</em>(<em>γ</em>+<em>b</em>)<sup>−<em>c</em></sup>]<sup>−1</sup></span> <span class="math inline"><em>γ</em></span>是高度角，单位是<span class="math inline"><sup>∘</sup></span>;<span class="math inline"><em>f</em>(<em>γ</em>)</span>是用近似公式计算的<span class="math inline"><em>m</em>(<em>γ</em>)</span>;<span class="math inline"><em>a</em>, <em>b</em>, <em>c</em></span>是式子的常数，<span class="math inline"><em>a</em> = 0.1500，<em>b</em> = 3.885<sup>∘</sup>，<em>c</em> = 1.253;</span></p>
<p>​ a,b,c这三个常数决定于最小二乘法的相对误差，也就是用前面的计算公式计算数据之后，用最小二乘法进行拟合，使用(3)的形式来计算三个常数。</p>
<p>​ 文献后面又介绍了两个不同的参数组合，一个是根据非线性最小二乘法计算的 <span class="math inline"><em>a</em> = 0.50572, <em>b</em> = 6.07995°,</span> <span class="math inline"><em>c</em> = 1.6364</span>；一个是根据 <span class="math inline"><em>B</em><em>e</em><em>m</em><em>p</em><em>o</em><em>r</em><em>a</em><em>d</em></span> 的经典大气质量表确定的，<span class="math inline"><em>a</em> = 0.6556, <em>b</em> = 6.379°, <em>c</em> = 1.757[1]</span>，其中文献的表中的 <span class="math inline"><em>r</em>(<em>γ</em>)</span> 是根据公式(4)计算的相对误差，用来衡量计算大气质量的相对误差。 <span class="math display">$$
r(\gamma)=\frac{f(\gamma)-m(\gamma)}{m(\gamma)}
$$</span></p>
<h2 id="积分问题和解决">积分问题和解决</h2>
<p>​ 对于公式(2)，积分会在 <span class="math inline"><em>γ</em> = 0</span> 和 <span class="math inline"><em>h</em></span> 接近于0的地方不定，在这种情况下，这个积分可以通过执行一个特殊的程序来进行计算，在参考文献[1]中有写这个程序。但是在计算的时候有个错误会混入，在地平线上的值 36.2648 会比实际的小 5% 左右。</p>
<p>​ 举例而言，在 Link 和 Neuzil[3] 文章的表中所给出的地平线上的在1962年美国的标准大气的大气质量是38.16，这跟 1959 年 Karsen 用的 ARDC 模型十分接近。Snider 和 Goldman[4] 给出的关于 1962 年的模型的38.10也是高度相似。Treve[5] 使用1959年的 ARDC 模型，得到了在地平线上的相对大气质量分别是 $0.55μm $ 的38.11和在 <span class="math inline">0.70<em>μ</em><em>m</em></span> 的38.08。</p>
<p>​ 还有就是采用一种新的标准来却确定式子 (2) 中的参数会优于旧的模型，也就是最新的国际标准化组织的大气模型 (ISO Standrad Atmophere) 代替 ARDC 模型大气(由国际民航组织 ICAO 提出的)，这个仅有的变化也就是名义地球半径变为 <span class="math inline"><em>R</em> = 6.356766 × 10<sup>6</sup><em>m</em></span>。</p>
<h2 id="一个计算公式">一个计算公式</h2>
<p><span class="math display">$$
m=\frac{1}{cos \frac{\pi \theta_0}{180^\circ}+0.15\times(93.885-\theta_0)^{-1.253}}
$$</span></p>
<p>​ 其中m是需要计算的大气质量，<span class="math inline"><em>θ</em><sub>0</sub></span> 是天顶角。</p>
<h2 id="我要做的工作">我要做的工作</h2>
<p>​ 在这篇文章里面，我要做的就是编写一个程序，根据文献中的大气质量近似公式(3)，并且用不同的参数组带入，将表格中自变量太阳高度角γ作为自变量带入近似公式计算，再与表格中所给的大气质量数进行作差比较，即验证这个算法是否真的符合实际，如果误差较小，则可以用到我们的项目中去。</p>
<figure>
<img src="表格2.png" alt="表格2" /><figcaption aria-hidden="true">表格2</figcaption>
</figure>
<p>​ 上面的这张表格也就说明了在文章计算的数据中天顶角 <span class="math inline"><em>γ</em></span> 的取值变化，也就是计算的时候自变量所采用的值。过计算得到了一些结果。</p>
<h2 id="结果">结果</h2>
<p><img src="运用其他公式计算的和标准大气质量.bmp" /></p>
<p>​ 图1 标准大气质量和用其他公式计算的大气质量</p>
<p><img src="几种方法计算的大气质量.bmp" /></p>
<p>​ 图2 四种计算方法与标准大气质量</p>
<p><img src="三种拟合系数计算的相对大气质量.bmp" /></p>
<p>​ 图3 三种拟合系数计算的大气质量</p>
<p><img src="几种方法计算的大气质量的误差值.bmp" /></p>
<p>​ 图4 误差曲线</p>
<h2 id="分析">分析</h2>
<p>​ 从上面的图中可以看到，用三种不同的系数计算的相对大气质量以及三组拟合系数的误差曲线，从图中可以看到，三者在天顶角大于 30° 之后都是差不多的经度，主要就是在30°之前的差异。而且可以看到在起始点的时候，第一组和第三组都有很大的误差，特别是第三组，误差都接近于4%，回想文章中提到的积分会在 <span class="math inline"><em>γ</em> = 0</span> 和 h 接近于 0 的地方不定，需要查阅参考文献[1]来寻找解决方法。但是我看到这个计算的第二组拟合系数表现的很好，不知道是否可以用第二组数据来计算，或者是这三组数据都是在不同的情况下表现的经度水平会不一样。但是有个问题，我们没有找到拟合系数1的这条曲线，在下面会进行说明，实际上<u>它是和其他公式计算的这条曲线重合了</u>。</p>
<p>​ 对比三种方法和一个计算公式，发现计算公式的误差在几个计算方法折中的位置，在角度 &gt;10° 之后，这个计算值的偏差与第二组拟合系数计算的误差一样，都是非常小的。</p>
<p>​ 可以看看在高度角大于10°时候的表现。</p>
<p><img src="高度角大于10°的大气质量误差.bmp" /></p>
<p>​ 图 5 在高度角大于10°时候计算大气质量的误差</p>
<p>​ 这里没有找到拟合系数1这条曲线，是因为他的变化与公式计算的是一模一样的，两条线是重合的。</p>
<p><img src="找拟合系数1这条线.bmp" /></p>
<p>​ 图 6 拟合系数1和公式计算的天顶角大于10°的误差曲线</p>
<p>​ 这说明，其实拟合系数1也就是将天顶角计算的公式做了稍微的变化，就得到了太阳高度角的，<u>本质上，这两个公式是一模一样的</u>，只是取得系数不同罢了。</p>
<h2 id="新给的数据的计算">新给的数据的计算</h2>
<p>​ 在之后使用已经写好的这几种计算方法来计算新的数据值，数据可以在 ‘1.xlsx’ 表格中找到。</p>
<p><img src="8月6号到8号计算的大气质量值.bmp" /></p>
<p>​ 图 7 根据所给的数据计算的三天的大气质量数值</p>
<p>​ 可以看到，其实一天内的天顶角并不是全是 0~90° 的，这几天维持在 40° 以下，这时候，查阅标准数据也是差不多在这样的数据范围。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] Kasten,“A New Table and Approximation Formula for the Relative Optical Air Mass”,Arch.Meteorol.Geophys.Bioklimatol.Ser.B 14,206-223(1965). [2] R.A Miner,K.S.W.Chamption,and H.L.Pond,The ARDC Model Atmosphere,1959,Air Force Surveys in Geophysics 11(AFCRL,1959) [3] F.Link and L.Neuzil,Table of Light Trajectories in the Terrestrial Atmosphere(Hermann,Paris,1969) [4] D.E Snier and A. Goldman,Refractive Effects in Remote Sensing of Atmosphere with Infrared Transmission Spectroscopy,(Ballistic Research Labratories,June 1975) [5] Y. M. Treve, New Values of the Optical Air Mass and the Refraction and Comparison with Previous Tables,” in Proceed-ings, Second Tropospheric Refraction Effects Technical ReviewMeeting, Technical Documentary Rep. ESD-TDR 64-103, May1964 (National Technical Information Service Order AD-442626), pp.5-391. [6] International Organization for Standardization,Standard Atmosphere,International Standard ISO253(1972) [7] S.L.Valley,Handbook of Geophysics and Space Physics (AFCRL,1965), pp.23. [8] W.H.Jefferys,M.J.Fitzpatrick,B.E.McArthur,andJ.E. McCartney, GaussFit:A System for Least Squares and RobustEstimation (U. Texas at Austin, 1989). [9] A.T.Young,Observational Technique and Data Reduction,” inle to Methods of Experimental Physics(Vol. 12, Astrophysics; Partrmly A:Optical and Infrared),N,Carleton,Ed.(Academic, New York, 1974),p.150.</p>
<h2 id="代码">代码</h2>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">%x的步长选取</span></span><br><span class="line">x1=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">20</span>;</span><br><span class="line">x2=<span class="number">20.2</span>:<span class="number">0.2</span>:<span class="number">30</span>;</span><br><span class="line">x3=<span class="number">30.5</span>:<span class="number">0.5</span>:<span class="number">55</span>;</span><br><span class="line">x4=<span class="number">56</span>:<span class="number">1</span>:<span class="number">90</span>;</span><br><span class="line">x=[x1,x2,x3,x4];</span><br><span class="line"><span class="comment">%定义Latxe字符</span></span><br><span class="line"><span class="built_in">gamma</span>=texlabel(<span class="string">&#x27;gamma&#x27;</span>);flambda=texlabel(<span class="string">&#x27;f(lambda)&#x27;</span>);</span><br><span class="line">txt = texlabel(<span class="string">&#x27;f(lambda)=[sin gamma+a(gamma+b)^&#123;-c&#125;]^&#123;-1&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">%输入标准数据，画标准数据图像</span></span><br><span class="line">data=xlsread(<span class="string">&#x27;datain.xlsx&#x27;</span>);</span><br><span class="line">datax=data(:,<span class="number">1</span>);px=datax;</span><br><span class="line">datay=data(:,<span class="number">2</span>);py=datay;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(datax,datay);grid on;box off;</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(&#123;<span class="string">&#x27;标准的相对大气质量&#x27;</span>;flambda&#125;);</span><br><span class="line"><span class="comment">% print(&#x27;Standard&#x27;,&#x27;-deps&#x27;);</span></span><br><span class="line"><span class="comment">%调用三个计算函数</span></span><br><span class="line">airMass1=massCal1(x);</span><br><span class="line">airMass2=massCal2(x);</span><br><span class="line">airMass3=massCal3(x);</span><br><span class="line">airMass4=massCal4(x);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(datax,airMass4);</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(&#123;<span class="string">&#x27;其他公式计算的相对大气质量&#x27;</span>;flambda&#125;);</span><br><span class="line">suptitle(<span class="string">&#x27;相对大气质量与高度角的关系&#x27;</span>);grid on;box off</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">set(<span class="built_in">figure</span>(<span class="number">2</span>),<span class="string">&#x27;PaperSize&#x27;</span>,[<span class="number">42</span>,<span class="number">60</span>]);</span><br><span class="line">suptitle([<span class="string">&#x27;\fontsize&#123;14&#125;&#x27;</span>,txt]);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,airMass1);grid on;box off;</span><br><span class="line">text(<span class="number">60</span>,<span class="number">30</span>,<span class="string">&#x27;a=0.1500,b=3.885,c=1.253&#x27;</span>);</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(&#123;<span class="string">&#x27;计算的相对大气质量&#x27;</span>;flambda&#125;);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,airMass2);grid on;box off;</span><br><span class="line">text(<span class="number">60</span>,<span class="number">30</span>,<span class="string">&#x27;a=0.50572,b=6.07995,c=1.6364&#x27;</span>);</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(&#123;<span class="string">&#x27;计算的相对大气质量&#x27;</span>;flambda&#125;);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,airMass3);grid on;box off;</span><br><span class="line">text(<span class="number">60</span>,<span class="number">30</span>,<span class="string">&#x27;a=0.6556,b=6.379,c=1.757&#x27;</span>);</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(&#123;<span class="string">&#x27;计算的相对大气质量&#x27;</span>;flambda&#125;);</span><br><span class="line">set(gcf, <span class="string">&#x27;position&#x27;</span>, [<span class="number">1920</span>/<span class="number">4</span> <span class="number">1080</span>/<span class="number">4</span> <span class="number">1920</span>/<span class="number">2</span> <span class="number">1080</span>/<span class="number">1.5</span>]);</span><br><span class="line"><span class="comment">% print(&#x27;Calculate&#x27;,&#x27;-deps&#x27;);</span></span><br><span class="line"><span class="comment">%画三个函数的误差曲线</span></span><br><span class="line">datay=datay&#x27;;</span><br><span class="line">delta1 = (airMass1-datay)./datay*<span class="number">100</span>;</span><br><span class="line">delta2 = (airMass2-datay)./datay*<span class="number">100</span>;</span><br><span class="line">delta3 = (airMass3-datay)./datay*<span class="number">100</span>;</span><br><span class="line">delta4 = (airMass4-datay)./datay*<span class="number">100</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,delta1);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta2,<span class="string">&#x27;--&#x27;</span>);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta3,<span class="string">&#x27;:&#x27;</span>);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta4);grid on;box off;</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(<span class="string">&#x27;三种大气质量的误差(%)&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;第1组拟合系数&#x27;</span>,<span class="string">&#x27;第2组拟合系数&#x27;</span>,<span class="string">&#x27;第3组拟合系数&#x27;</span>,<span class="string">&#x27;其他公式计算&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;几种计算方法的误差&#x27;</span>);</span><br><span class="line"><span class="comment">% print(&#x27;Error&#x27;,&#x27;-deps&#x27;);</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(datax,datay);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,airMass1);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,airMass2);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,airMass3);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,airMass4);grid on;box off;</span><br><span class="line">xlabel([<span class="string">&#x27;高度角&#x27;</span>,<span class="built_in">gamma</span>]);ylabel(<span class="string">&#x27;相对大气质量&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;实际的&#x27;</span>,<span class="string">&#x27;方法1&#x27;</span>,<span class="string">&#x27;方法2&#x27;</span>,<span class="string">&#x27;方法三&#x27;</span>,<span class="string">&#x27;其他方法&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;几种方法和实际的相对大气质量&#x27;</span>);</span><br><span class="line"></span><br><span class="line">[~,Date,~] = xlsread(<span class="string">&#x27;1.xlsx&#x27;</span>,<span class="string">&#x27;A2:A105&#x27;</span>);</span><br><span class="line">Date = datetime(Date,<span class="string">&#x27;InputFormat&#x27;</span>,<span class="string">&#x27;dd/MM/yyyy&#x27;</span>);</span><br><span class="line">Date.Format = <span class="string">&#x27;yyyy-MM-dd&#x27;</span>;</span><br><span class="line">Time = days(xlsread(<span class="string">&#x27;1.xlsx&#x27;</span>,<span class="string">&#x27;B2:B105&#x27;</span>));</span><br><span class="line">Time.Format = <span class="string">&#x27;hh:mm:ss&#x27;</span>;</span><br><span class="line">datetime = Date+Time;</span><br><span class="line">datetime.Format = <span class="string">&#x27;yyyy-MM-dd hh:mm:ss&#x27;</span>;</span><br><span class="line">xxx=xlsread(<span class="string">&#x27;1.xlsx&#x27;</span>,<span class="string">&#x27;C2:C105&#x27;</span>);</span><br><span class="line">xx=<span class="number">90</span>-xxx;</span><br><span class="line">airMassx1=massCal1(xx);</span><br><span class="line">airMassx2=massCal2(xx);</span><br><span class="line">airMassx3=massCal3(xx);</span><br><span class="line">airMassx4=massCal4(xx);</span><br><span class="line">output=[airMassx1,airMassx2,airMassx3,airMassx4];</span><br><span class="line">xlswrite(<span class="string">&#x27;output.xlsx&#x27;</span>,output);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">datetime = datenum(datetime);</span><br><span class="line"><span class="built_in">plot</span>(datetime,airMassx1);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(datetime,airMassx2);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(datetime,airMassx3);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(datetime,airMassx4);grid on;box off;<span class="built_in">hold</span> on</span><br><span class="line">dateFormat = <span class="string">&#x27;yy-mm-dd HH:MM:SS&#x27;</span>;</span><br><span class="line">datetick(<span class="string">&#x27;x&#x27;</span>,dateFormat)</span><br><span class="line"><span class="comment">%plot(px,py);grid on;box off;</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;计算方法1&#x27;</span>,<span class="string">&#x27;计算方法2&#x27;</span>,<span class="string">&#x27;计算方法3&#x27;</span>,<span class="string">&#x27;其他方法计算的&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;大气质量&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;新给的数据的高度角计算的值&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = (x&gt;<span class="number">10</span>);</span><br><span class="line">x = x(p);</span><br><span class="line">delta1 = delta1(p);</span><br><span class="line">delta2 = delta2(p);</span><br><span class="line">delta3 = delta3(p);</span><br><span class="line">delta4 = delta4(p);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,delta1);<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta2);<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta3);<span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x,delta4);grid on;box off;</span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);ylabel(<span class="string">&#x27;大气质量计算偏差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;高度角 &gt;10° 时大气质量计算偏差&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;拟合系数1&#x27;</span>,<span class="string">&#x27;拟合系数2&#x27;</span>,<span class="string">&#x27;拟合系数3&#x27;</span>,<span class="string">&#x27;公式计算&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,delta1);box off;grid on</span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);ylabel(<span class="string">&#x27;大气质量计算偏差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;拟合系数1计算&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,delta4);box off;grid on</span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);ylabel(<span class="string">&#x27;大气质量计算偏差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;公式计算&#x27;</span>);</span><br><span class="line">suptitle(<span class="string">&#x27;高度角 &gt;10° 时大气质量计算偏差&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算方法1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">massCal1</span><span class="params">(gamma)</span></span></span><br><span class="line"><span class="comment">%函数调用格式：airMass=massCal1(gamma)</span></span><br><span class="line"><span class="comment">%输入参数说明：gamma是天顶角，单位是°</span></span><br><span class="line"><span class="comment">%输出参数说明：airMass是大气质量</span></span><br><span class="line">a=<span class="number">0.1500</span>;b=<span class="number">3.885</span>;c=<span class="number">1.253</span>;</span><br><span class="line"><span class="comment">% gamma=gamma*pi/180;%b=b*pi/180;</span></span><br><span class="line">y=(<span class="built_in">sin</span>(<span class="built_in">gamma</span>*<span class="built_in">pi</span>/<span class="number">180</span>)+a*(<span class="built_in">gamma</span>+b).^(-c)).^(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算方法2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">massCal2</span><span class="params">(gamma)</span></span></span><br><span class="line"><span class="comment">%函数调用格式：airMass=massCal2(gamma)</span></span><br><span class="line"><span class="comment">%输入参数说明：gamma是天顶角，单位是°</span></span><br><span class="line"><span class="comment">%输出参数说明：airMass是大气质量</span></span><br><span class="line">a=<span class="number">0.50572</span>;b=<span class="number">6.07995</span>;c=<span class="number">1.6364</span>;</span><br><span class="line">y=(<span class="built_in">sin</span>(<span class="built_in">gamma</span>*<span class="built_in">pi</span>/<span class="number">180</span>)+a*(<span class="built_in">gamma</span>+b).^(-c)).^(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 计算方法3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">massCal3</span><span class="params">(gamma)</span></span></span><br><span class="line"><span class="comment">%函数调用格式：airMass=massCal(gamma)</span></span><br><span class="line"><span class="comment">%输入参数说明：gamma是天顶角，单位是°</span></span><br><span class="line"><span class="comment">%输出参数说明：airMass是大气质量</span></span><br><span class="line">a=<span class="number">0.6556</span>;b=<span class="number">6.379</span>;c=<span class="number">1.757</span>;</span><br><span class="line">y=(<span class="built_in">sin</span>(<span class="built_in">gamma</span>*<span class="built_in">pi</span>/<span class="number">180</span>)+a*(<span class="built_in">gamma</span>+b).^(-c)).^(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>光学</tag>
      </tags>
  </entry>
  <entry>
    <title>内核转储文件--内核崩溃</title>
    <url>/2024/01/13/%E5%86%85%E6%A0%B8%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/%E5%86%85%E6%A0%B8%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6--%E5%86%85%E6%A0%B8%E5%B4%A9%E6%BA%83/</url>
    <content><![CDATA[<h2 id="ubuntu">Ubuntu</h2>
<h3 id="安装crash工具">安装crash工具</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">apt-get install linux-crashdump</span><br></pre></td></tr></table></figure>
<h3 id="检查kdump配置">检查kdump配置</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">kdump-config show</span><br><span class="line"></span><br><span class="line">DUMP_MODE:              kdump</span><br><span class="line">USE_KDUMP:              1</span><br><span class="line">KDUMP_COREDIR:          /var/crash</span><br><span class="line">crashkernel addr: 0x73000000</span><br><span class="line">   /var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-5.15.0-89-generic</span><br><span class="line">kdump initrd:</span><br><span class="line">   /var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-5.15.0-89-generic</span><br><span class="line">current state:    ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/boot/vmlinuz-5.15.0-89-generic root=UUID=92414257-97c5-46a0-9154-66c415ee7358 ro net.ifnames=0 consoleblank=600 console=tty0 console=ttyS0,115200n8 noibrs reset_devices systemd.unit=kdump-tools-dump.service nr_cpus=1 irqpoll nousb&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz</span><br></pre></td></tr></table></figure>
<p>USE_KDUMP=1 代表kdump打开</p>
<p>KDUMP_COREDIR 代表生成的core文件在<code>/var/crash</code>下面</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash"><span class="comment"># dmesg | grep -i crash</span></span></span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-89-generic root=UUID=92414257-97c5-46a0-9154-66c415ee7358 ro net.ifnames=0 consoleblank=600 console=tty0 console=ttyS0,115200n8 noibrs crashkernel=512M-:192M</span><br><span class="line">[    0.005698] Reserving 192MB of memory at 1840MB for crashkernel (System RAM: 2047MB)</span><br><span class="line">[    0.013125] Kernel command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-89-generic root=UUID=92414257-97c5-46a0-9154-66c415ee7358 ro net.ifnames=0 consoleblank=600 console=tty0 console=ttyS0,115200n8 noibrs crashkernel=512M-:192M</span><br></pre></td></tr></table></figure>
<p>dmesg 显示了crashkernel保留了192M内存，kexec命令。</p>
<h3 id="手动触发sysrq">手动触发sysrq</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/sysrq</span><br><span class="line">echo c &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>sysrq值不为0代表工作正常</li>
<li>echo写主动触发kdump</li>
</ol>
<h2 id="centos">CentOS</h2>
<h3 id="安装crash工具-1">安装crash工具</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">yum install kexec-tools</span><br><span class="line">yum install crash</span><br></pre></td></tr></table></figure>
<h3 id="安装内核调试信息包">安装内核调试信息包</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">yum install kernel-debuginfo-$(uname -r)</span><br><span class="line">yum install kernel-debuginfo-common-$(uname -r)</span><br></pre></td></tr></table></figure>
<h3 id="判断服务正常开启">判断服务正常开启</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">systemctl status kdump</span><br></pre></td></tr></table></figure>
<h3 id="主动触发分析">主动触发分析</h3>
<p>这一步跟Ubuntu的一致</p>
<h2 id="分析调试">分析调试</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">crash /usr/lib/debug/lib/modules/$(uname -r)/vmlinux /var/crash/XX/vmcore</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>常用shell命令</title>
    <url>/2025/12/21/shells/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="bash快捷键">Bash快捷键</h1>
<p><img src="moving_cli.png" /></p>
<h2 id="moving">Moving</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ctrl + a</td>
<td>Goto BEGINNING of command line</td>
</tr>
<tr class="even">
<td>ctrl + e</td>
<td>Goto END of command line</td>
</tr>
<tr class="odd">
<td>ctrl + b</td>
<td>move back one character</td>
</tr>
<tr class="even">
<td>ctrl + f</td>
<td>move forward one character</td>
</tr>
<tr class="odd">
<td>alt + f</td>
<td>move cursor FORWARD one word</td>
</tr>
<tr class="even">
<td>alt + b</td>
<td>move cursor BACK one word</td>
</tr>
<tr class="odd">
<td>ctrl + xx</td>
<td>Toggle between the start of line and current cursor position</td>
</tr>
<tr class="even">
<td>ctrl + ] + x</td>
<td>Where x is any character, moves the cursor forward to the next occurance of x</td>
</tr>
<tr class="odd">
<td>alt + ctrl + ] + x</td>
<td>Where x is any character, moves the cursor backwards to the previous occurance of x</td>
</tr>
</tbody>
</table>
<h2 id="edit-other">Edit / Other</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ctrl + d</td>
<td>Delete the character under the cursor</td>
</tr>
<tr class="even">
<td>ctrl + h</td>
<td>Delete the previous character before cursor</td>
</tr>
<tr class="odd">
<td>ctrl + u</td>
<td>Clear all / cut BEFORE cursor</td>
</tr>
<tr class="even">
<td>ctrl + k</td>
<td>Clear all / cut AFTER cursor</td>
</tr>
<tr class="odd">
<td>ctrl + w</td>
<td>delete the word BEFORE the cursor</td>
</tr>
<tr class="even">
<td>alt + d</td>
<td>delete the word FROM the cursor</td>
</tr>
<tr class="odd">
<td>ctrl + y</td>
<td>paste (if you used a previous command to delete)</td>
</tr>
<tr class="even">
<td>ctrl + i</td>
<td>command completion like Tab</td>
</tr>
<tr class="odd">
<td>ctrl + l</td>
<td>Clear the screen (same as clear command)</td>
</tr>
<tr class="even">
<td>ctrl + c</td>
<td>kill whatever is running</td>
</tr>
<tr class="odd">
<td>ctrl + d</td>
<td>Exit shell (same as exit command when cursor line is empty)</td>
</tr>
<tr class="even">
<td>ctrl + z</td>
<td>Place current process in background</td>
</tr>
<tr class="odd">
<td>ctrl + _</td>
<td>Undo</td>
</tr>
<tr class="even">
<td>ctrl + x ctrl + u</td>
<td>Undo the last changes. ctrl+ _ does the same</td>
</tr>
<tr class="odd">
<td>ctrl + t</td>
<td>Swap the last two characters before the cursor</td>
</tr>
<tr class="even">
<td>esc + t</td>
<td>Swap last two words before the cursor</td>
</tr>
<tr class="odd">
<td>alt + t</td>
<td>swap current word with previous</td>
</tr>
<tr class="even">
<td>esc + .</td>
<td></td>
</tr>
<tr class="odd">
<td>esc + _</td>
<td></td>
</tr>
<tr class="even">
<td>alt + [Backspace]</td>
<td>delete PREVIOUS word</td>
</tr>
<tr class="odd">
<td>alt + &lt;</td>
<td>Move to the first line in the history</td>
</tr>
<tr class="even">
<td>alt + &gt;</td>
<td>Move to the end of the input history, i.e., the line currently being entered</td>
</tr>
<tr class="odd">
<td>alt + ?</td>
<td>display the file/folder names in the current path as help</td>
</tr>
<tr class="even">
<td>alt + *</td>
<td>print all the file/folder names in the current path as parameter</td>
</tr>
<tr class="odd">
<td>alt + .</td>
<td>print the LAST ARGUMENT (ie “vim file1.txt file2.txt” will yield “file2.txt”)</td>
</tr>
<tr class="even">
<td>alt + c</td>
<td>capitalize the first character to end of word starting at cursor (whole word if cursor is at the beginning of word)</td>
</tr>
<tr class="odd">
<td>alt + u</td>
<td>make uppercase from cursor to end of word</td>
</tr>
<tr class="even">
<td>alt + l</td>
<td>make lowercase from cursor to end of word</td>
</tr>
<tr class="odd">
<td>alt + n</td>
<td></td>
</tr>
<tr class="even">
<td>alt + p</td>
<td>Non-incremental reverse search of history.</td>
</tr>
<tr class="odd">
<td>alt + r</td>
<td>Undo all changes to the line</td>
</tr>
<tr class="even">
<td>alt + ctl + e</td>
<td>Expand command line.</td>
</tr>
<tr class="odd">
<td>~[TAB][TAB]</td>
<td>List all users</td>
</tr>
<tr class="even">
<td>$[TAB][TAB]</td>
<td>List all system variables</td>
</tr>
<tr class="odd">
<td>@[TAB][TAB]</td>
<td>List all entries in your /etc/hosts file</td>
</tr>
<tr class="even">
<td>[TAB]</td>
<td>Auto complete</td>
</tr>
<tr class="odd">
<td>cd -</td>
<td>change to PREVIOUS working directory</td>
</tr>
</tbody>
</table>
<h2 id="history">History</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ctrl + r</td>
<td>Search backward starting at the current line and moving ‘up’ through the history as necessary</td>
</tr>
<tr class="even">
<td>crtl + s</td>
<td>Search forward starting at the current line and moving ‘down’ through the history as necessary</td>
</tr>
<tr class="odd">
<td>ctrl + p</td>
<td>Fetch the previous command from the history list, moving back in the list (same as up arrow)</td>
</tr>
<tr class="even">
<td>ctrl + n</td>
<td>Fetch the next command from the history list, moving forward in the list (same as down arrow)</td>
</tr>
<tr class="odd">
<td>ctrl + o</td>
<td>Execute the command found via Ctrl+r or Ctrl+s</td>
</tr>
<tr class="even">
<td>ctrl + g</td>
<td>Escape from history searching mode</td>
</tr>
<tr class="odd">
<td>!!</td>
<td>Run PREVIOUS command (ie <code>sudo !!</code>)</td>
</tr>
<tr class="even">
<td>!vi</td>
<td>Run PREVIOUS command that BEGINS with vi</td>
</tr>
<tr class="odd">
<td>!vi:p</td>
<td>Print previously run command that BEGINS with vi</td>
</tr>
<tr class="even">
<td>!n</td>
<td>Execute nth command in history</td>
</tr>
<tr class="odd">
<td>!$</td>
<td>Last argument of last command</td>
</tr>
<tr class="even">
<td>!^</td>
<td>First argument of last command</td>
</tr>
<tr class="odd">
<td><sup>abc</sup>xyz</td>
<td>Replace first occurance of abc with xyz in last command and execute it</td>
</tr>
</tbody>
</table>
<h1 id="常用命令">常用命令</h1>
<blockquote>
<p>https://github.com/jlevy/the-art-of-command-line/tree/master</p>
</blockquote>
<h2 id="bash命令行">bash命令行</h2>
<ul>
<li>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ # yum install gcc   &lt;--前面加#</span><br><span class="line">➜  ~ # yum install gcc   &lt;-- 按上键</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</li>
<li><code>pstree -p</code> 以一种优雅的方式展示进程树。</li>
<li>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</li>
<li>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</li>
<li>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>su - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。</li>
<li>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href="http://superuser.com/a/183980/7106">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</li>
<li>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</li>
<li>shell PS1显示 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 编辑配置文件（以当前用户的 ~/.bashrc 为例）</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 在文件末尾添加一行，例如：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示效果类似于：[Sun Dec 21 14:05:30] user@server:~$</span></span><br><span class="line">export PS1=&quot;[\d \t] \u@\h:\W\$ &quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 让配置立即生效</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件及数据处理">文件及数据处理</h2>
<ul>
<li><code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</li>
<li>使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</li>
<li>替换一个或多个文件中出现的字符串： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">perl -pi.bak -e &#x27;s/old-string/new-string/g&#x27; my-files-*.txt</span><br></pre></td></tr></table></figure></li>
<li><code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html">最快方法</a>之一： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</span><br></pre></td></tr></table></figure></li>
<li>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。 <img src="diff.png" /></li>
<li>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</li>
<li>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</li>
<li>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</li>
<li>操作日期和时间表达式，可以用 <a href="http://www.fresse.org/dateutils/"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</li>
<li>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</li>
<li>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></li>
<li>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getfacl -R /some/path &gt; permissions.txt</span><br><span class="line">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure></li>
<li>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href="https://zh.wikipedia.org/wiki/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</li>
</ul>
<h2 id="系统调试">系统调试</h2>
<ul>
<li><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href="https://github.com/jkbrzt/httpie"><code>httpie</code></a>。</li>
<li>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</li>
<li>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</li>
<li><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</li>
<li>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</li>
<li>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools">SJK tools</a> 更高级。</li>
<li>使用 <a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</li>
<li>用 <a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</li>
<li>查找正在使用带宽的套接字连接或进程，使用 <a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>。</li>
<li><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</li>
<li><a href="https://wireshark.org/"><code>wireshark</code></a>，<a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a> 和 <a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a> 可用于复杂的网络调试。</li>
<li>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</li>
<li>了解使用 <code>ldd</code> 来检查共享库。但是<a href="http://www.catonmat.net/blog/ldd-arbitrary-code-execution/">永远不要在不信任的文件上运行</a>。</li>
<li>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</li>
<li>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</li>
<li>当调试一些之前出现的问题的时候，<a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</li>
<li>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>），<a href="https://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a>，以及<a href="https://github.com/draios/sysdig"><code>sysdig</code></a>。</li>
<li>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</li>
<li>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</li>
<li>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用： <code>lsof | grep deleted | grep "filename-of-my-big-file"</code></li>
</ul>
<h2 id="单行脚本">单行脚本</h2>
<ul>
<li>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort a b | uniq &gt; c   # c 是 a 并 b</span><br><span class="line">sort a b | uniq -d &gt; c   # c 是 a 交 b</span><br><span class="line">sort a b b | uniq -u &gt; c   # c 是 a - b</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p></li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27; myfile</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -ls</span><br></pre></td></tr></table></figure></p></li>
<li><p>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">egrep -o &#x27;acct_id=[0-9]+&#x27; access.log | cut -d= -f2 | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure></p></li>
<li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 'ls -rtlh | tail'</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p></li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function taocl() &#123;</span><br><span class="line">	curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class="line">	pandoc -f markdown -t html |</span><br><span class="line">       iconv -f &#x27;utf-8&#x27; -t &#x27;unicode&#x27; |</span><br><span class="line">       xmlstarlet fo --html --dropdtd |</span><br><span class="line">       xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |</span><br><span class="line">       xmlstarlet unesc | fmt -80</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> ## 冷门但有用</p></li>
<li><p><code>expr</code>：计算表达式或正则匹配</p></li>
<li><p><code>m4</code>：简单的宏处理器</p></li>
<li><p><code>yes</code>：多次打印字符串</p></li>
<li><p><code>cal</code>：漂亮的日历</p></li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p></li>
<li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p></li>
<li><p><code>look</code>：查找以特定字符串开头的单词或行</p></li>
<li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p></li>
<li><p><code>fmt</code>：格式化文本段落</p></li>
<li><p><code>pr</code>：将文本格式化成页／列形式</p></li>
<li><p><code>fold</code>：包裹文本中的几行</p></li>
<li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p></li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p></li>
<li><p><code>nl</code>：添加行号</p></li>
<li><p><code>seq</code>：打印数字</p></li>
<li><p><code>bc</code>：计算器</p></li>
<li><p><code>factor</code>：分解因数</p></li>
<li><p><a href="https://gnupg.org/"><code>gpg</code></a>：加密并签名文件</p></li>
<li><p><code>toe</code>：terminfo 入口列表</p></li>
<li><p><code>nc</code>：网络调试及数据传输</p></li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p></li>
<li><p><a href="https://github.com/mattthias/slurm"><code>slurm</code></a>：网络流量可视化</p></li>
<li><p><code>dd</code>：文件或设备间传输数据</p></li>
<li><p><code>file</code>：确定文件类型</p></li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p></li>
<li><p><code>stat</code>：文件信息</p></li>
<li><p><code>time</code>：执行命令，并计算执行时间</p></li>
<li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p></li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p></li>
<li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p></li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p></li>
<li><p><a href="https://github.com/joh/when-changed"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p></li>
<li><p><code>tac</code>：反向输出文件</p></li>
<li><p><code>shuf</code>：文件中随机选取几行</p></li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p></li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p></li>
<li><p><code>tr</code>：转换字母</p></li>
<li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p></li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p></li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p></li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p></li>
<li><p><code>apg</code>：随机生成密码</p></li>
<li><p><code>xz</code>：高比例的文件压缩</p></li>
<li><p><code>ldd</code>：动态库信息</p></li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p></li>
<li><p><code>ab</code> 或 <a href="https://github.com/wg/wrk"><code>wrk</code></a>：web 服务器性能分析</p></li>
<li><p><code>strace</code>：调试系统调用</p></li>
<li><p><a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a>：更好的网络调试跟踪工具</p></li>
<li><p><code>cssh</code>：可视化的并发 shell</p></li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p></li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a> 和 <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>：抓包和网络调试工具</p></li>
<li><p><a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>：网络层的 grep</p></li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p></li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p></li>
<li><p><code>dstat</code>：系统状态查看</p></li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>：高层次的多子系统总览</p></li>
<li><p><code>iostat</code>：硬盘使用状态</p></li>
<li><p><code>mpstat</code>： CPU 使用状态</p></li>
<li><p><code>vmstat</code>： 内存使用状态</p></li>
<li><p><code>htop</code>：top 的加强版</p></li>
<li><p><code>last</code>：登入记录</p></li>
<li><p><code>w</code>：查看处于登录状态的用户</p></li>
<li><p><code>id</code>：用户/组 ID 信息</p></li>
<li><p><a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a>：系统历史数据</p></li>
<li><p><a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>：套接字及进程的网络利用情况</p></li>
<li><p><code>ss</code>：套接字数据</p></li>
<li><p><code>dmesg</code>：引导及系统错误信息</p></li>
<li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p></li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p></li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p></li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p></li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p></li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>内核转储文件--应用程序崩溃分析</title>
    <url>/2024/01/07/%E5%86%85%E6%A0%B8%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6/%E5%86%85%E6%A0%B8%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6--%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="ubuntu">Ubuntu</h2>
<p>设置如下的程序 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crash_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">char</span> *str =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(str,<span class="string">&quot;test&quot;</span>); <span class="comment">// segment fault</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;crash test&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">crash_test</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以下就是生成了dump文件</p>
<p><img src="Pastedimage20240113005115.png" /></p>
<h3 id="查看coredump是否打开">查看coredump是否打开</h3>
<p>查看命令：<code>ulimit -c</code></p>
<p>打开命令：<code>ulimit -c unlimited</code></p>
<p>0：关闭</p>
<p>unlimited：打开 ### 配置规则 主要看内核参数<code>kernel.core_pattern</code>，路径为<code>/proc/sys/kernel/core_pattern</code>。</p>
<p>所以修改有两种方法</p>
<p>1、<code>sysctl -w kernel.core_pattern=/root/core/core-%e.%s.%p.%t</code></p>
<p>2、<code>echo -e "/root/core/core-%e.%s.%p.%t" &gt; /proc/sys/kernel/core_pattern</code></p>
<blockquote>
<p>%e：进程名称</p>
<p>%s：崩溃时收到的信号</p>
<p>%p：进程ID</p>
<p>%t：时间戳</p>
</blockquote>
<h3 id="注意关闭apport服务">注意关闭apport服务</h3>
<p>这个服务会读取core文件分析，不会保存源文件 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">systemctl stop apport.service</span><br></pre></td></tr></table></figure></p>
<h2 id="centos">CentOS</h2>
<h3 id="编辑etcsecuritylimits.conf文件">编辑<code>/etc/security/limits.conf</code>文件</h3>
<p>末尾增加<code>soft core unlimited</code>，表示应用程序生成的core文件不受大小限制 ### 配置规则 和Ubuntu一样 ### reboot</p>
<h2 id="分析崩溃">分析崩溃</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">gdb test  /root/corefile/core-test.11.6284.1705062175</span><br></pre></td></tr></table></figure>
<p><img src="Pastedimage20240113011447.png" /></p>
<p>发现最后的出错函数位于strcpy这一处，源文件第8行。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>几种算法误差报告</title>
    <url>/2019/10/10/%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E8%AF%AF%E5%B7%AE%E6%8A%A5%E5%91%8A/%E5%87%A0%E7%A7%8D%E7%AE%97%E6%B3%95%E8%AF%AF%E5%B7%AE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="几种算法误差报告">几种算法误差报告</h1>
<p>​ 本文主要探讨了几种计算天顶角的算法，并且根据已经测得的标准数据进行了误差对比，以此来判断几种算法的精度。</p>
<h2 id="原算法的误差">原算法的误差</h2>
<h3 id="算法的计算步骤">算法的计算步骤</h3>
<p>​ 算法的详情我不是很了解，但是我得到了计算后的数据，将其与标准数据做对比。</p>
<h3 id="算法的实现代码">算法的实现代码</h3>
<p>​ MATLAB代码，new1是通过.csv文件导入得到的.mat数据。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%连接日期与时间</span></span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line"><span class="comment">%计算误差</span></span><br><span class="line">y = new1.Real-new1.Calculate;</span><br><span class="line"><span class="comment">%制图</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<h3 id="算法的最终结果">算法的最终结果</h3>
<p>​ 得到的结果如图:</p>
<figure>
<img src="huang.bmp" alt="huang" /><figcaption aria-hidden="true">huang</figcaption>
</figure>
<p>​ 根据上图可以看出来，在所给的测试数据中，天顶角的计算误差在<strong><u>-0.006~0.01</u></strong>。</p>
<h2 id="五种算法的公共部分">五种算法的公共部分</h2>
<h3 id="前时间处理部分">前时间处理部分</h3>
<figure>
<img src="Δτ.png" alt="Δτ" /><figcaption aria-hidden="true">Δτ</figcaption>
</figure>
<p>​ Δτ的计算是根据上图用插值法计算的一个线性表达式</p>
<p><span class="math display">$$
\Delta\tau=96.4+0.00158t\\
$$</span></p>
<p><span class="math display"><em>t</em> = <em>Δ</em><em>d</em><em>a</em><em>y</em> = (<em>y</em><em>e</em><em>a</em><em>r</em><sub><em>n</em><em>o</em><em>w</em></sub>−2060) × 365.2425</span> ​ 参数解释:</p>
<figure>
<img src="Parameter.png" alt="Parameter" /><figcaption aria-hidden="true">Parameter</figcaption>
</figure>
<p>​ 根据实际情况，确定了一些参数</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数名称</th>
<th style="text-align: center;">参数符号</th>
<th style="text-align: center;">单位</th>
<th style="text-align: center;">参数值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">经度</td>
<td style="text-align: center;">θ</td>
<td style="text-align: center;">rad</td>
<td style="text-align: center;">1.647765346807846</td>
</tr>
<tr class="even">
<td style="text-align: center;">纬度</td>
<td style="text-align: center;">φ</td>
<td style="text-align: center;">rad</td>
<td style="text-align: center;">0.699702497124527</td>
</tr>
<tr class="odd">
<td style="text-align: center;">压强</td>
<td style="text-align: center;">P</td>
<td style="text-align: center;">atm</td>
<td style="text-align: center;">0.85862324</td>
</tr>
<tr class="even">
<td style="text-align: center;">温度</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">℃</td>
<td style="text-align: center;">25</td>
</tr>
</tbody>
</table>
<p>​ 在计算过程中，如果月份m&lt;2，那么把月份加12，年份减1，这里的INT是表示向0取整。前处理过程如下：</p>
<p><img src="PreProcess.png" /> <span class="math display"><em>ω</em> = 0.017202786<em>d</em><em>a</em><em>y</em><sup>−1</sup></span></p>
<h3 id="后角度计算部分">后角度计算部分</h3>
<p><img src="Finalstep1.png" /></p>
<figure>
<img src="Finalstep2.png" alt="Finalstep (2)" /><figcaption aria-hidden="true">Finalstep (2)</figcaption>
</figure>
<figure>
<img src="Finalstep3.png" alt="Finalstep (3)" /><figcaption aria-hidden="true">Finalstep (3)</figcaption>
</figure>
<figure>
<img src="Finalstep4.png" alt="Finalstep (4)" /><figcaption aria-hidden="true">Finalstep (4)</figcaption>
</figure>
<figure>
<img src="Finalstep5.png" alt="Finalstep (5)" /><figcaption aria-hidden="true">Finalstep (5)</figcaption>
</figure>
<figure>
<img src="Finalstep6.png" alt="Finalstep (6)" /><figcaption aria-hidden="true">Finalstep (6)</figcaption>
</figure>
<p>​ 计算时只需要知道经<strong>纬度，赤经赤纬，时角</strong>就可以了。</p>
<h2 id="第一种算法的误差">第一种算法的误差</h2>
<h3 id="算法的计算步骤-1">算法的计算步骤</h3>
<p><img src="Al1.png" /></p>
<h3 id="算法的实现代码-1">算法的实现代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line"><span class="comment">% 第一种算法的计算误差</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 合并日期，提取信息</span></span><br><span class="line">load(<span class="string">&#x27;table.mat&#x27;</span>, <span class="string">&#x27;new1&#x27;</span>);</span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>] = readDateTime(x);</span><br><span class="line"><span class="comment">%调用算法函数计算</span></span><br><span class="line">data = [y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>];</span><br><span class="line">[GammaAngle,zAngle] = reportFun1(data);</span><br><span class="line">Real = new1.Real;</span><br><span class="line"><span class="comment">% 计算差值</span></span><br><span class="line">y = Real-zAngle&#x27;;</span><br><span class="line"><span class="comment">% 画图</span></span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% reportFun1函数</span></span><br><span class="line"><span class="comment">% 主要是根据文献的步骤写的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span> = <span class="title">reportFun1</span><span class="params">(data)</span></span></span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat,pre,tem] = readFile(data);</span><br><span class="line"><span class="comment">%需要转化为的数值或者其他常量</span></span><br><span class="line">[theta,phi,omega,t,te]=Preprocess(y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat);</span><br><span class="line"><span class="comment">%算法第一步，计算s1=sin(omega*te),c1=cos(omega*te);</span></span><br><span class="line">s1 = <span class="built_in">sin</span>(omega*te);c1=<span class="built_in">cos</span>(omega*te);</span><br><span class="line"><span class="comment">%算法第二步，计算s2=2*s1*c1,c2=(c1+s1)*(c1-s1)</span></span><br><span class="line">s2=<span class="number">2</span>*s1.*c1;c2=(c1+s1).*(c1-s1);</span><br><span class="line"><span class="comment">%算法第三步，计算赤经α</span></span><br><span class="line">alpha = <span class="number">-1.38880</span>+<span class="number">1.72027920</span>*<span class="number">10</span>^(<span class="number">-2</span>)*te+<span class="number">3.199</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s1...</span><br><span class="line">        <span class="number">-2.65</span>*<span class="number">10</span>^(<span class="number">-3</span>)*c1+<span class="number">4.050</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s2+<span class="number">1.525</span>*<span class="number">10</span>^(<span class="number">-2</span>)*c2;</span><br><span class="line"><span class="comment">%算法第四步，把α转换到方便的范围:α→mod(α,2π)</span></span><br><span class="line">alpha = <span class="built_in">mod</span>(alpha,<span class="number">2</span>*<span class="built_in">pi</span>);                                 <span class="comment">%根据算法用方便的范围代替，此时还是弧度</span></span><br><span class="line">alphaAngle = alpha*<span class="number">180</span>/<span class="built_in">pi</span>;                                <span class="comment">%转换到角度</span></span><br><span class="line"><span class="comment">%算法第五步，计算赤纬δ</span></span><br><span class="line">delta = <span class="number">6.57</span>*<span class="number">10</span>^(<span class="number">-3</span>)+<span class="number">7.347</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s1<span class="number">-3.9919</span>*<span class="number">10</span>^(<span class="number">-1</span>)*c1...</span><br><span class="line">        +<span class="number">7.3</span>*<span class="number">10</span>^(<span class="number">-4</span>)*s2<span class="number">-6.60</span>*<span class="number">10</span>^(<span class="number">-3</span>)*c2;</span><br><span class="line">deltaAngle = delta*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"><span class="comment">%算法第六步，注意都要用弧度                              </span></span><br><span class="line">H = <span class="number">1.75283</span>+<span class="number">6.3003881</span>*t+theta-alpha;</span><br><span class="line"><span class="comment">%算法第七步,转到方便的范围H→mod(H+π，2π)-π</span></span><br><span class="line">H = <span class="built_in">mod</span>(H+<span class="built_in">pi</span>,<span class="number">2</span>*<span class="built_in">pi</span>)-<span class="built_in">pi</span>;</span><br><span class="line">HAngle = H*<span class="number">180</span>/<span class="built_in">pi</span>;                                        <span class="comment">%转角度输出</span></span><br><span class="line"><span class="comment">% %Final Step,几个算法都一样的</span></span><br><span class="line">[GammaAngle,zAngle]=finalStep(phi,delta,H,tem,pre);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% ReadFile函数</span></span><br><span class="line"><span class="comment">% 读取年月日时分秒</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[y,m,d,h,min,sec,lon,lat,pre,tem]</span> = <span class="title">readFile</span><span class="params">(data)</span></span></span><br><span class="line">y = data(:,<span class="number">1</span>);</span><br><span class="line">m = data(:,<span class="number">2</span>);</span><br><span class="line">d = data(:,<span class="number">3</span>);</span><br><span class="line">h = data(:,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">min</span> = data(:,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">sec</span> = data(:,<span class="number">6</span>);</span><br><span class="line">[~,col] = <span class="built_in">size</span>(data);</span><br><span class="line"><span class="keyword">if</span>(col&gt;<span class="number">6</span>)</span><br><span class="line">lon = data(:,<span class="number">7</span>);</span><br><span class="line">lat = data(:,<span class="number">8</span>);</span><br><span class="line">pre = data(:,<span class="number">9</span>);</span><br><span class="line">tem = data(:,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    [lon,lat,pre,tem] = definePara();</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y=y&#x27;;</span><br><span class="line">m=m&#x27;;</span><br><span class="line">d=d&#x27;;</span><br><span class="line">h=h&#x27;;</span><br><span class="line"><span class="built_in">min</span>=min&#x27;;</span><br><span class="line"><span class="built_in">sec</span>=sec&#x27;;</span><br><span class="line">lon=lon&#x27;;</span><br><span class="line">pre=pre&#x27;;</span><br><span class="line">tem=tem&#x27;;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Preprocess函数</span></span><br><span class="line"><span class="comment">% 主要做一些前处理工作，如计算年积日等，也是根据文献来的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta,phi,omega,t,te]</span>=<span class="title">Preprocess</span><span class="params">(y,m,d,h,min,sec,lon,lat)</span></span></span><br><span class="line"><span class="comment">%调用格式[theta,phi,omega,t,te]=Proprocess(y,m,d,h,min,sec,lon,lat)</span></span><br><span class="line"><span class="comment">%输出参数[经度弧度θ，纬度弧度φ，ω常数，与2060相距天数t，t加上Δτ后的te]</span></span><br><span class="line"><span class="comment">%输入参数(年year，月month，日day，时hour，分minute，秒second，经度longitude(°)，纬度latitude(°))</span></span><br><span class="line">h = h+<span class="built_in">min</span>/<span class="number">60</span>+<span class="built_in">sec</span>/<span class="number">3600</span>;              <span class="comment">%精确时间</span></span><br><span class="line">theta = lon*<span class="built_in">pi</span>/<span class="number">180</span>;                 <span class="comment">%theta表示经度的弧度</span></span><br><span class="line">phi = lat*<span class="built_in">pi</span>/<span class="number">180</span>;                   <span class="comment">%phi表示纬度的弧度</span></span><br><span class="line">omega = <span class="number">0.017202786</span>;                <span class="comment">%omega是算法给的，单位是day^(-1)</span></span><br><span class="line">tau = <span class="number">96.4</span>+<span class="number">0.00158</span>*(y<span class="number">-2060</span>)*<span class="number">365</span>;    <span class="comment">%tau是前面用插值曲线计算的，代表论文中的Δτ</span></span><br><span class="line"><span class="keyword">if</span>(m&lt;=<span class="number">2</span>)                            <span class="comment">%根据前面的描述，如果月份小于2，那么月份+2，年份-1</span></span><br><span class="line">    m=m+<span class="number">12</span>;</span><br><span class="line">    y=y<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%根据算法1中的公式计算</span></span><br><span class="line"><span class="comment">%根据论文，也通过验证，代码没问题，下式的t是距离2060的天数，小的为-，大的为+</span></span><br><span class="line">t = <span class="built_in">fix</span>(<span class="number">365.25</span>*(y<span class="number">-2000</span>))+<span class="built_in">fix</span>(<span class="number">30.6001</span>*(m+<span class="number">1</span>))-<span class="built_in">fix</span>(<span class="number">0.01</span>*y)+d+h/<span class="number">24</span><span class="number">-21958</span>;</span><br><span class="line"><span class="comment">%te就是基于TT独立于地球转动，下面都用这个te来建立全局太阳位置</span></span><br><span class="line">te = t+<span class="number">1.574</span>*<span class="number">10</span>^(<span class="number">-5</span>)*tau;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% finalStep函数</span></span><br><span class="line"><span class="comment">% 几个算法的最终的步骤都是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span>=<span class="title">finalStep</span><span class="params">(phi,delta,H,tem,pre)</span></span></span><br><span class="line"><span class="comment">%函数调用格式:[GammaAngle,zAngle]=FinalStep(phi,delta,H,tem,pre)</span></span><br><span class="line"><span class="comment">%输出参数[方位角GammaAngle(°),天顶角zAngle(°)]</span></span><br><span class="line"><span class="comment">%输入参数(纬度phi,赤纬delta,时角H,温度tem,压强pre)</span></span><br><span class="line">e0 = <span class="built_in">asin</span>(<span class="built_in">sin</span>(phi).*<span class="built_in">sin</span>(delta)+<span class="built_in">cos</span>(phi).*<span class="built_in">cos</span>(delta).*<span class="built_in">cos</span>(H));      <span class="comment">%计算升角e0=arcsin(sinφsinδ+cosφcosδcosH),计算都要弧度</span></span><br><span class="line"><span class="comment">%计算Δpe应该是修正量</span></span><br><span class="line">deltape = <span class="number">-4.26</span>*<span class="number">10</span>^(<span class="number">-5</span>)*<span class="built_in">cos</span>(e0);                               <span class="comment">%以地心为中心</span></span><br><span class="line">ep = e0+deltape;</span><br><span class="line"><span class="comment">%计算方位角Γ=atan2(...)见下</span></span><br><span class="line">Gamma = <span class="built_in">atan2</span>(<span class="built_in">sin</span>(H),<span class="built_in">cos</span>(H).*<span class="built_in">sin</span>(phi)-<span class="built_in">tan</span>(delta).*<span class="built_in">cos</span>(phi));</span><br><span class="line">GammaAngle = Gamma*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">deltare = <span class="number">0.08422</span>*pre./((<span class="number">273</span>+tem).*<span class="built_in">tan</span>(ep+(<span class="number">0.003138</span>./(ep+<span class="number">0.08919</span>))));</span><br><span class="line"><span class="comment">%计算天顶角z</span></span><br><span class="line">z = <span class="built_in">pi</span>/<span class="number">2</span>-ep-deltare;</span><br><span class="line">zAngle = z*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="算法的最终结果-1">算法的最终结果</h3>
<figure>
<img src="第一种算法.bmp" alt="第一种算法" /><figcaption aria-hidden="true">第一种算法</figcaption>
</figure>
<p>​ 根据文献的第一种算法计算的误差不容乐观，在<strong><u>-0.2<sub>0.3</u><strong>之间，参考黄冬师兄算的误差，这个扩大了30倍。说明这个算法的精度不是很高，在文献中，这个算法最后也使用了计算数据进行了比较，他给出天顶角的误差范围在</strong><u>-0.19</sub>0.19</u></strong>，实际计算的比这个范围稍大些，只能说是我们这个数据不够精确或者文献的数据凑得比较好。</p>
<h2 id="第二种算法的误差">第二种算法的误差</h2>
<h3 id="算法的计算步骤-2">算法的计算步骤</h3>
<p><img src="Al2.png" /></p>
<h3 id="算法的实现代码-2">算法的实现代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line"><span class="comment">% 第二种算法的计算误差</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 合并日期，提取信息</span></span><br><span class="line">load(<span class="string">&#x27;table.mat&#x27;</span>, <span class="string">&#x27;new1&#x27;</span>);</span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>] = readDateTime(x);</span><br><span class="line">data = [y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>];</span><br><span class="line">[GammaAngle,zAngle] = reportFun2(data);</span><br><span class="line">Real = new1.Real;</span><br><span class="line">y = Real-zAngle&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% reportFun2函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span> = <span class="title">reportFun2</span><span class="params">(data)</span></span></span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat,pre,tem]=readFile(data);</span><br><span class="line">[theta,phi,omega,t,te]=Preprocess(y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat);</span><br><span class="line">[~,col]=<span class="built_in">size</span>(te);</span><br><span class="line"><span class="comment">%Step1</span></span><br><span class="line">s1=<span class="built_in">sin</span>(omega*te);c1=<span class="built_in">cos</span>(omega*te);</span><br><span class="line"><span class="comment">%Step2</span></span><br><span class="line">s2=<span class="number">2</span>*s1.*c1;c2=(c1+s1).*(c1-s1);</span><br><span class="line"><span class="comment">%Step3</span></span><br><span class="line">s3=s2.*c1+c2.*s1;c3=c2.*c1-s2.*s1;</span><br><span class="line"><span class="comment">%Step4</span></span><br><span class="line">s4=<span class="number">2</span>*s2.*c2;c4=(c2+s2).*(c2-s2);</span><br><span class="line"><span class="comment">%Step5</span></span><br><span class="line">alpha = <span class="number">-1.38880</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">1.72027920</span>*<span class="number">10</span>^(<span class="number">-2</span>)*te+<span class="number">3.199</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s1...</span><br><span class="line">        <span class="number">-2.65</span>*<span class="number">10</span>^(<span class="number">-3</span>)*c1+<span class="number">4.050</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s2+<span class="number">1.525</span>*<span class="number">10</span>^(<span class="number">-2</span>)*c2...</span><br><span class="line">        +<span class="number">1.33</span>*<span class="number">10</span>^(<span class="number">-3</span>)*s3+<span class="number">3.8</span>*<span class="number">10</span>^(<span class="number">-4</span>)*c3+<span class="number">7.3</span>*<span class="number">10</span>^(<span class="number">-4</span>)*s4+<span class="number">6.2</span>*<span class="number">10</span>^(<span class="number">-4</span>)*c4;</span><br><span class="line"><span class="comment">%Step6</span></span><br><span class="line">alpha = <span class="built_in">mod</span>(alpha,<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line"><span class="comment">%Step7</span></span><br><span class="line">delta = <span class="number">6.57</span>*<span class="number">10</span>^(<span class="number">-3</span>)*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">7.347</span>*<span class="number">10</span>^(<span class="number">-2</span>)*s1<span class="number">-3.9919</span>*<span class="number">10</span>^(<span class="number">-1</span>)*c1...</span><br><span class="line">        +<span class="number">7.3</span>*<span class="number">10</span>^(<span class="number">-4</span>)*s2<span class="number">-6.60</span>*<span class="number">10</span>^(<span class="number">-3</span>)*c2+<span class="number">1.50</span>*<span class="number">10</span>^(<span class="number">-3</span>)*s3...</span><br><span class="line">        <span class="number">-2.58</span>*<span class="number">10</span>^(<span class="number">-3</span>)*c3+<span class="number">6</span>*<span class="number">10</span>^(<span class="number">-5</span>)*s4<span class="number">-1.3</span>*<span class="number">10</span>^(<span class="number">-4</span>)*c4;</span><br><span class="line"><span class="comment">%Step8</span></span><br><span class="line">H = <span class="number">1.75283</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">6.3003881</span>*t+theta-alpha;</span><br><span class="line">H = <span class="built_in">mod</span>(H+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col),<span class="number">2</span>*<span class="built_in">pi</span>)-<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col);</span><br><span class="line">alphaAngle = alpha*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">deltaAngle = delta*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">HAngle = H*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">[GammaAngle,zAngle]=finalStep(phi,delta,H,tem,pre);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>​ 其实最大的不同只是reportFun()函数是不一样的，因为这个是算法的核心，主函数也是类似的，写入数据，调用函数，得到输出，最后画一下误差图。</p>
<p>​ 其他的前处理函数，后处理函数都是一模一样的。</p>
<h3 id="算法的最终结果-2">算法的最终结果</h3>
<p><img src="第二种算法.bmp" /></p>
<p>​ 根据文献的第二种算法计算的误差也是不太OK，而且有个严重的问题。从图上看出来，这个集散的误差范围在<strong><u>-0.2<sub>0.2</u><strong>之间，参考黄冬师兄算的误差，这个误差其实相对于第一种算法减小的不是很多。而且对比文献，他给出天顶角的误差范围在</strong><u>-0.034</sub>0.034</u></strong>，实际计算的比这个范围大了6倍，这个误差还是很大的。</p>
<h2 id="第三种算法的误差">第三种算法的误差</h2>
<h3 id="算法的计算步骤-3">算法的计算步骤</h3>
<p><img src="Al3.png" /></p>
<h3 id="算法的实现代码-3">算法的实现代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line"><span class="comment">% 第三种算法的计算误差</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 合并日期，提取信息</span></span><br><span class="line">load(<span class="string">&#x27;table.mat&#x27;</span>, <span class="string">&#x27;new1&#x27;</span>);</span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>] = readDateTime(x);</span><br><span class="line">data = [y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>];</span><br><span class="line">[GammaAngle,zAngle] = reportFun3(data);</span><br><span class="line">Real = new1.Real;</span><br><span class="line">y = Real-zAngle&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span> = <span class="title">reportFun3</span><span class="params">(data)</span></span></span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat,pre,tem]=readFile(data);</span><br><span class="line"><span class="comment">%需要转化为的数值或者其他常量</span></span><br><span class="line">[theta,phi,~,t,te]=Preprocess(y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat);</span><br><span class="line">[~,col]=<span class="built_in">size</span>(te);</span><br><span class="line">omegaa = <span class="number">0.0172019715</span>;</span><br><span class="line"><span class="comment">%Step1</span></span><br><span class="line">lambda = <span class="number">-1.388803</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">1.720279216</span>*<span class="number">10</span>^(<span class="number">-2</span>)*te+<span class="number">3.3366</span>*<span class="number">10</span>^(<span class="number">-2</span>)...</span><br><span class="line">         *<span class="built_in">sin</span>(omegaa*te<span class="number">-0.06172</span>)+<span class="number">3.53</span>*<span class="number">10</span>^(<span class="number">-4</span>)*<span class="built_in">sin</span>(<span class="number">2</span>*omegaa*te<span class="number">-0.1163</span>);</span><br><span class="line"><span class="comment">%Step2</span></span><br><span class="line">epsilon = <span class="number">4.089567</span>*<span class="number">10</span>^(<span class="number">-1</span>)*<span class="built_in">ones</span>(<span class="number">1</span>,col)<span class="number">-6.19</span>*<span class="number">10</span>^(<span class="number">-9</span>)*te;</span><br><span class="line"><span class="comment">%Step3</span></span><br><span class="line">slambda=<span class="built_in">sin</span>(lambda);clambda=<span class="built_in">cos</span>(lambda);</span><br><span class="line"><span class="comment">%Step4</span></span><br><span class="line">sepsilon=<span class="built_in">sin</span>(epsilon);cepsilon=<span class="built_in">sqrt</span>(<span class="number">1</span>-sepsilon.^(<span class="number">2</span>));</span><br><span class="line"><span class="comment">%Step5</span></span><br><span class="line">alpha = <span class="built_in">atan2</span>(slambda.*cepsilon,clambda);</span><br><span class="line"><span class="comment">%Step6</span></span><br><span class="line"><span class="keyword">if</span>(alpha&lt;<span class="number">0</span>)</span><br><span class="line">    alpha = alpha+<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%Step7</span></span><br><span class="line">delta = <span class="built_in">asin</span>(slambda.*sepsilon);</span><br><span class="line"><span class="comment">%Step8</span></span><br><span class="line">H = <span class="number">1.75283</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">6.3003881</span>*t+theta-alpha;</span><br><span class="line">H = <span class="built_in">mod</span>(H+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col),<span class="number">2</span>*<span class="built_in">pi</span>)-<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col);</span><br><span class="line">alphaAngle = alpha*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">deltaAngle = delta*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">HAngle = H*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">[GammaAngle,zAngle]=finalStep(phi,delta,H,tem,pre);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="算法的最终结果-3">算法的最终结果</h3>
<p><img src="第三种算法.bmp" /></p>
<p>​ 从图上看出来，这个计算的误差范围在<strong><u>-0.17<sub>0.17</u><strong>之间。对比文献，他给出天顶角的误差范围在</strong><u>-0.0093</sub>0.0093</u></strong>，实际计算的比这个范围大了18倍，说明这个差距还是很大的，是有一定问题的。</p>
<h2 id="第四种算法的误差">第四种算法的误差</h2>
<h3 id="算法的计算步骤-4">算法的计算步骤</h3>
<p><img src="Al4(1).png" /></p>
<p><img src="Al4(2).png" /></p>
<h3 id="算法的实现代码-4">算法的实现代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line"><span class="comment">% 第三种算法的计算误差</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 合并日期，提取信息</span></span><br><span class="line">load(<span class="string">&#x27;table.mat&#x27;</span>, <span class="string">&#x27;new1&#x27;</span>);</span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>] = readDateTime(x);</span><br><span class="line">data = [y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>];</span><br><span class="line">[GammaAngle,zAngle] = reportFun4(data);</span><br><span class="line">Real = new1.Real;</span><br><span class="line">y = Real-zAngle&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span> = <span class="title">reportFun4</span><span class="params">(data)</span></span></span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat,pre,tem]=readFile(data);</span><br><span class="line">[theta,phi,~,t,te]=Preprocess(y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat);</span><br><span class="line">[~,col]=<span class="built_in">size</span>(te);</span><br><span class="line">omegaa = <span class="number">0.0172019715</span>;</span><br><span class="line">omegan = <span class="number">9.282</span>*<span class="number">10</span>^(<span class="number">-4</span>);</span><br><span class="line"><span class="comment">%Step1</span></span><br><span class="line">L = <span class="number">1.752790</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">1.720279216</span>*<span class="number">10</span>^(<span class="number">-2</span>)*te+<span class="number">3.3366</span>*<span class="number">10</span>^(<span class="number">-2</span>)...</span><br><span class="line">    *<span class="built_in">sin</span>(omegaa*te<span class="number">-0.06172</span>)+<span class="number">3.53</span>*<span class="number">10</span>^(<span class="number">-4</span>)*<span class="built_in">sin</span>(<span class="number">2</span>*omegaa*te<span class="number">-0.1163</span>);</span><br><span class="line"><span class="comment">%Step2</span></span><br><span class="line">nu = omegan*te<span class="number">-0.8</span>;</span><br><span class="line"><span class="comment">%Step3</span></span><br><span class="line">deltalambda = <span class="number">8.34</span>*<span class="number">10</span>^(<span class="number">-5</span>)*<span class="built_in">sin</span>(nu);</span><br><span class="line"><span class="comment">%Step4</span></span><br><span class="line">lambda = L.*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+deltalambda;</span><br><span class="line"><span class="comment">%Step5</span></span><br><span class="line">epsilon = <span class="number">4.089567</span>*<span class="number">10</span>^(<span class="number">-1</span>)*<span class="built_in">ones</span>(<span class="number">1</span>,col)<span class="number">-6.19</span>*<span class="number">10</span>^(<span class="number">-9</span>)*te+<span class="number">4.46</span>*<span class="number">10</span>^(<span class="number">-5</span>)*<span class="built_in">cos</span>(nu);</span><br><span class="line"><span class="comment">%Step6</span></span><br><span class="line">slambda=<span class="built_in">sin</span>(lambda);clambda=<span class="built_in">cos</span>(lambda);</span><br><span class="line"><span class="comment">%Step7</span></span><br><span class="line">sepsilon=<span class="built_in">sin</span>(epsilon);cepsilon=<span class="built_in">cos</span>(epsilon);</span><br><span class="line"><span class="comment">%Step8</span></span><br><span class="line">alpha = <span class="built_in">atan2</span>(slambda.*cepsilon,clambda);</span><br><span class="line"><span class="comment">%Step9</span></span><br><span class="line"><span class="keyword">if</span>(alpha&lt;<span class="number">0</span>)</span><br><span class="line">    alpha = alpha+<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%Step10</span></span><br><span class="line">delta = <span class="built_in">asin</span>(slambda.*sepsilon);</span><br><span class="line"><span class="comment">%Step11</span></span><br><span class="line">H = <span class="number">1.7528311</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col)+<span class="number">6.300388099</span>*t+theta-alpha+<span class="number">0.92</span>*deltalambda;</span><br><span class="line">H = <span class="built_in">mod</span>(H+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col),<span class="number">2</span>*<span class="built_in">pi</span>)-<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,col);</span><br><span class="line">alphaAngle = alpha*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">deltaAngle = delta*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">HAngle = H*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">[GammaAngle,zAngle]=finalStep(phi,delta,H,tem,pre);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="算法的最终结果-4">算法的最终结果</h3>
<p><img src="第四种算法.bmp" /></p>
<p>​ 算法计算的误差在<strong><u>-0.17<sub>0.17</u><strong>之间。与算法三计算的差不多，文献中写的误差范围是</strong><u>-0.0091</sub>0.0091</u></strong>，差了17.5倍左右。</p>
<h2 id="第五种算法的误差">第五种算法的误差</h2>
<h3 id="算法的计算步骤-5">算法的计算步骤</h3>
<p>使用算法5计算的时候需要给表格中的参数。</p>
<p><img src="Al5table.png" /></p>
<p><img src="Al5.png" /></p>
<p><img src="Al5(2).png" /></p>
<h3 id="算法的实现代码-5">算法的实现代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 主函数</span></span><br><span class="line"><span class="comment">% 第三种算法的计算误差</span></span><br><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 合并日期，提取信息</span></span><br><span class="line">load(<span class="string">&#x27;table.mat&#x27;</span>, <span class="string">&#x27;new1&#x27;</span>);</span><br><span class="line">new1.Date.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">new1.Time.Format = <span class="string">&#x27;dd.MM.uuuu HH:mm&#x27;</span>;</span><br><span class="line">x = new1.Date + timeofday(new1.Time);</span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>] = readDateTime(x);</span><br><span class="line">data = [y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>];</span><br><span class="line">[GammaAngle,zAngle] = reportFun4(data);</span><br><span class="line">Real = new1.Real;</span><br><span class="line">y = Real-zAngle&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x,y);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);ylabel(<span class="string">&#x27;误差&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;天顶角实际值与计算值的误差&#x27;</span>);</span><br><span class="line">box off</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% reportFun5函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[GammaAngle,zAngle]</span> = <span class="title">reportFun5</span><span class="params">(data)</span></span></span><br><span class="line">[y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat,pre,tem]=readFile(data);</span><br><span class="line"><span class="comment">%需要转化为的数值或者其他常量</span></span><br><span class="line">[theta,phi,~,t,te]=Preprocess(y,m,d,h,<span class="built_in">min</span>,<span class="built_in">sec</span>,lon,lat);</span><br><span class="line"><span class="comment">%确定常数</span></span><br><span class="line">L0 = <span class="number">1.7527901</span>;</span><br><span class="line">L1 = <span class="number">1.7202792159</span>*<span class="number">10</span>^(<span class="number">-2</span>);</span><br><span class="line">omegaa = <span class="number">0.0172019715</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">2.92</span>*<span class="number">10</span>^(<span class="number">-5</span>);</span><br><span class="line">omegan = <span class="number">9.282</span>*<span class="number">10</span>^(<span class="number">-4</span>);</span><br><span class="line">omega = [<span class="number">1.49</span>*<span class="number">10</span>^(<span class="number">-3</span>),<span class="number">4.31</span>*<span class="number">10</span>^(<span class="number">-3</span>),<span class="number">1.076</span>*<span class="number">10</span>^(<span class="number">-2</span>),<span class="number">1.575</span>*<span class="number">10</span>^(<span class="number">-2</span>),...</span><br><span class="line">         <span class="number">2.152</span>*<span class="number">10</span>^(<span class="number">-2</span>),<span class="number">3.152</span>*<span class="number">10</span>^(<span class="number">-2</span>),<span class="number">2.1277</span>*<span class="number">10</span>^(<span class="number">-1</span>)];</span><br><span class="line">a = [<span class="number">3.33024</span>*<span class="number">10</span>^(<span class="number">-2</span>),<span class="number">3.512</span>*<span class="number">10</span>^(<span class="number">-4</span>),<span class="number">5.2</span>*<span class="number">10</span>^(<span class="number">-6</span>)];</span><br><span class="line">dbeta = <span class="number">-8.23</span>*<span class="number">10</span>^(<span class="number">-5</span>);</span><br><span class="line">d = [<span class="number">1.27</span>,<span class="number">1.21</span>,<span class="number">2.33</span>,<span class="number">3.49</span>,<span class="number">2.67</span>,<span class="number">1.28</span>,<span class="number">3.14</span>]*<span class="number">10</span>^(<span class="number">-5</span>);</span><br><span class="line">b = [<span class="number">-2.0582</span>*<span class="number">10</span>^(<span class="number">-3</span>),<span class="number">-4.07</span>*<span class="number">10</span>^(<span class="number">-5</span>),<span class="number">-9</span>*<span class="number">10</span>^(<span class="number">-7</span>)];</span><br><span class="line">Phi = [<span class="number">-2.337</span>,<span class="number">3.065</span>,<span class="number">-1.533</span>,<span class="number">-2.358</span>,<span class="number">0.074</span>,<span class="number">1.547</span>,<span class="number">-0.488</span>];</span><br><span class="line">     </span><br><span class="line">[~,volume]=<span class="built_in">size</span>(te);</span><br><span class="line">s1=<span class="built_in">sin</span>(omegaa*te);c1=<span class="built_in">cos</span>(omegaa*te);</span><br><span class="line">s2=<span class="number">2</span>*s1.*c1;c2=(c1+s1).*(c1-s1);</span><br><span class="line">s3=s2.*c1+c2.*s1;c3=c2.*c1-s2.*s1;</span><br><span class="line">Sigma7=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">7</span></span><br><span class="line">    Sigma7=Sigma7+d(<span class="built_in">i</span>)*<span class="built_in">sin</span>(omega(<span class="built_in">i</span>)*te+Phi(<span class="built_in">i</span>)*<span class="built_in">ones</span>(<span class="number">1</span>,volume));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">L=L0*<span class="built_in">ones</span>(<span class="number">1</span>,volume)+L1*te+(a(<span class="number">1</span>)*s1+a(<span class="number">2</span>)*s2+a(<span class="number">3</span>)*s3+b(<span class="number">1</span>)*c1+b(<span class="number">2</span>)*c2+b(<span class="number">3</span>)*c3)...</span><br><span class="line">    +dbeta*s1.*<span class="built_in">sin</span>(<span class="built_in">beta</span>*te)+Sigma7;</span><br><span class="line">nu=omegan*te<span class="number">-0.8</span>;</span><br><span class="line">deltalambda=<span class="number">8.34</span>*<span class="number">10</span>^(<span class="number">-5</span>)*<span class="built_in">sin</span>(nu);</span><br><span class="line">lambda=L+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,volume)+deltalambda;</span><br><span class="line">slambda=<span class="built_in">sin</span>(lambda);clambda=<span class="built_in">cos</span>(lambda);</span><br><span class="line">epsilon = <span class="number">4.089567</span>*<span class="number">10</span>^(<span class="number">-1</span>)*<span class="built_in">ones</span>(<span class="number">1</span>,volume)<span class="number">-6.19</span>*<span class="number">10</span>^(<span class="number">-9</span>)*te+<span class="number">4.46</span>*<span class="number">10</span>^(<span class="number">-5</span>)*<span class="built_in">cos</span>(nu);</span><br><span class="line">sepsilon=<span class="built_in">sin</span>(epsilon);cepsilon=<span class="built_in">sqrt</span>(<span class="number">1</span>-sepsilon.^(<span class="number">2</span>));</span><br><span class="line">alpha=<span class="built_in">atan2</span>(slambda.*cepsilon,clambda);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:volume</span><br><span class="line"><span class="keyword">if</span> alpha(<span class="built_in">i</span>)&lt;<span class="number">0</span></span><br><span class="line">    alpha(<span class="built_in">i</span>)=alpha(<span class="built_in">i</span>)+<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">delta=<span class="built_in">asin</span>(slambda.*sepsilon);</span><br><span class="line">H = <span class="number">1.7528311</span>*<span class="built_in">ones</span>(<span class="number">1</span>,volume,<span class="number">1</span>)+<span class="number">6.300388099</span>*t+theta-alpha+<span class="number">0.92</span>*deltalambda;</span><br><span class="line">H = <span class="built_in">mod</span>(H+<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,volume),<span class="number">2</span>*<span class="built_in">pi</span>)-<span class="built_in">pi</span>*<span class="built_in">ones</span>(<span class="number">1</span>,volume);</span><br><span class="line">deltaAngle=delta*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">HAngle=H*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">alphaAngle=alpha*<span class="number">180</span>/<span class="built_in">pi</span>;</span><br><span class="line">[GammaAngle,zAngle]=finalStep(phi,delta,H,tem,pre);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="算法的最终结果-5">算法的最终结果</h3>
<p><img src="第五种算法.bmp" /></p>
<p>​ 图上看误差大概也是<strong><u>-0.17<sub>0.16</u><strong>，文献的误差范围给的是</strong><u>-0.0025</sub>0.0027</u></strong>，差距是64倍左右，这个差距是很大的。</p>
<h4 id="分析一下8月7日">分析一下8月7日</h4>
<p><img src="算法5_8月7日角度值.bmp" /></p>
<p><img src="算法5_8月7日误差散点.bmp" /></p>
<p>​ 看了上面两张图，第一张其实看不出来什么，因为误差相对于测量角度的实际值差了100倍左右，能看出来的只是说一天中太阳天顶角是这么分布的。</p>
<p>​ 第二张图和第一张图结合看其实是能看出来一点东西的，看到其实到了6点左右也是天顶角最小，这也是说明这时候高度角最大，太阳在比较高的地方，这时候计算的误差是小的，在00：00和12：00处误差也较大。</p>
<p><img src="算法5_8月7日分布图.bmp" /></p>
<p>​ 看了上面的三幅图，看到这些计算的结果，可以发现误差的分布也有点稀奇古怪，看不出来是什么类型的分布，因为我觉得数据的总数也不是很大，来计算的点数也不够多。可能这样子反应的规律也不是跟明确。总体上来看，还是误差小的占的比例大，所以可能这也是可以稍微有点欣慰的一件事吧。</p>
<h2 id="总结">总结</h2>
<h3 id="几种计算方法的结果">几种计算方法的结果</h3>
<p><img src="算法1~算法4.bmp" /></p>
<p><img src="算法0和算法5.bmp" /></p>
<h3 id="说明">说明</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">文献给的误差范围</th>
<th style="text-align: center;">计算的误差范围</th>
<th style="text-align: center;">相差倍数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">[-0.19,0.19]</td>
<td style="text-align: center;">[-0.2,0.3]</td>
<td style="text-align: center;">1.05~1.5</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">[-0,034,0.034]</td>
<td style="text-align: center;">[-0.2,0.2]</td>
<td style="text-align: center;">5.8</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">[-0.0093,0.0092]</td>
<td style="text-align: center;">[-0.17,0.17]</td>
<td style="text-align: center;">18.3</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">[-0.0091,0.0093]</td>
<td style="text-align: center;">[-0.17,0.17]</td>
<td style="text-align: center;">18.7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">[-0.0025,0.0027]</td>
<td style="text-align: center;">[-0.16,0.16]</td>
<td style="text-align: center;">59.3</td>
</tr>
</tbody>
</table>
<p>从这个表格中看出，几种计算出来的结果都在只能最高保证在0.16。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] Roberto Grena Five new algorithms for the computation of sun position from 2010 to 2110 Solar Energy</p>
<p>https://www.sciencedirect.com/science/article/pii/S0038092X12000400</p>
]]></content>
      <tags>
        <tag>光学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian和github和hexo博客流配置</title>
    <url>/2023/12/21/%E5%8D%9A%E5%AE%A2%E6%B5%81%E9%85%8D%E7%BD%AE/Obsidian%E5%92%8Cgithub%E5%92%8Chexo%E5%8D%9A%E5%AE%A2%E6%B5%81%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="hexo配置">hexo配置</h2>
<h3 id="node.js配置">node.js配置</h3>
<h3 id="hexo主题配置">hexo主题配置</h3>
<h2 id="obsidian配置">Obsidian配置</h2>
<p>下载<code>Obsidian Git</code>插件，需要打开第三方插件按钮，下载插件。</p>
<p><img src="img1.png" /></p>
<p>在对应的.git目录下打开仓库，下图的打开本地仓库，生成本地目录。</p>
<p><img src="img3.png" /></p>
<p>配置Git设置地址等，这样就可以调用后台的git自动推送了</p>
<p><img src="img2.png" /></p>
<blockquote>
<p>需要注意的是：git需要首先被安装，并且配置到环境变量</p>
<h2 id="github配置">github配置</h2>
<h3 id="workflows配置">workflows配置</h3>
<h2 id="dependabot配置">dependabot配置</h2>
</blockquote>
]]></content>
      <tags>
        <tag>工作流</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>判断磁盘是ssd还是hdd</title>
    <url>/2024/01/21/%E5%88%A4%E6%96%AD%E7%A3%81%E7%9B%98%E6%98%AFssd%E8%BF%98%E6%98%AFhdd/%E5%88%A4%E6%96%AD%E7%A3%81%E7%9B%98%E6%98%AFssd%E8%BF%98%E6%98%AFhdd/</url>
    <content><![CDATA[<h2 id="linux">Linux</h2>
<h3 id="通过文件系统">通过文件系统</h3>
<p><code>rotational</code>为1代表可以旋转，为hdd，为0代表不能旋转，为ssd</p>
<p>查看位置在<code>/sys/block/sd*/queue/rotational</code> <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[root@dushenda home]# grep ^ /sys/block/sd*/queue/rotational  </span><br><span class="line">/sys/block/sda/queue/rotational:1  </span><br><span class="line">/sys/block/sdb/queue/rotational:1  </span><br><span class="line">/sys/block/sdc/queue/rotational:1</span><br></pre></td></tr></table></figure></p>
<h3 id="lsblk">lsblk</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[root@dushenda home]# lsblk -o name,rota,VENDOR  </span><br><span class="line">NAME ROTA VENDOR  </span><br><span class="line">sda 1 Msft  </span><br><span class="line">sdb 1 Msft  </span><br><span class="line">sdc 1 Msft</span><br></pre></td></tr></table></figure>
<p><code>lsblk</code>可选行信息如下等，通过<code>lsblk --help</code>查看 <img src="判断磁盘是ssd还是hdd_20240121.png" /></p>
<h3 id="smartctl">smartctl</h3>
<p>该工具需要自行安装Ubuntu和CentOS安装包名称均为<code>smartmontools</code>。 <figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[root@dushenda home]# smartctl -a /dev/sdc  </span><br><span class="line">smartctl 7.1 2019-12-30 r5022 [x86_64-linux-5.15.133.1-microsoft-standard-WSL2] (local build)  </span><br><span class="line">Copyright (C) 2002-19, Bruce Allen, Christian Franke, www.smartmontools.org  </span><br><span class="line">  </span><br><span class="line">=== START OF INFORMATION SECTION ===  </span><br><span class="line">Vendor: Msft  </span><br><span class="line">Product: Virtual Disk  </span><br><span class="line">Revision: 1.0  </span><br><span class="line">Compliance: SPC-3  </span><br><span class="line">User Capacity: 1,099,511,627,776 bytes [1.09 TB]  </span><br><span class="line">Logical block size: 512 bytes  </span><br><span class="line">Physical block size: 4096 bytes  </span><br><span class="line">LU is thin provisioned, LBPRZ=0</span><br></pre></td></tr></table></figure></p>
<h2 id="windows">Windows</h2>
<h3 id="powershell">powershell</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\dushenda&gt; Get-PhysicalDisk</span><br><span class="line"></span><br><span class="line">Number FriendlyName                  SerialNumber    MediaType CanPool OperationalStatus HealthStatus Usage            Size</span><br><span class="line">------ ------------                  ------------    --------- ------- ----------------- ------------ -----            ----</span><br><span class="line">1      Samsung SSD 860 EVO M.2 500GB S414NB0K722943N SSD       False   OK                Healthy      Auto-Select 465.76 GB</span><br><span class="line">0      WDC WD10SPCX-24HWST1          WD-WXB1AC41L2P1 HDD       False   OK                Healthy      Auto-Select 931.51 GB</span><br></pre></td></tr></table></figure>
<h3 id="gui">GUI</h3>
<p>在任务管理器下查看 <img src="判断磁盘是ssd还是hdd_20240121_1.png" /></p>
]]></content>
      <tags>
        <tag>磁盘</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo增加mermaid</title>
    <url>/2025/12/21/%E5%8D%9A%E5%AE%A2%E6%B5%81%E9%85%8D%E7%BD%AE/hexo%E5%A2%9E%E5%8A%A0mermaid/</url>
    <content><![CDATA[<h1 id="config.next.yml文件">_config.next.yml文件</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Mermaid tag</span><br><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available themes: default | dark | forest | neutral</span><br><span class="line">  theme:</span><br><span class="line">    light: forest</span><br><span class="line">    dark: dark</span><br></pre></td></tr></table></figure>
<p><img src="image.png" /></p>
<h1 id="例子">例子</h1>
<pre><code class="highlight mermaid">flowchart

A-- This is the text! ---B</code></pre>
<pre><code class="highlight mermaid">sequenceDiagram
Alice-&gt;&gt;John: Hello John, how are you?
John--&gt;&gt;Alice: Great!
Alice-)John: See you later!</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>最大间隙问题</title>
    <url>/2019/11/24/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/%E6%9C%80%E5%A4%A7%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="最大间隙问题">最大间隙问题</h1>
<h2 id="题目">题目</h2>
<p>对于输入的一组数，个数为 n ，求这 n 个数中大小相邻的两个数之间最大差。假设对于任何实数的下取整函数耗时都是 O(1) ，设计此问题的最大间隙解法。例如。</p>
<p><code>input.txt</code> <code>output.txt</code></p>
<p>5 0.8</p>
<p>1.1 1.3 2.5 0.7 2.1</p>
<p>其中这个几个数依次排列 0.7&lt;1.1&lt;1.3&lt;2.1&lt;2.5</p>
<p>可以看到，这几个相邻数字之间的差距最大在 2.1-1.3=0.8，所以求得这几个数字之间的最大间距是 0.8</p>
<h2 id="思考">思考</h2>
<h3 id="办法一">办法一</h3>
<p>对于这个题目，首先我想到的也就是上面这个思路，首先要判断整个数组的两数相邻与否，那么我要做的就是将其排序，排序完，我再将其相邻数做差，那么也就是的都一个相邻两数的数组，得到数组之后，我就寻找数组中的最大元素，找到最大元素，再对应其索引，我就能找到那两个数字了。</p>
<p>但是，我立刻又想到了复杂度问题，因为排序算法的复杂度最低的是分治法，普通的搜索算法复杂度会比排序低的</p>
<p>复杂度计算如下 <span class="math display">$$
O(n\log n)+O(n)+O(n)=O(n\log n) \\
O(n\log n) &gt; O(n)
$$</span> ​ <!--排序算法+做差+搜索--> 这个复杂度有点尴尬，因为他不是线性复杂度，不符合题目的要求，所以这个思路是不可行的。</p>
<p>那么我只能换其他的办法来做。</p>
<h3 id="办法二">办法二</h3>
<ol type="1">
<li>设输入的是n个数，分别为 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ..., <em>a</em><sub><em>n</em></sub>​</span> ，设在这些数中最大的数为<span class="math inline"><em>a</em><sub><em>m</em><em>a</em><em>x</em></sub>​</span>，最小的是<span class="math inline"><em>a</em><sub><em>m</em><em>i</em><em>n</em></sub>​</span>；</li>
<li>在<span class="math inline"><em>a</em><sub><em>m</em><em>a</em><em>x</em></sub></span>与<span class="math inline"><em>a</em><sub><em>m</em><em>i</em><em>n</em></sub></span>之间均匀插入<span class="math inline"><em>n</em> − 2</span>个等分点，将其分为<span class="math inline"><em>n</em> − 1</span>段，如下图； <img src="分段.png" /></li>
<li>把需要剩下的<span class="math inline"><em>n</em> − 2</span>个数按照大小放入这<span class="math inline"><em>n</em> − 1​</span>个段中，根据鸽巢原理，那么其中必定有一个段是空的，如果有一个段是空的，那么我们就可以知道两个相邻数字之间的差值肯定是在两个段中的；</li>
<li>计算每个段中的最大值最小值<span class="math inline"><em>l</em><em>o</em><em>w</em>[<em>i</em>]</span>和<span class="math inline"><em>h</em><em>i</em><em>g</em><em>h</em>[<em>i</em>]</span>，再使用后一段的<span class="math inline"><em>l</em><em>o</em><em>w</em>[<em>i</em>+1]</span>减去前一段的<span class="math inline"><em>h</em><em>i</em><em>g</em><em>h</em>[<em>i</em>]</span>，得到这些差值中的最大值就是相邻两数的最大间隙了。</li>
</ol>
<p>分析一下复杂度，对于找最大最小值，也只需要遍历一次即可，所以复杂度为<span class="math inline"><em>O</em>(<em>n</em>)​</span>，等分点只需要得到单位长度即可，单位长度为 <span class="math display">$$
l=\frac{max-mix}{n-1}
$$</span> 每个数要判断在哪个段里面也只需要知道自己跟起始处距离几个单位长度即可 <span class="math display">$$
seg[i]=\frac{x[i]-minx}{l}+1
$$</span> 数组<span class="math inline"><em>s</em><em>e</em><em>g</em>[<em>i</em>]</span>是一个纽带氏作用，它的索引与<span class="math inline"><em>x</em>[<em>i</em>]</span>的数的索引是一样的，数组里面存储的数对于的第几个段。这个过程也是用这个公式就可以计算完成的，所以这个过程的复杂度也是<span class="math inline"><em>O</em>(<em>n</em>)</span>，最后需要做差，使用<span class="math inline"><em>l</em><em>o</em><em>w</em>[<em>i</em>+1] − <em>h</em><em>i</em><em>g</em><em>h</em>[<em>i</em>]</span>得到数组的间隙的最大值即可，最后这个过程的复杂吨也只需要<span class="math inline"><em>O</em>(<em>n</em>)</span>。</p>
<p>根据前面的分析，每个过程的复杂度均为<span class="math inline"><em>O</em>(<em>n</em>)</span>，那么有限个<span class="math inline"><em>O</em>(<em>n</em>)</span>的累加复杂度还是<span class="math inline"><em>O</em>(<em>n</em>)</span>，说明这个方法是可行的，满足题目要求。</p>
<h2 id="伪代码">伪代码</h2>
<p>通过前面的分析，确定了方法二是可行的，那么就可以采用这个方法来进行伪代码书写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先要求出最大值最小值。在这里求出它的索引，这样通过 x 数组访问就可得到它的值了</span></span><br><span class="line">function maxi</span><br><span class="line">maxi = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>:<span class="number">1</span>:n</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">x</span>(i) &gt; x[maxi])	maxi = i;</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> maxi;</span><br><span class="line"></span><br><span class="line">function mini</span><br><span class="line">mini = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>:<span class="number">1</span>:n</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">x</span>(i) &gt; x[mini])	mini = i;</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> mini;</span><br><span class="line"><span class="comment">//计算最大最小值，计算刻度，计算索引映射数据段数组 seg</span></span><br><span class="line">maxx = x[maxi];minx = x[mini];</span><br><span class="line">l = (maxx - minx)/(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>:<span class="number">1</span>:n</span><br><span class="line">	seg[i] = (x[i] - minx)/l;</span><br><span class="line">end</span><br><span class="line"><span class="comment">//初始化 low 和 high 数组</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>:<span class="number">1</span>:n<span class="number">-2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>资源收集</title>
    <url>/2024/01/13/%E6%9D%82/%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>malloc: http://blog.codinglabs.org/articles/a-malloc-tutorial.html</p>
<p>duartes.org: http://duartes.org/gustavo/blog/archives/</p>
<p>github mannul: http://www.epubit.com.cn/article/844#what</p>
<p>liaoxuefeng.com: http://www.liaoxuefeng.com/</p>
<p>TCP/IP network: http://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</p>
<p>netfilter.org: https://people.netfilter.org/pablo/netdev0.1/papers/</p>
<p>tuning-linux-sending: https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/</p>
<p>tuning-linux-receiving: https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</p>
<p>strace: https://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/</p>
<p>IBM-Tim: https://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?search_by=Linux+%E5%89%96%E6%9E%90</p>
<p>yeolar: http://www.yeolar.com/</p>
<p>http://www.yeolar.com/note/2012/03/29/virtual-memory/</p>
<p>vxlan: https://blogs.vmware.com/vsphere/2013/07/vxlan-series-how-vmotion-impacts-the-forwarding-table-part-6.html</p>
<p>http://www.cisco.com/c/en/us/products/collateral/switches/nexus-5000-series-switches/white-paper-c11-733618.html#_Toc439799767</p>
<p>http://www.cisco.com/c/en/us/products/collateral/switches/nexus-9000-series-switches/white-paper-c11-729383.html</p>
<p>ali-kernel: http://kernel.taobao.org/index.php?title=%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A52017-02</p>
<p>linux-performance: http://www.brendangregg.com/linuxperf.html</p>
<p>systemTap: https://sourceware.org/systemtap/SystemTap_Beginners_Guide/</p>
<p>calico: http://docs.projectcalico.org/v2.0/introduction/</p>
<p>docker: http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice</p>
<p>Flannel: http://dockone.io/article/618</p>
<p>SDN: https://www.opennetworking.org/</p>
<p>Linux Kernel Networking: https://wiki.linuxfoundation.org/networking/start</p>
<p>MacVtap: https://blog.kghost.info/2013/03/27/linux-network-tun/</p>
<p>http://blog.csdn.net/dog250/article/details/45788279</p>
<p>Neutron: http://blog.csdn.net/quqi99/article/details/22853403</p>
<p>Linux Bridge: http://blog.csdn.net/yeasy/article/details/50728243</p>
<p>Docker Networking: http://edgedef.com/docker-networking.html</p>
<p>Tun/Tap interface: http://backreference.org/2010/03/26/tuntap-interface-tutorial/</p>
<p>TC ifb: http://blog.csdn.net/dog250/article/details/40680765?utm_source=tuicool&amp;utm_medium=referral</p>
<p>汇编:</p>
]]></content>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>现代操作系统-进程与线程16~30</title>
    <url>/2018/12/28/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B16~30/</url>
    <content><![CDATA[<blockquote>
<p>以下答案均不代表正确答案，仅代表作者观点</p>
</blockquote>
<ul>
<li><h5 id="线程可以被时钟中断抢占吗如果可以在什么情形下可以如果不可以为什么不可以">16.线程可以被时钟中断抢占吗？如果可以，在什么情形下可以？如果不可以，为什么不可以？</h5>
<p>用户级线程不能被时钟剥夺，除非整个进程的时间片用完。内核级线程可以单独地被剥夺。在后一种情况下，如果线程运行过久，时钟将中断该当前进程，因而当前线程也被中断。内核可以自由地从同一个进程中选取其他线程运行。</p></li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>现代操作系统-进程与线程1~15</title>
    <url>/2018/12/20/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B1~15/</url>
    <content><![CDATA[<h1 id="现代操作系统-进程与线程115">现代操作系统-进程与线程1~15</h1>
<blockquote>
<p>以下答案都是作者作答，不代表正确答案，望周知。</p>
</blockquote>
<hr />
<ol type="1">
<li><h5 id="如图对于每一个进程都有四种状态照理应该有6种切换方式但是为什么只有四种为什么另外两种不行">如图，对于每一个进程都有四种状态，照理应该有6种切换方式，但是为什么只有四种，为什么另外两种不行？</h5></li>
</ol>
<p><img src="1.bmp" alt="img" /> 答：<strong>从逻辑上来说，就绪态和运行态是类似的</strong>，唯一的不同是在于是否得到CPU资源。如果从就绪态可以转换到阻塞态，那么出现的事件也就是需要等待输入，但是，就绪态就是因为已经出现了有效的输入只不过没有得到CPU资源而产生的等待，所以不可能出现就绪态向阻塞态的转变；从阻塞态到运行态是得到了有效的输入和CPU计算资源才能完成的转化，但是得到有效的输入肯定会位于得到资源的前面，因为没有有效的输入都不能进行计算，而当出现有效输入的时候，就已经是就绪态了，即使有效输入和CPU资源获取的间隔很小，但是始终存在，所以肯定会经过就绪态。</p>
<span id="more"></span>
<ol start="2" type="1">
<li><h5 id="假设要设计一种先进的计算机体系结构它使用硬件替代中断来完成进程切换进程切换时cpu需要哪些信息请描述用硬件完成进程切换的工作过程">假设要设计一种先进的计算机体系结构，它使用硬件替代中断来完成进程切换。进程切换时CPU需要哪些信息？请描述用硬件完成进程切换的工作过程。</h5></li>
</ol>
<p>首先需要知道，进程的管理是使用进程表来实现的。操作系统维护着一张表格，里面存储着各个进程的信息，是用结构数组实现的，每一个进程都占一个进程表项。所以管理进程也就是管理进程表，如果用硬件完成切换，首先需要有一个包含当前正在运行的进程的进程表项的指针，当当前进程从运行态转换到就绪态或者阻塞态的时候，将这部分信息存入进程表中，之后调度程序再加载下一个进程，并且更新该寄存器的指针值。P.S. 进程表和进程表项大概是这样的:</p>
<table>
<thead>
<tr class="header">
<th>进程表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>进程1</td>
</tr>
<tr class="even">
<td>进程2</td>
</tr>
<tr class="odd">
<td>进程3</td>
</tr>
</tbody>
</table>
<p>进程表项：</p>
<table>
<thead>
<tr class="header">
<th>进程管理</th>
<th>存储管理</th>
<th>文件目录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>寄存器</td>
<td>正文段指针</td>
<td>根目录</td>
</tr>
<tr class="even">
<td>程序计数器</td>
<td>数据段指针</td>
<td>工作目录</td>
</tr>
<tr class="odd">
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li><h5 id="当代计算机中为什么中断处理程序至少有一部分的是由汇编语言写的">当代计算机中，为什么中断处理程序至少有一部分的是由汇编语言写的？</h5></li>
</ol>
<p>答：因为要有部分功能需要直接访问硬件。</p>
<ol start="4" type="1">
<li><h5 id="中断或系统调用把控制权交给操作系统的时候为什么通常会用到与被中断进程的栈分离的内核栈">中断或系统调用把控制权交给操作系统的时候，为什么通常会用到与被中断进程的栈分离的内核栈？</h5></li>
</ol>
<p>答：这个问题的实质应该是问的为什么内核使用单独的堆栈而不是使用中断进程的堆栈。中断是由外部的用户进程产生的，用户进程和内核进程的重要程度和安全要求不一样，首先用户进程的堆栈有可能崩溃，如果将内核栈放在其中，会导致操作系统的崩溃，并且用户进程的堆栈是可以为用户读写的，如果将内核堆栈放在其中，则计算机系统可能会被某些恶意程序所劫持。</p>
<ol start="5" type="1">
<li><h5 id="一个计算机系统的内存有足够的空间容纳5个程序这些程序有一半的时间处于等待io的空闲状态请问cpu时间浪费的比例是多少">一个计算机系统的内存有足够的空间容纳5个程序。这些程序有一半的时间处于等待I/O的空闲状态。请问CPU时间浪费的比例是多少？</h5></li>
</ol>
<p>答：一个程序空闲的概率为<span class="math inline">$p=\frac{1}{2}$</span>，要等到五个程序都空闲时候，CPU才不做任何计算，这时候处于空闲状态，这五个进程相互独立，则CPU的空闲（即浪费时间）为<span class="math inline">$p^5=\frac{1}{2^5}=\frac{1}{32}$</span>。</p>
<hr />
<ol start="6" type="1">
<li><h5 id="一个计算机的ram有4gb其中操作系统占512mb所有进程占256mb为了简化计算并且特征相同要使cpu利用率达到99最大io等待为多少">一个计算机的RAM有4GB，其中操作系统占512MB，。所有进程占256MB（为了简化计算）并且特征相同。要使CPU利用率达到99%，最大I/O等待为多少？</h5></li>
</ol>
<p>答：首先要看懂所有进程占256MB这句话的意思，这是说每个进程都是256MB并且一样。先计算在4G内存下最多存在的进程数目<span class="math inline">$m=\frac{4GB-512MB}{256MB}=14$</span>，说明最多有14个进程。设每个进程的I/O等待为<span class="math inline"><em>p</em></span>，则CPU的空闲率为<span class="math inline"><em>p</em><sup>14</sup></span>，并且要求占用率<span class="math inline"> ≥ 99%</span>，所以有等式</p>
<p><span class="math display">1 − <em>p</em><sup>14</sup> ≥ 99%</span></p>
<p>计算得到<span class="math inline"><em>p</em> ≤ 71.9%</span>。</p>
<ol start="7" type="1">
<li><h5 id="如果多个作业能够并行运行会比他们顺序执行完成的快假设有两个作业同时开始执行每个需要20min的cpu时间如果顺序执行那么完成最后一个作业需要多长时间如果并行执行又需要多长时间假设io等待占50">如果多个作业能够并行运行，会比他们顺序执行完成的快。假设有两个作业同时开始执行，每个需要20min的CPU时间。如果顺序执行，那么完成最后一个作业需要多长时间？如果并行执行，又需要多长时间？假设I/O等待占50%。</h5></li>
</ol>
<p>答：</p>
<figure>
<img src="2.bmp" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如图所示，如果顺序执行，那么每个进程在输入需要10min，在输出需要10min，所以进行一个就需要40min的时间，共需要80min。</p>
<p>如果是并行执行，那么每个进程得到的CPU的利用率为<span class="math inline">$\frac{1-p^2}{2}=0.375$</span>，每个进程本来在CPU利用率为1的时候需要20min，现在在CPU利用率为0.375的情况下需要时间为<span class="math inline">$\frac{20\min}{0.375}\approx53.3\min$</span>，由于是并行执行，取其最大的即可，即<span class="math inline">max {<em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, ...<em>T</em><sub><em>n</em></sub>}</span>，在这里两个进程的时间一样，所以运行的时间为53.3min。</p>
<ol start="8" type="1">
<li><h5 id="考虑一个6级多道程序系统内存中可同时容纳6个程序假设每个进程的io等待占40那么cpu的利用率是多少">考虑一个6级多道程序系统（内存中可同时容纳6个程序）。假设每个进程的I/O等待占40%，那么CPU的利用率是多少？</h5></li>
</ol>
<p>答： <span class="math display">$$
CPU_总=1-p^6=1-0.004096=0.995904,CPU_{每个}\frac{0.995904}{6}=0.16598
$$</span></p>
<ol start="9" type="1">
<li><h5 id="假设要从互联网上下载一个2gb大小的文件文件的内容可从一组镜像服务器获得每个服务器可以传输文件的一部分假设每个传输请求给定起始字节和结束字节如何利用多线程优化下载时间">假设要从互联网上下载一个2GB大小的文件，文件的内容可从一组镜像服务器获得，每个服务器可以传输文件的一部分。假设每个传输请求给定起始字节和结束字节。如何利用多线程优化下载时间？</h5></li>
</ol>
<p>答：客户机进程可以创建单独的线程；每个线程可以从一个镜像服务器获取文件的不同部分。这有助于减少停机时间。当然，所有线程都共享一个网络链接。当线程数量变得非常大时，此链接可能成为瓶颈。</p>
<ol start="10" type="1">
<li><h5 id="为什么下图的模型不适合用于内存中使用高速缓存的文件服务器每个进程可以有自己的高速缓存吗">为什么下图的模型不适合用于内存中使用高速缓存的文件服务器？每个进程可以有自己的高速缓存吗？</h5></li>
</ol>
<p><img src="3.jpg" /></p>
<p>答：要牢记进程和线程在很多方面是类似的，线程可以理解为轻量级进程。但是最重要的区别是<strong>进程共享存储空间</strong>，共享存储空间说明他们操作的文件是一样的，所以将文件存于高速缓存是可以的。但是进程不同，操作的文件是不一样的，如果将其文件存于同一个缓存中，很可能前一个进程的文件就会被后一个进程的文件所覆盖。</p>
<hr />
<ol start="11" type="1">
<li><h5 id="当一个多线程进程创建子进程时如果子进程复制父进程的所有线程就会出现问题假如父进程中有一个线程在等待键盘输入那么当子进程复制父进程的时候那么也会复制一个正在等待的等待键盘输入的子进程那么当键盘输入的时候父进程和子进程都会各有一个这种问题在单线程进程中也会发生吗">当一个多线程进程创建子进程时，如果子进程复制父进程的所有线程，就会出现问题：假如父进程中有一个线程在等待键盘输入，那么当子进程复制父进程的时候，那么也会复制一个正在等待的等待键盘输入的子进程，那么当键盘输入的时候，父进程和子进程都会各有一个。这种问题在单线程进程中也会发生吗？</h5></li>
</ol>
<p>答：不会。如果单线程进程在键盘上阻塞，就不能创建子进程。（而多线程进程在一个线程阻塞时可以运行另一个线程，整个进程不会因此被阻塞。）</p>
<ol start="12" type="1">
<li><h5 id="下图给了一个多线程web服务器如果读取文件只能使用阻塞的read系统调用那么web服务器应该使用用户级线程还是内核级线程">下图给了一个多线程Web服务器。如果读取文件只能使用阻塞的read系统调用，那么Web服务器应该使用用户级线程还是内核级线程？</h5></li>
</ol>
<p><img src="4.jpg" /></p>
<p>答：当工作线程从磁盘读取Web页时，它就会被阻塞。如果使用用户级线程，该动作将阻塞整个进程，而破坏多线程的价值。这就是使用内核线程的原因：某些线程的阻塞不会影响到其他线程。</p>
<ol start="13" type="1">
<li><h5 id="在本章中我们介绍了多线程web服务器说明它比单线程服务器和有限状态机服务器更好的原因存在单线程服务器更好一些的情形吗请举例">在本章中，我们介绍了多线程Web服务器，说明它比单线程服务器和有限状态机服务器更好的原因。存在单线程服务器更好一些的情形吗？请举例。</h5></li>
</ol>
<table>
<thead>
<tr class="header">
<th>模型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>多线程</td>
<td>并行性、阻塞系统调用</td>
</tr>
<tr class="even">
<td>单线程进程</td>
<td>无并行性、阻塞系统调用</td>
</tr>
<tr class="odd">
<td>有限状态机</td>
<td>并行性、非阻塞系统调用、中断</td>
</tr>
</tbody>
</table>
<p>答：多线程，即可以并行执行多种工作，CPU的利用率高，而单线程进程和有限状态机在一个时刻只能执行一种工作，在切换线程的时候会造成I/O等待。比如有数据需要从web服务器输入输出，如果是多线程，那么可以在一个进程的情况下，一个线程实现数据的读入，一个处理线程和一个输出线程，这样相当于一个人打三份工，虽然累，但是不需要来回切换，一直在做。如果是单线程，那么需要不断切换，相当于几个人干不同的活，但是在交接的时候需要等待时间。这时候就没有在工作 。CPU就闲置了。</p>
<ol start="14" type="1">
<li><h5 id="既然计算机中只有一套寄存器为什么在图中的寄存器集合是按每个线程中列出而不是按每个进程列出">既然计算机中只有一套寄存器，为什么在图中的寄存器集合是按每个线程中列出而不是按每个进程列出。</h5></li>
</ol>
<p><img src="5.jpg" /></p>
<p>答：当一个线程停止时，它在寄存器中有值。它们必须被保存，就像进程停止时，必须保存寄存器。多线程和多进程没有什么不同，所以每个线程需要自己的寄存器保存区。</p>
<ol start="15" type="1">
<li><h5 id="在没有时钟中断的系统中一个线程放弃cpu后可能再也不会获得cpu资源那么为什么线程还要通过调用thread_yield自愿放弃cpu">在没有时钟中断的系统中，一个线程放弃CPU后可能再也不会获得CPU资源，那么为什么线程还要通过调用thread_yield自愿放弃CPU？</h5></li>
</ol>
<p>答：进程中的线程合作。它们彼此不敌对。如果应用程序需要阻塞以运行得更好，那么一个线程可以调用thread_yield自愿放弃CPU。毕竟，同一个进程中的线程的全部代码通常是一个程序员写的。</p>
<hr />
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式(一)</title>
    <url>/2020/03/17/%E6%9D%82/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="正则表达式一">正则表达式(一)</h1>
<h2 id="元字符">元字符</h2>
<p>元字符（metacharacters）是按照一定规则限制表示的字符。</p>
<ol type="1">
<li><p><code>.</code>匹配所有字符</p></li>
<li><p><code>[]</code>匹配方括号内的所有字符,这个字符按照原样,即使是具有特殊意义的字符,如’,$,&gt;,+’等都是保持字符本意<code>\-</code>除外</p></li>
<li><p><code>[^c1c2]c3c4</code>不匹配’c1,c2’,即不带有c1,c2的c3c4字符串</p></li>
<li><p><code>[c1-c2]</code>匹配c1到c2之间的所有字符</p></li>
<li><p><code>\w</code>匹配任意单个数字，字符串或者下划线，等价于<code>[a-zA-Z_1-9]</code>，<code>\w*</code>匹配多个连续字符<code>\w{N}</code>匹配N个连续字符</p></li>
</ol>
<p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">OriginStr = <span class="string">&#x27;spain remain contain aint retain &#x27;</span>;</span><br><span class="line">AnsStr = regexp(OriginStr,<span class="string">&#x27;\w*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);</span><br><span class="line">PosStr = regexp(OriginStr,<span class="string">&#x27;\w*&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">PosStr =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>     <span class="number">7</span>    <span class="number">14</span>    <span class="number">22</span>    <span class="number">27</span>    <span class="number">33</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; AnsStr</span><br><span class="line"></span><br><span class="line">AnsStr =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;spain&#x27;</span>&#125;    &#123;<span class="string">&#x27;remain&#x27;</span>&#125;    &#123;<span class="string">&#x27;contain&#x27;</span>&#125;    &#123;<span class="string">&#x27;aint&#x27;</span>&#125;    &#123;<span class="string">&#x27;retain&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这个得到的是所有的匹配。而且对于语句<code>regexp(OriginStr,MatchStr,'option')</code>，如果不加<code>option</code>的话，就是得到匹配的一个字符的位置，如果加上<code>option</code>为<code>match</code>的话，就是得到匹配的值。</p>
<p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">OriginStr = <span class="string">&#x27;spain remain contain aint retain &#x27;</span>;</span><br><span class="line">AnsStr = regexp(OriginStr,<span class="string">&#x27;\w* ain&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; AnsStr</span><br><span class="line"></span><br><span class="line">AnsStr =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;contain ain&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，AnsStr输出的<code>contain ain</code>，即匹配<code>ain</code>的前缀都包括的一串字符串。</p>
<ol start="6" type="1">
<li><code>\W</code>是匹配<code>\w</code>的补集，<code>\W*</code>跟<code>\w*</code>含义一致<code>\W{N}</code>和<code>\w{N}</code>含义一致。</li>
<li><code>\s</code>等价于<code>[ \f\t\r\n\v]</code>，匹配空白字符</li>
<li><code>\S</code>等价于<code>[^\f\t\r\n\v]</code>匹配非空白字符 tips：小写字母和大写字母的含义往往是补集的关系</li>
<li><code>\d</code>匹配单个十进制数<code>\d*</code>匹配多个 tips<code>*</code>匹配多个</li>
<li><code>D</code>是<code>\d</code>的补集，即匹配除了数字以外的所有字符，等价于<code>[^\d]</code></li>
<li><code>\oN</code> 和<code>\o{N}</code>匹配八进制数N</li>
<li><code>\xN</code>匹配<code>\x{N}</code>匹配十六进制数N</li>
</ol>
<h2 id="表达式">表达式</h2>
<p><code>expr</code>，表达式，这个也就是对于一串字符串，即<code>xp</code>=<code>x&amp;p</code>，<code>[xp]</code>=<code>x|p</code>，即不加<code>[]</code>是且关系，加了<code>[]</code>是或关系，表达式是限定符前面构成的所有字符构成的匹配字符串。</p>
<h2 id="转义字符">转义字符</h2>
<p><code>char(10)</code>=<code>\n</code>，即回车。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">str = [<span class="string">&#x27;some&#x27;</span>,char(<span class="number">10</span>),<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">regexp(str,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">regexp(str,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;match&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">str =</span><br><span class="line"> <span class="string">&#x27;some</span></span><br><span class="line"><span class="string">  text&#x27;</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line"> &#123;<span class="string">&#x27;?&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">转义字符</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>\a</code></td>
<td style="text-align: center;">警告</td>
<td style="text-align: center;"><code>char(7)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\b</code></td>
<td style="text-align: center;">退格</td>
<td style="text-align: center;"><code>char(8)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>\f</code></td>
<td style="text-align: center;">换页符</td>
<td style="text-align: center;"><code>char(12)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\n</code></td>
<td style="text-align: center;">换行符</td>
<td style="text-align: center;"><code>char(10)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>\r</code></td>
<td style="text-align: center;">回车</td>
<td style="text-align: center;"><code>char(13)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\t</code></td>
<td style="text-align: center;">水平制表符</td>
<td style="text-align: center;"><code>char(9)</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>\v</code></td>
<td style="text-align: center;">垂直制表符</td>
<td style="text-align: center;"><code>char(11)</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\char</code></td>
<td style="text-align: center;">任意特殊字符</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h2 id="限定符">限定符</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">限定符</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">expr *</td>
<td style="text-align: center;">多次expr：0~∞</td>
</tr>
<tr class="even">
<td style="text-align: center;">expr ?</td>
<td style="text-align: center;">一次expr：0~1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr +</td>
<td style="text-align: center;">一次到多次expr：1~∞</td>
</tr>
<tr class="even">
<td style="text-align: center;">expr{m,n}</td>
<td style="text-align: center;">m到n次expr：m~n</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr{m,}</td>
<td style="text-align: center;">大于等于m次expr：m~∞</td>
</tr>
<tr class="even">
<td style="text-align: center;">expr{m}</td>
<td style="text-align: center;">m次expr：=m</td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>expr*</code>代表匹配0次或者多次，与任意多个字符匹配</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;12--asdf--45dfg&#x27;</span>,<span class="string">&#x27;\w*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;12&#x27;</span>&#125;    &#123;<span class="string">&#x27;asdf&#x27;</span>&#125;    &#123;<span class="string">&#x27;45dfg&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expr?</code>代表至多匹配1次</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;12--asdf--45dfg&#x27;</span>,<span class="string">&#x27;\w?&#x27;</span>,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">11</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;1&#x27;</span>&#125;    &#123;<span class="string">&#x27;2&#x27;</span>&#125;    &#123;<span class="string">&#x27;a&#x27;</span>&#125;    &#123;<span class="string">&#x27;s&#x27;</span>&#125;    &#123;<span class="string">&#x27;d&#x27;</span>&#125;    &#123;<span class="string">&#x27;f&#x27;</span>&#125;    &#123;<span class="string">&#x27;4&#x27;</span>&#125;    &#123;<span class="string">&#x27;5&#x27;</span>&#125;    &#123;<span class="string">&#x27;d&#x27;</span>&#125;    &#123;<span class="string">&#x27;f&#x27;</span>&#125;    &#123;<span class="string">&#x27;g&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expr+</code>匹配一次或者连续多次</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;12--asdf--45dfg&#x27;</span>,<span class="string">&#x27;\w+&#x27;</span>,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;12&#x27;</span>&#125;    &#123;<span class="string">&#x27;asdf&#x27;</span>&#125;    &#123;<span class="string">&#x27;45dfg&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expr{m,n}</code>匹配m~n次，<code>{0,1}</code>=<code>'?'</code></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;12--asdf--45dfg&#x27;</span>,<span class="string">&#x27;\w&#123;1,3&#125;&#x27;</span>,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">5</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;12&#x27;</span>&#125;    &#123;<span class="string">&#x27;asd&#x27;</span>&#125;    &#123;<span class="string">&#x27;f&#x27;</span>&#125;    &#123;<span class="string">&#x27;45d&#x27;</span>&#125;    &#123;<span class="string">&#x27;fg&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>expr{m,}</code>匹配≥m次，<code>{0,}</code>=<code>'*'</code>;<code>{1,}</code>=<code>'+'</code></p></li>
<li><p><code>expr{n}</code>匹配n次，<code>n</code>=<code>{n,n}</code></p></li>
</ul>
<h2 id="模式">模式</h2>
<p>表达式+限定词=模式</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 33%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">表达式+限定词</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">expr q</td>
<td style="text-align: center;">积极表达式：与尽可能多的expr匹配</td>
<td style="text-align: center;">给定文本 <code>&lt;tr&gt;&lt;td&gt;&lt;p&gt;text&lt;/p&gt;&lt;/td&gt;</code>，表达式 <code>&lt;/?t.*&gt;</code>与介于 <code>&lt;tr</code> 和 <code>/td&gt;</code> 之间的所有字符匹配：</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;tr&gt;&lt;td&gt;&lt;p&gt;text&lt;/p&gt;&lt;/td&gt;</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr q？</td>
<td style="text-align: center;">消极表达式：与所需尽可能少的expr匹配</td>
<td style="text-align: center;">给定文本<code>&lt;tr&gt;&lt;td&gt;&lt;p&gt;text&lt;/p&gt;&lt;/td&gt;</code>，表达式 <code>&lt;/?t.*?&gt;</code> 在第一次出现右尖括号 (&gt;) 时结束每个匹配项：</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;tr&gt;</code> <code>&lt;td&gt;</code> <code>&lt;/td&gt;</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr q+</td>
<td style="text-align: center;">主动表达式：最大程度的匹配</td>
<td style="text-align: center;">给定文本 <code>&lt;tr&gt;&lt;td&gt;&lt;p&gt;text&lt;/p&gt;&lt;/td&gt;</code>，表达式 <code>&lt;/?t.*+&gt;</code> 不返回任何匹配项，这是因为右尖括号是使用 <code>.*</code> 捕获的且不进行重新扫描。<br />空<code>{}</code></td>
</tr>
</tbody>
</table>
<ul>
<li><p>积极表达式：碰到符合条件的，就从开始处匹配到结尾，格式为<code>expr q</code>，q为任意限定符。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>, <span class="string">&#x27;&lt;/?t.*&gt;&#x27;</span> ,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消极模式：只要匹配就立即停止搜索，进行下一次匹配，格式为<code>expr q?</code>如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>, <span class="string">&#x27;&lt;/?t.*?&gt;&#x27;</span> ,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">3</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;&lt;txr&gt;&#x27;</span>&#125;    &#123;<span class="string">&#x27;&lt;txd&gt;&#x27;</span>&#125;    &#123;<span class="string">&#x27;&lt;/tpd&gt;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主动模式：最大程度的匹配，格式为<code>expr q+</code>，如</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; regexp(<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>, <span class="string">&#x27;&lt;/?t.*+&gt;&#x27;</span> ,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  空的 <span class="number">0</span>×<span class="number">0</span> cell 数组</span><br><span class="line">  </span><br><span class="line">&gt;&gt; regexp(<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>, <span class="string">&#x27;&lt;t.*+&#x27;</span> ,<span class="string">&#x27;match&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>×<span class="number">1</span> cell 数组</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">&#x27;&lt;txr&gt;&lt;txd&gt;&lt;p&gt;text&lt;/p&gt;&lt;/tpd&gt;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>主动模式较难理解，我觉得可以这样看，他就就是直接把检测到开头的<code>&lt;</code>字符就开始匹配，知道匹配到无可匹配也就是<code>&gt;</code>为止，这时候才到达匹配模式里面的<code>?</code>部分，所以如果<code>?</code>后面有任何的字符，这个匹配出来的都是空字符串。</p>
<p>这个匹配模式跟匹配出来的结果就是两个，一个是最后一位是<code>？</code>,这时候等价于<code>expr *</code>，最后一位不是<code>?</code>，这时候结果是空字符串。</p>
<h2 id="操作符的优先级">操作符的优先级</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">\</td>
<td style="text-align: center;">转义符</td>
</tr>
<tr class="even">
<td style="text-align: center;">(), (?:), (?=), []</td>
<td style="text-align: center;">圆括号和方括号</td>
</tr>
<tr class="odd">
<td style="text-align: center;">*, +, ?, {n}, {n,}, {n,m}</td>
<td style="text-align: center;">限定符</td>
</tr>
<tr class="even">
<td style="text-align: center;">^, $, </td>
<td style="text-align: center;">位置和顺序</td>
</tr>
<tr class="odd">
<td style="text-align: center;">|</td>
<td style="text-align: center;">“或”操作</td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>正则</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>现代操作系统-内存管理1</title>
    <url>/2018/11/11/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861/</url>
    <content><![CDATA[<h1 id="现代操作系统-内存管理1">现代操作系统-内存管理1</h1>
<h2 id="空闲内存的管理">空闲内存的管理</h2>
<p>动态分配内存的时候（在进程需要动态扩张的时候），需要操作系统对其进行管理。</p>
<p><img src="内存存储管理1.jpg" /></p>
<ul>
<li><p>使用位图的存储器管理</p>
<p>从上图可以看出，在内存中运行有A，B，C，D，E五个进程，阴影部分为空闲区。b)是对应的位图，首先堆内存进行分段，1表示有进程在运行，0表示处于空闲区。c)是空闲区链表的存储方式，其中P表示有进程在运行，0，5这样的数字说的是运行的段是从0到5。 使用位图存储器就需要合适的选取刻度值，即对于整个内存的存储，如果刻度选的过小，就会导致位存储器过大，那么在查找和存储就会造成困扰。</p></li>
<li><p>使用链表的存储器管理 如果使用一种链表式的存储，如c)所示，那么会显著减小存储，不这是一个单向链表，在查找的时候会比较慢。在进程状态改变的时候（如从内存中被导出等）就需要进行相应的链表操作。</p></li>
</ul>
<h2 id="覆盖与交换">覆盖与交换</h2>
<p>覆盖与交换技术都是因为程序实际的需求的内存大小大于物理内存的大小产生的解决方案。他们都是与外存（如磁盘、硬盘等）进行程序与数据的交换。但是区别是交换是由操作系统完成的，交换的最小单元是程序，覆盖是由编程语言或者程序员完成的，导入导出的最小单元是程序中的模块，需要有相应的运行时支持。所以可以发现，交换的单个容量相对较大，并且不需要程序员过多的操心，覆盖的单个的容量相对较小，以程序的模块为单位。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">技术</th>
<th style="text-align: center;">优点</th>
<th style="text-align: center;">缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">交换技术</td>
<td style="text-align: center;">由操作系统完成，不需要程序员操心，自动化</td>
<td style="text-align: center;">交换力度过大，可能导致交换产生的开销过大</td>
</tr>
<tr class="even">
<td style="text-align: center;">覆盖技术</td>
<td style="text-align: center;">交换力度小，产生的开销小</td>
<td style="text-align: center;">由程序员完成，不方便且易出错</td>
</tr>
</tbody>
</table>
<h3 id="交换技术">交换技术</h3>
<h4 id="交换过程">交换过程</h4>
<p><img src="操作系统内存交换技术.png" /></p>
<p>上图所示就是操作系统的内存交换过程，首先知道交换技术是进程在内存和外存之间的导入导出操作，主要原因是内存的容量不够，其中的A，B，C，D均为进程。</p>
<ol type="1">
<li>运行进程A，进程A的程序和数据从头开始放</li>
<li>之后运行进程B，此时进程A处于就绪状态，依旧存在于内存之中</li>
<li>加载C进程，和前面的方法类似</li>
<li>将进程A导出到外存，留下A部分的空闲区，也叫做洞</li>
<li>加载D进程，这时候还是从头开始检测，发现空闲区可以容纳进程D</li>
<li>杀死进程B</li>
<li>从外存导入进程A，此时是空闲区刚好容纳A进程的大小</li>
</ol>
<h4 id="内存紧缩">内存紧缩</h4>
<p>上述就是交换过程，其中有一个问题，那就是一个进程被导出之后留下了空闲区，空闲区的存在可能容纳不了下一个加载进程的大小。</p>
<p><img src="操作系统内存紧缩.png" /></p>
<p>这时候，就需要将进程B与进程A挪一挪，将其变成下面的状态。</p>
<p><img src="操作系统内存紧缩2.png" /></p>
<p>这样的拷贝移动的过程称为内存紧缩。当然这种技术很不错，但是有一个问题，那就是开销，之前说到交换技术的最大的缺点是开销问题，开销是因为进程过于庞大，频繁移动他们需要很大的资源。</p>
<blockquote>
<p>例如，一台16GB内存的计算机可以每8ns复制8个字节，那么其紧缩全部内存需要花费16s</p>
</blockquote>
<p>这其实是很长的时间了，可以想象，经常使用内存紧缩是不合适的。</p>
<h4 id="动态分配">动态分配</h4>
<p>前面说到的进程好像就是一个进程导入内存就可以运行了，但是在很多情况下，进程需要接收输入，并且会进行一些处理，如果是数据增长，那么解决方法较为简单，因为数据位于数据段，可以直接由编程语言从堆中分配内存，还有一种情况是进程空间需要扩大，那么就需要操作系统在导入进程的时候预留一部分空间给进程，以应对其扩张。分配的大小是由操作系统需要的大小分配，即进程中所带的信息决定的，当其意外的超出了规定的大小并且磁盘上也没有多余的交换空间之后，那么该进程就会被挂起直到有一些空闲的空间。</p>
<h3 id="覆盖技术">覆盖技术</h3>
<blockquote>
<p>一个典型的SATA磁盘的峰值传输率高达每秒几百兆，这就意味着需要好几秒才能换出或者换入一个1GB的程序。</p>
</blockquote>
<p>所以交换技术的开销问题确实是一个很致命的点。所以就出现了将程序分割，称为模块，将模块进行交换的技术，即覆盖技术</p>
<h2 id="虚拟内存">虚拟内存</h2>
<p>从上面的交换技术和覆盖技术中可以看出，他们各自互补各自的优缺点。如果有一种技术，能够像覆盖那样导入导出小的模块，又能像交换那样由操作系统完成就优势互补了，这就是虚拟内存技术产生的原因了。</p>
<p>虚拟内存的思想是和覆盖类似，只不过将模块变成了页，页是对于程序的等大小的划分，这些页被映射到物理内存，并且由硬件直接运行。</p>
<blockquote>
<p>从某个角度来说，虚拟内存是对基址寄存器和界限寄存器的一种综合。</p>
</blockquote>
<p>由于涉及操作系统对页的自动操作，所以对于页的讨论还很多，留在下一篇再说。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>SSD学习（一）</title>
    <url>/2024/01/14/%E7%A1%AC%E7%9B%98/SSD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>存储</tag>
        <tag>SSD</tag>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>编译链接浅析</title>
    <url>/2019/02/01/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引子">引子</h2>
<p>先来看两段代码，这两段代码很简单。<code>main</code>是主函数，调用<code>sum</code>进行求和，其中<code>sum</code>函数参数是指针类型的，也就是说在<code>sum</code>函数进行改变会引起原来的值的改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">-2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">-5</span>;</span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span>* b;</span><br><span class="line">    a = &amp;k;</span><br><span class="line">    b = &amp;j;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;k+j=&quot;</span>&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;k=&quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="string">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sum.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="built_in">abs</span>(*a);*b=<span class="built_in">abs</span>(*b);</span><br><span class="line">    <span class="keyword">return</span> (*a+*b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在<code>Linux</code>上面执行出结果，那么打上下面的代码就可以了： <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ main.c sum.cpp <span class="literal">-o</span> a.out</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure> 输出的结果是： <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">k+j=<span class="number">7</span></span><br><span class="line">k=<span class="number">2</span>	j=<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到运行正确了，这个结果也是预料之中的，k 变成了 2，j 变成了 5，这个是在<code>sum</code>里面被改变了值，也会影响到原址的值。</p>
<h2 id="程序到可执行文件">程序到可执行文件</h2>
<p>程序到可执行文件需要经过几个阶段：</p>
<h3 id="预编译阶段">预编译阶段</h3>
<p>预编译阶段是把原始的代码文件的需要预编译头加进来，即对于<code>#include</code>的文件进行原样复制，<code>#include</code>文件可以由命令<code>locate</code>得到 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~/VSCode/CSAPP深入理解计算机系统<span class="variable">$</span> locate iostream</span><br><span class="line">/usr/include/c++/<span class="number">7</span>/iostream</span><br><span class="line">/usr/lib/x86_64<span class="literal">-linux-gnu</span>/libboost_iostreams.so.<span class="number">1.65</span>.<span class="number">1</span></span><br><span class="line">/usr/share/doc/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span></span><br><span class="line">/usr/share/doc/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>/copyright</span><br><span class="line">/usr/share/lintian/overrides/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span></span><br><span class="line">/var/lib/dpkg/info/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>:amd64.shlibs</span><br><span class="line">/var/lib/dpkg/info/libboost<span class="literal">-iostreams1</span>.<span class="number">65.1</span>:amd64.triggers</span><br></pre></td></tr></table></figure> 或者是对于C语言的库使用<code>man</code> <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">man</span> stdio</span><br></pre></td></tr></table></figure> <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">STDIO(<span class="number">3</span>)                   Linux Programmer<span class="string">&#x27;s Manual                  STDIO(3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       stdio - standard input/output library functions</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       FILE *stdin;</span></span><br><span class="line"><span class="string">       FILE *stdout;</span></span><br><span class="line"><span class="string">       FILE *stderr;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br></pre></td></tr></table></figure> 预编译命令如下： <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ <span class="literal">-E</span> main.cpp <span class="literal">-o</span> main.i</span><br><span class="line"><span class="built_in">cat</span> main.i</span><br></pre></td></tr></table></figure> 这个命令是把<code>main.cpp</code><span class="math inline">→</span><code>main.i</code>。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部分代码，在Linux试一下就知道</span></span><br><span class="line"><span class="keyword">namespace</span> std __attribute__ ((__visibility__ (<span class="string">&quot;default&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"># <span class="number">60</span> <span class="string">&quot;/usr/include/c++/7/iostream&quot;</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">extern</span> istream cin;</span><br><span class="line">  <span class="keyword">extern</span> ostream cout;</span><br><span class="line">  <span class="keyword">extern</span> ostream cerr;</span><br><span class="line">  <span class="keyword">extern</span> ostream clog;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> wistream wcin;</span><br><span class="line">  <span class="keyword">extern</span> wostream wcout;</span><br><span class="line">  <span class="keyword">extern</span> wostream wcerr;</span><br><span class="line">  <span class="keyword">extern</span> wostream wclog;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> ios_base::Init __ioinit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span> <span class="string">&quot;main.cpp&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">-2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">-5</span>;</span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span>* b;</span><br><span class="line">    a = &amp;k;</span><br><span class="line">    b = &amp;j;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;k+j=&quot;</span>&lt;&lt;<span class="built_in">sum</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;k=&quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="string">&quot;j=&quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以看到，这就是把<code>#include</code>里面的东西原样复制到<code>main.cpp</code>代码文件里面，整合到一起，就叫做预编译过程。 ### C++编译阶段 C++编译阶段就是把预编译好的文件编译成汇编代码，个人觉得这个过程跟翻译差不多，把一种语言翻译成另一种语言，命令如下。 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ <span class="literal">-S</span> main.i</span><br><span class="line"><span class="built_in">cat</span> main.s</span><br></pre></td></tr></table></figure> 上面的<code>g++</code>命令默认会有<code>-o main.s</code>添加上，即会产生<code>main.s</code>文件产生。 产生的<code>main.s</code>文件如下，由于太长，截取了部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;main.cpp&quot;</span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">	.type	_ZStL19piecewise_construct, @object</span><br><span class="line">	.size	_ZStL19piecewise_construct, 1</span><br><span class="line">_ZStL19piecewise_construct:</span><br><span class="line">	.zero	1</span><br><span class="line">	.local	_ZStL8__ioinit</span><br><span class="line">	.comm	_ZStL8__ioinit,1,1</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;k+j=&quot;</span><br><span class="line">.LC1:</span><br><span class="line">	.string	&quot;k=&quot;</span><br><span class="line">.LC2:</span><br><span class="line">	.string	&quot;\t&quot;</span><br><span class="line">.LC3:</span><br><span class="line">	.string	&quot;j=&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1493:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	pushq	%rbx</span><br><span class="line">	subq	$56, %rsp</span><br><span class="line">	.cfi_offset 3, -24</span><br><span class="line">	movl	%edi, -52(%rbp)</span><br><span class="line">	movq	%rsi, -64(%rbp)</span><br><span class="line">	movq	%fs:40, %rax</span><br><span class="line">	movq	%rax, -24(%rbp)</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	movl	$-2, -48(%rbp)</span><br><span class="line">	movl	$-5, -44(%rbp)</span><br><span class="line">	leaq	-48(%rbp), %rax</span><br><span class="line">	movq	%rax, -40(%rbp)</span><br><span class="line">	leaq	-44(%rbp), %rax</span><br><span class="line">	movq	%rax, -32(%rbp)</span><br><span class="line">	leaq	.LC0(%rip), %rsi</span><br><span class="line">	leaq	_ZSt4cout(%rip), %rdi</span><br><span class="line">	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT</span><br><span class="line">	movq	%rax, %rbx</span><br><span class="line">	movq	-32(%rbp), %rdx</span><br><span class="line">	movq	-40(%rbp), %rax</span><br><span class="line">	movq	%rdx, %rsi</span><br><span class="line">	movq	%rax, %rdi</span><br><span class="line">	call	_Z3sumPiS_@PLT</span><br><span class="line">	movl	%eax, %esi</span><br><span class="line">	movq	%rbx, %rdi</span><br><span class="line">	call	_ZNSolsEi@PLT</span><br><span class="line">	movq	%rax, %rdx</span><br><span class="line">	movq	</span><br></pre></td></tr></table></figure>
<p>从上面的代码看出，这是个汇编代码，也就完成了<code>main.i</code><span class="math inline">→</span><code>main.s</code>的转化。</p>
<h3 id="汇编代码转化为rof文件">汇编代码转化为rof文件</h3>
<p><code>rof</code>是relocatable object file的简称，称为可重定向目标文件。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ <span class="literal">-c</span> main.s</span><br></pre></td></tr></table></figure>
<p>输出的文件为<code>main.o</code>，这个文件不是文本文件，是一个二进制文件。</p>
<blockquote>
<p>文本文件：由ASCII码组成的文件，可以由文本编辑器直接打开 二进制文件：除了文本文件之外的所有文件，如图片格式文件就属于二进制文件，这种文件需要专门的解码软件打开，如果使用文本编辑器打开就是乱码的。</p>
</blockquote>
<h3 id="链接器链接生成eof">链接器链接生成eof</h3>
<p><code>eof</code>是executable object file的简称，称为可执行目标文件。</p>
<p>按照前面的步骤（预编译<span class="math inline">→</span>C++编译<span class="math inline"> → ​</span>rof文件生成）得到<code>sum.o</code>文件。然后进行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ main.o sum.o</span><br></pre></td></tr></table></figure>
<p>这时候会产生一个新的文件为<code>a.out</code>，这个名字可以自己取，也就是把默认的那个语句加上，如： <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">g++ main.o sum.o <span class="literal">-o</span> main.out</span><br></pre></td></tr></table></figure> 当然，在 Linux 里面文件的后缀名是不重要的，<code>.x</code>也可，只不过<code>.out</code>是在Unix操作系统上第一个实现的可执行文件的后缀名，就保留了下来。</p>
<p>之后就运行： <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure> 得到结果 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">k+j=<span class="number">7</span></span><br><span class="line">k=<span class="number">2</span>	j=<span class="number">5</span></span><br></pre></td></tr></table></figure> 这个结果跟之前的一致。执行命令的时候，Linux 会使用它的加载器将可执行文件<code>a.out</code>的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h3 id="小结">小结</h3>
<figure>
<img src="文件编译过程.png" alt="总结" /><figcaption aria-hidden="true">总结</figcaption>
</figure>
<h2 id="可执行文件格式分析">可执行文件格式分析</h2>
]]></content>
      <tags>
        <tag>编译</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP协议分析</title>
    <url>/2024/01/14/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/DHCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="协议流程">协议流程</h1>
<h2 id="直接dhcp">直接DHCP</h2>
<p>DHCP允许系统管理员在服务器上集中定义设备配置，当这些设备启动时，可以请求这些配置参数。</p>
<p>当客户端发送广播<strong>DISCOVER</strong>包时，DHCP 进程开始，本质上是说“外面有任何 DHCP 服务器吗?” 这就是我正在寻找的信息。” 然后 DHCP 服务器回复一个包含所有信息的<strong>OFFER</strong>报文。 客户机用一个<strong>REQUEST</strong>包进行响应，这个包的名称似乎很奇怪——实际上，客户机只是通过确认的方式，发送它刚刚从服务器返回的信息。 然后，服务器发送最后的<strong>ACKNOWLEDGEMENT</strong>数据包，同样带有相同的信息，再次确认它。</p>
<p>这是通常称为<strong>DORA</strong>序列(<strong>发现、提供、请求、确认</strong>)，通常是这样描述的:</p>
<p><img src="dhcp原理.jpg" /></p>
<p>因为这些都是 UDP 数据包，请记住 UDP 协议中没有任何会话信息，那么是什么将这四个数据包绑定到一个“会话”中呢? 因此，最初的 Discover 报文有一个事务 ID，在随后的三个报文中匹配- Wireshark 跟踪如下所示:</p>
<p><img src="dhcp报文示例1.jpg" /></p>
<p>实际上，客户端直到第四个包才有一个地址，所以 Discover 和 Request 包是从 IP 为<code>0.0.0.0</code>的客户端的 MAC 地址到<code>255.255.255.255</code>的广播地址(即到整个局域网)。</p>
<h2 id="中继dhcp">中继DHCP</h2>
<p>在许多公司网络中，服务器在它们自己的子网中——分离服务器和工作站是相当普遍的做法。 这种情况下 DHCP 顺序如何工作? DORA 序列的前三个数据包被发送到广播地址，因此它们只能到达同一 VLAN 上的其他主机。</p>
<p>我们通过在客户端子网中的主机上放置一个 DHCP“转发器”或“中继”进程来完成这项工作。 该进程接收本地广播，然后将其以单播形式转发给 DHCP 服务器。 当服务器应答时(以单播方式向转发器主机)，转发器将包“转换”为客户机所期望的广播应答。 几乎总是，这个转发器功能是在客户端子网上的路由器或交换机 IP 地址上完成的——换句话说，接口最终将成为客户端的默认网关。 这个函数在技术上不需要在那个接口上，但它是一个我们知道会在那里的接口，而且这个函数几乎总是可供我们使用。 另外，如果我们将其作为一种不成文的惯例，当我们以后需要更改它时，它将更容易找到该命令! 在 Cisco 路由器或交换机上，这个命令看起来像这样: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">interface VLAN &lt;x&gt;  ip helper-address 10.10.10.10</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>10.10.10.10</code>是我们 DHCP 服务器的 IP 地址。</p>
<p>在操作中，这改变了我们在大多数家庭网络上拥有的简单的广播操作： <img src="dhcp原理2-中继.jpg" /> 这如何修改我们的 DORA 序列? 简单的回答是，它实际上不会修改任何数据包的 DHCP 内容。 它所做的是修改数据包中的上层“IP 地址”字段-路由器和服务器之间修改的数据包有“真实的”源和目的 IP 地址。 但是，客户端看到的包内容保持不变。 如果你深入研究 DHCP 报文，你会发现不管是否有中继，DHCP 客户端的 MAC 地址和 DHCP 服务器的 IP 地址实际上包含在 7 层 DHCP 协议的数据字段中。</p>
<p>现在我们开始为基本配置 DHCP 服务器工作站操作,但在我们到达之前,我们要考虑我们需要的专用设备,如 iphone,<strong>无线访问点</strong>(<strong>WAP), 或者甚至是</strong>预执行环境(PXE)设备，可以从 DHCP 信息加载其整个操作系统。</p>
<h2 id="仿真">仿真</h2>
<h3 id="组网">组网</h3>
<p><img src="Pastedimage20231215004144.png" /></p>
<h3 id="路由设置">路由设置</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;sys</span><br><span class="line">[Huawei]sysname AR1</span><br><span class="line">[AR1]int g0/0/0</span><br><span class="line">[AR1-GigabitEthernet0/0/0]ip adderss 1.1.1.200 24</span><br><span class="line">[AR1]dhcp enable</span><br><span class="line">[AR1]ip pool ip_pool1</span><br><span class="line">[AR1-ip-pool-ip_pool1]network 1.1.1.0 24</span><br><span class="line">[AR1-ip-pool-ip_pool1]gateway-list 1.1.1.200</span><br><span class="line">[AR1-ip-pool-ip_pool1]lease day 3</span><br><span class="line">[AR1]int g0/0/0</span><br><span class="line">[AR1-GigabitEthernet0/0/0]dhcp select global</span><br></pre></td></tr></table></figure>
<p><img src="Pastedimage20231215004416.png" /></p>
<h2 id="抓包">抓包</h2>
<p><img src="Pastedimage20231215005008.png" /></p>
<h3 id="dhcp-discover">dhcp discover</h3>
<p><img src="Pastedimage20231215010535.png" /></p>
<p><img src="Pastedimage20231215010615.png" /></p>
<h3 id="dhcp-offer">dhcp offer</h3>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>主机同网段双ip问题</title>
    <url>/2025/12/21/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E4%B8%BB%E6%9C%BA%E5%90%8C%E7%BD%91%E6%AE%B5%E5%8F%8Cip%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="现象">现象</h1>
<p>因为两个网卡都在同一个网段，所以如果这个时候直接和我们的主机（IP192.168.0.2）进行ping，因为优先级的原因，会导致有一个网卡会无法ping通主机。</p>
<p><img src="ips.png" /> <img src="route.png" /> <img src="ping1.png" /></p>
<h1 id="反向路由检查">反向路由检查</h1>
<p>您可以把这个机制想象成一个严格的“门卫”。当服务器从一个网络接口（比如<code>eth1</code>）收到一个数据包时，这个“门卫”会去查路由表，问：“<strong>要回复这个数据包，我们应该从哪个接口发出去？</strong>”</p>
<ul>
<li><strong>正常情况</strong>：如果查到的最佳出口恰好是数据包进来的接口（<code>eth1</code>），则验证通过，数据包被正常接收处理。</li>
<li><strong>您遇到的情况</strong>：服务器上两个IP在同一LAN，网关可能只在一个接口上（或系统认为只有一个最佳路径）。当数据包从<code>eth1</code>进入，但路由表显示回复它的最佳路径是<code>eth0</code>，这时“门卫”就会拒绝这个数据包，导致ping不通 。关键在于，系统<strong>检查的是“反向路径”是否最优，而非是否可达</strong>​ 。 ## 问题诊断与解决步骤</li>
</ul>
<h4 id="确认-rp_filter-的当前设置">1. 确认 rp_filter 的当前设置</h4>
<p>首先，您需要查看系统当前的反向路由检查设置。在终端中执行以下命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/conf/all/rp_filter</span><br><span class="line">cat /proc/sys/net/ipv4/conf/eth0/rp_filter  # 请将 eth0 替换为您的实际网卡名</span><br><span class="line">cat /proc/sys/net/ipv4/conf/eth1/rp_filter  # 请将 eth1 替换为您的实际网卡名</span><br></pre></td></tr></table></figure> <strong>参数值解读</strong>​ ： - <strong>0</strong>：关闭源地址验证。 - <strong>1</strong>：<strong>严格模式</strong>。只要反向路径不是最佳路径（即使有其他路径可达），数据包也会被丢弃。这通常是问题的根源。 - <strong>2</strong>：<strong>松散模式</strong>。只检查源地址是否可通过任意接口可达，而不要求是最佳路径。这在有多路径的环境中是更安全的选择。</p>
<p>如果这些值被设置为 <code>1</code>（严格模式），那么它很可能就是导致您一个IP不通的原因。 ### 2. 关闭反向路由检查</p>
<p><strong>重要提示</strong>：关闭此功能会降低系统对IP地址欺骗（IP Spoofing）的防御能力 。请确保您的服务器处于受信任的内网环境中。</p>
<p><strong>方法一：临时关闭（重启后失效）</strong></p>
<p>适用于快速验证问题。执行命令： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/eth0/rp_filter</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/eth1/rp_filter</span><br></pre></td></tr></table></figure> <strong>方法二：永久关闭（推荐配置）</strong></p>
<p>通过修改系统配置文件，使设置永久生效。</p>
<ol type="1">
<li>编辑 <code>/etc/sysctl.conf</code>文件： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
<li>在文件末尾添加或修改以下行： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果需要，也可以为每个网卡单独设置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">net.ipv4.conf.eth0.rp_filter = 0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">net.ipv4.conf.eth1.rp_filter = 0</span></span><br></pre></td></tr></table></figure></li>
<li>使用以下命令使配置立即生效： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="折中方案采用松散模式">3. 折中方案：采用松散模式</h3>
<p>如果担心完全关闭的安全风险，折中的办法是启用<strong>松散模式（Loose Mode）</strong>，将值设置为 <code>2</code>。这样既允许了非对称路径的存在（您的包从A进，从B出），又保留了基本的源地址验证 。修改方法同上，只需将配置文件中的值改为2： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter = 2</span><br><span class="line">net.ipv4.conf.default.rp_filter = 2</span><br></pre></td></tr></table></figure></p>
<h2 id="其他可能性">其他可能性</h2>
<p>虽然反向路由检查是最常见的原因，但如果调整后问题依旧，还可以关注以下几点：</p>
<ul>
<li><strong>防火墙规则</strong>：检查 iptables 或 firewalld 是否有规则阻止了特定IP的ICMP请求。</li>
<li><strong>路由表本身</strong>：使用 <code>ip route show</code>或 <code>route -n</code>确认两个IP地址的路由表项是否正确。</li>
<li><strong>ARP问题</strong>：在局域网中，使用 <code>arp -a</code>或 <code>ip neighbour</code>检查ARP表项是否正确 。</li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>问题定位</tag>
      </tags>
  </entry>
  <entry>
    <title>立体角</title>
    <url>/2019/10/14/%E7%AB%8B%E4%BD%93%E8%A7%92%E6%A6%82%E5%BF%B5/%E7%AB%8B%E4%BD%93%E8%A7%92/</url>
    <content><![CDATA[<h1 id="立体角">立体角</h1>
<p>在谈立体角之前，我们先来复习一下球坐标及其面积分。</p>
<h2 id="球面坐标系及积分">球面坐标系及积分</h2>
<h3 id="球坐标系">球坐标系</h3>
<figure>
<img src="sphere1.png" alt="sphere1" /><figcaption aria-hidden="true">sphere1</figcaption>
</figure>
<p>如上图所示，就是一个典型的球坐标系统，在坐标系中的每一点都可以使用<span class="math inline">(<em>ρ</em>,<em>ϕ</em>,<em>θ</em>)</span>来描述，与笛卡尔坐标系之间的转化如下</p>
<p><span class="math display">$$
x=\rho\sin\phi\cos\theta\\
y=\rho\sin\phi\sin\theta\\
z=\cos\phi
$$</span></p>
<p>上式就是球坐标和笛卡尔坐标之间的转化，这个转化很容从图上看出来。</p>
<h3 id="球面积分">球面积分</h3>
<figure>
<img src="sphere3.png" alt="sphere2" /><figcaption aria-hidden="true">sphere2</figcaption>
</figure>
<p>从上图可以看出，面积的微元，长为<span class="math inline"><em>ρ</em><em>d</em><em>ϕ</em></span>，因为这个方向上的长度为<span class="math inline"><em>ρ</em><em>ϕ</em></span>，所以微元为<span class="math inline"><em>ρ</em><em>d</em><em>ϕ</em></span>；宽为<span class="math inline"><em>ρ</em>sin <em>ϕ</em><em>d</em><em>θ</em></span>，这是因为首先要投影到<span class="math inline"><em>x</em><em>y</em></span>平面，在这个平面上的长度为<span class="math inline"><em>ρ</em>sin <em>ϕ</em></span>，从图上可以看出，这个长度也就是宽，所以微元的宽为<span class="math inline"><em>ρ</em>sin <em>ϕ</em><em>d</em><em>ϕ</em></span>。所以球面积分的微元面积<span class="math inline"><em>ρ</em><sup>2</sup>sin <em>ϕ</em><em>d</em><em>ϕ</em><em>d</em><em>θ</em>​</span>。</p>
<ul>
<li>来看几个例子
<ol type="1">
<li><p>球的表面积计算</p>
<figure>
<img src="sphere4.png" alt="shpere4" /><figcaption aria-hidden="true">shpere4</figcaption>
</figure>
<p>表面积的求法，就是对于微元而言，<span class="math inline"><em>ϕ</em></span>的取值为<span class="math inline">0</span>到<span class="math inline">2<em>π</em></span>，<span class="math inline"><em>θ</em></span>的取值也是<span class="math inline">0</span>到<span class="math inline">2<em>π</em></span>。<span class="math inline"><em>ρ</em></span>就是球的半径。 所以微元<span class="math inline"><em>d</em><em>S</em> = <em>ρ</em><sup>2</sup>sin <em>ϕ</em><em>d</em><em>ϕ</em><em>d</em><em>θ</em></span>。表面积的求法如下： <span class="math display"><em>S</em> = ∫<sub>0</sub><sup>2<em>π</em></sup><em>d</em><em>θ</em>∫<sub>0</sub><sup>2<em>π</em></sup><em>ρ</em><sup>2</sup>sin <em>ϕ</em><em>d</em><em>ϕ</em></span> <span class="math inline"> → 2<em>π</em><em>ρ</em><sup>2</sup>(−cos<em>θ</em>)|<sub>0</sub><sup>2<em>π</em></sup> = 4<em>π</em><em>ρ</em><sup>2</sup>​</span>，这就是很熟悉的圆表面积计算公式了。<span class="math inline"><em>S</em><sub><em>圆</em></sub> = 4<em>π</em><em>r</em><sup>2</sup>​</span>，这个公式应该在高中时候就经常使用了。</p></li>
<li><p>球帽表面积的计算 <img src="1.png" alt="shpere5" /></p></li>
</ol>
蓝色部分就叫做球帽，计算这一部分的表面积。首先面积分的微元跟之前的一样，为<span class="math inline"><em>d</em><em>S</em> = <em>ρ</em><sup>2</sup>sin <em>θ</em><em>ϕ</em><em>d</em><em>ϕ</em><em>d</em><em>θ</em></span>，不过这个图上的角度标的不太一样，那么改变一下，把<span class="math inline"><em>x</em><em>y</em></span>平面的角度设为<span class="math inline"><em>ϕ</em></span>，把与<span class="math inline"><em>z</em></span>轴之间的夹角设为<span class="math inline"><em>α</em></span>。很容易从图上看出，<span class="math inline"><em>ϕ</em> ∈ [0,2<em>ϕ</em>], <em>α</em> ∈ [0,<em>θ</em>]</span>，这边要注意这个<span class="math inline"><em>α</em></span>，它的取值是从<span class="math inline"><em>z</em></span>轴为<span class="math inline">0</span>，到<span class="math inline"><em>x</em><em>y</em></span>平面为<span class="math inline">$\frac{\pi}{2}$</span>。所以其表面积为</li>
</ul>
<p><span class="math display"><em>S</em> = ∫<sub>0</sub><sup>2<em>π</em></sup><em>d</em><em>ϕ</em>∫<sub>0</sub><sup><em>θ</em></sup><em>r</em><sup>2</sup>sin <em>θ</em><em>d</em><em>θ</em></span> ​ <span class="math inline">$\rightarrow 2\pi r^2(-\cos\theta)|^{\theta}_0=2\pi r^2(1-\cos\theta)=2\pi r^2(1-\frac{r-h}{r})=2\pi rh​$</span>，如果<span class="math inline"><em>h</em> = <em>r</em>​</span>，那么求的是半球的面积， 面积<span class="math inline"><em>S</em> = 2<em>π</em><em>r</em><sup>2</sup>​</span>，跟之前的球表面积也对上了。</p>
<hr />
<p>球面坐标复习到这儿，下面就进入正题了。 ## 立体角</p>
<h3 id="角度">角度</h3>
<p>在介绍立体角之前，也先做个铺垫，讲一下角度。</p>
<p><img src="angle1.png" /></p>
<p>如上图所示，平面角，简称角度定义为圆的弧长与半径之间的比值，单位为弧度(<span class="math inline"><em>r</em><em>a</em><em>d</em></span>)。 <span class="math display">$$
\theta=\frac{l}{r}
$$</span></p>
<h3 id="立体角-1">立体角</h3>
<p>参考平面角的定义，立体角的定义为表面积与半径平方的比值，即</p>
<p><span class="math display">$$
\Omega=\frac{S}{r^2}
$$</span></p>
<p>反映的是从该点出发，向球面区域张成的视野大小，是平面角的三维扩展。</p>
<p><img src="angle2.jpg" /></p>
<p>接上面计算的表面积的例子。</p>
<ol type="1">
<li>球的立体角 球的表面积为<span class="math inline"><em>S</em> = 4<em>π</em><em>r</em><sup>2</sup>​</span>，球的半径为<span class="math inline"><em>r</em>​</span>，立体角为<span class="math inline">$\Omega=\frac{S}{r^2}=4\pi​$</span>，这也是最大的立体角。</li>
<li>球帽的立体角 球帽的表面积为<span class="math inline">2<em>π</em><em>r</em><em>h</em></span>，半径为<span class="math inline"><em>r</em></span>，立体角为<span class="math inline">$\Omega=\frac{S}{r^2}=2\pi h$</span>。</li>
</ol>
<p>需要注意的是，立体角计算也可以理解为是所形成表面在以原点为圆心的球的球面上的投影除以半径的平方。因为要计算的立体角表面不一定是球面的一部分，所以需要先投影到球面再进行计算。</p>
]]></content>
      <tags>
        <tag>光学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>考拉兹猜想</title>
    <url>/2019/09/25/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<h1 id="考拉兹猜想">考拉兹猜想</h1>
<h2 id="考拉兹猜想定义">考拉兹猜想定义</h2>
<p>考拉兹函数定义如下</p>
<p><span class="math display">$$
f(x)=\left\{
\begin{array}{**lr**}
3n+1&amp;x为奇数且x\neq1\\
n/2&amp;x为偶数\\
1&amp;x=1
\end{array}
\right.
$$</span> 通过对 <span class="math inline"><em>x</em></span> 取不同的值，发现最后都会收敛到 1。求该函数构成算法的上下界。</p>
<p>当然，下界是很容易求出来的，如果输入 <span class="math inline"><em>n</em></span> ，下降最快的也就是每次下降 <span class="math inline">$\frac{1}{2}$</span>，这个下降速度对于的计算时间是 <span class="math inline">log <em>n</em></span> 。对于上界，用 <span class="math inline"><em>M</em><em>A</em><em>T</em><em>L</em><em>A</em><em>B</em>​</span> 带入一些数值计算。得到的结果如下：</p>
<h2 id="部分-n_0-的步长与-n-值变化">部分 <span class="math inline"><em>n</em><sub>0</sub></span> 的步长与 <span class="math inline"><em>n</em></span> 值变化</h2>
<p><img src="3~6.bmp" /></p>
<figure>
<img src="7~10.bmp" alt="7~10" /><figcaption aria-hidden="true">7~10</figcaption>
</figure>
<figure>
<img src="11~14.bmp" alt="11~14" /><figcaption aria-hidden="true">11~14</figcaption>
</figure>
<figure>
<img src="15~18.bmp" alt="15~18" /><figcaption aria-hidden="true">15~18</figcaption>
</figure>
<figure>
<img src="19~22.bmp" alt="19~22" /><figcaption aria-hidden="true">19~22</figcaption>
</figure>
<figure>
<img src="23~26.bmp" alt="23~26" /><figcaption aria-hidden="true">23~26</figcaption>
</figure>
<figure>
<img src="27~30.bmp" alt="27~30" /><figcaption aria-hidden="true">27~30</figcaption>
</figure>
<figure>
<img src="31~34.bmp" alt="31~34" /><figcaption aria-hidden="true">31~34</figcaption>
</figure>
<figure>
<img src="35~38.bmp" alt="35~38" /><figcaption aria-hidden="true">35~38</figcaption>
</figure>
<figure>
<img src="39~42.bmp" alt="39~42" /><figcaption aria-hidden="true">39~42</figcaption>
</figure>
<figure>
<img src="43~46.bmp" alt="43~46" /><figcaption aria-hidden="true">43~46</figcaption>
</figure>
<figure>
<img src="47~50.bmp" alt="47~50" /><figcaption aria-hidden="true">47~50</figcaption>
</figure>
<figure>
<img src="51~54.bmp" alt="51~54" /><figcaption aria-hidden="true">51~54</figcaption>
</figure>
<figure>
<img src="55~58.bmp" alt="55~58" /><figcaption aria-hidden="true">55~58</figcaption>
</figure>
<figure>
<img src="242~245.bmp" alt="242~245" /><figcaption aria-hidden="true">242~245</figcaption>
</figure>
<h2 id="n_0-与计算次数分布曲线"><span class="math inline"><em>n</em><sub>0</sub></span> 与计算次数分布曲线</h2>
<figure>
<img src="次数与初值.bmp" alt="次数与初值" /><figcaption aria-hidden="true">次数与初值</figcaption>
</figure>
<p><img src="n0=400.bmp" /></p>
<figure>
<img src="n0=1000.bmp" alt="n0=1000" /><figcaption aria-hidden="true">n0=1000</figcaption>
</figure>
<figure>
<img src="n0=5000.bmp" alt="n0=5000" /><figcaption aria-hidden="true">n0=5000</figcaption>
</figure>
<figure>
<img src="n0=10000.bmp" alt="n0=10000" /><figcaption aria-hidden="true">n0=10000</figcaption>
</figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记-场地自动化定标方法研究及应用</title>
    <url>/2019/03/01/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9C%BA%E5%9C%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9A%E6%A0%87%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%9C%BA%E5%9C%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9A%E6%A0%87%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="论文笔记-场地自动化定标方法研究及应用">论文笔记-场地自动化定标方法研究及应用</h1>
<h2 id="辐射定标的意义">辐射定标的意义</h2>
<p>卫星获取地物图像时候，由于存在各种各样的干扰，造成观测值与实际值的偏差，定标就是来（尽可能）消除这些偏差，使得卫星得到的图像与真实的物体之间（尽可能）没有这些偏差，即反映客观事物。</p>
<h3 id="辐射定标">辐射定标</h3>
<h3 id="辐射校正">辐射校正</h3>
<h2 id="遥感辐射定标方法">遥感辐射定标方法</h2>
<p>因为卫星所在环境为外太空，会受到强烈的电磁干扰和强辐射，所以器件的老化程度是很快的，这也就是卫星存在使用寿命的一个原因，受限于载荷的使用寿命。那么要延长载荷的工作年限，就需要实时测出其老化程度，对于传感器的灵敏度做出评估，改变具体参数使得其能够继续工作。比如之前对于输入为 10 就能输出 10 ，现在只能输出 5，就乘以系数 2 就可以完成跟之前一样的功能。这样器件就还可以接着使用。</p>
<span id="more"></span>
<h3 id="发射前定标准备活动">发射前定标（准备活动）</h3>
<p>相当于发射前，在地面上对各个参数进行测定，比如输入 10 输出 10 ，那这个系数就是 1，在发射前就需要记录下来。也就是相当于确定了一个基准，来为后面的调整参数做准备。</p>
<h3 id="运行时定标">运行时定标</h3>
<h4 id="星上定标">星上定标</h4>
<p>卫星运行过程中器件老化，改变参数的过程。星上定标的方法有：</p>
<ol type="1">
<li>灯+积分球</li>
<li>灯+漫反射板</li>
</ol>
<figure>
<img src="星上定标几种方式1.png" alt="定标原理图" /><figcaption aria-hidden="true">定标原理图</figcaption>
</figure>
<p>定标灯在卫星的内部，可以通过由地面的指令频繁进行定标。但是由于灯的光谱和强度与太阳的光谱差别较大，无法真实反映整个系统的变化（那有没有实现复制太阳光谱的生产灯的技术呢？），所以光谱匹配校正增加了定标的不确定性，并且灯也是仪器，也会有一定的衰变，所以精度也会下降。</p>
<ol start="3" type="1">
<li>太阳+漫反射板</li>
<li>太阳+衰减板+漫反射板</li>
</ol>
<figure>
<img src="星上定标几种方式2.png" alt="定标原理图" /><figcaption aria-hidden="true">定标原理图</figcaption>
</figure>
<p>借助太阳的话，就能实现光源的匹配，也就是光源的误差完全被消除了，但是由于需要得到太阳光，所以漫反射板就会暴露在卫星外部。漫反射板材料会在强紫外环境下分解，并且太空中的杂质也容易粘到漫反射板上。衰减板的作用是衰减紫外辐射，减缓漫反射板的分解。</p>
<p>所以，卫星内定标和卫星外定标都有各自的优缺点，卫星内定标主要问题是光源不匹配造成的误差，卫星外定标的主要问题是漫反射板分解造成的误差。</p>
<h4 id="替代定标场地定标">替代定标（场地定标）</h4>
<p>选取可知可测的地物目标作为辐射源（本身的辐射还是对太阳的反射？我的理解是太阳的反射）代替实验室和星上定标器来标定在轨器件的观测数据。因为需要计算的是卫星的表观辐亮度（也就是卫星本来应该测量出的辐亮度值）和卫星的实测辐亮度进行比较。 表观辐亮度需要通过大气传输模型得到，大气传输模型的一个重要的参数就是地表反射率，这也就是为什么我需要测量地表反射率的原因。</p>
<p>主要有三种定标方法：</p>
<ul>
<li><p>反射率基法 在卫星过场地的时候（过顶），测量场地的地表反射率和一些大气参数，通过<code>辐射传输模型</code>计算卫星入瞳处的辐射亮度；卫星上面的仪器也会记录一个遥感图像，通过遥感图像可以卫星测量的入瞳处的辐亮度，二者之间的差距就是需要校正的值，也就是定标系数的确定。</p>
<p>当然在场地的选取方面有要求，需要场地的朗伯特性好（朗伯特性是漫反射好换的评价，也是场地或者材料各向同性属性的评价标准），通过朗伯系数等参数可以计算出地表反射率（猜测应该是朗伯系数越小计算的误差越小，并且有较好的的公式）。</p>
<p>所以地表反射率和大气参数是场地定标需要得到的非常重要的参数。</p></li>
<li><p>辐照度基法 是反射率基法的改进流程与反射率基法基本相同，主要区别是增加了漫-总比的测量。</p></li>
<li><p>辐亮度基法 这个是做一个飞行器，在航空范围内，搭载一台精确定标的辐射计仪器，在卫星过顶的时候保持与卫星对场地的同步几何角度（姿态角等），然后对大气层的影响，将两者标准化到统一的环境下，主要是航空器与卫星的高度不同，而且二者之间有大气，所以需要进行一定的校正，校正完成之后，二者的值应该还是不同的（因为卫星上的仪器的老化），所以这样就可以对卫星上的仪器进行标定系数。 理论上辐亮度基法应该比较准，因为它与卫星之间的距离较小，受到的大气的干扰少，底层大气会由于人类的活动受到较大的干扰。但是由于需要有精密的飞行器和辐射计，并且其要在卫星过顶时与卫星保持一致的几何角度，所以耗资比较大，并且由于航空器需要到达的高度为3km~20km，这个飞行高度有也是客机的飞行高度，所以还需要申请空域。</p></li>
</ul>
<h2 id="人工定标">人工定标</h2>
<h4 id="概览">概览</h4>
<p>首先定标需要得到的结果是计算出辐亮度，把这个辐亮度输入辐射传输模型里面，得到一个本来应该是卫星的辐亮度，叫做表观辐亮度，这个表观辐亮度与卫星上的遥感器的辐亮度比较，就可以得到定标系数，这就完成了定标。</p>
<p>人工定标可以得到实时的地表反射率，所以根据定标流程图，直接计算代入辐射传输模型就可以了。</p>
<p>具体过程如下图所示： <img src="反射率基法.png" alt="反射率基法" /> 从上图可以看到，通过地表反射率、大气参数和气象观测（主要做辅助功能）可以输入辐射传输模型，然后再加上太阳传感器几何测量（得到一些角度值）就可以计算出卫星上面的遥感平台的表观辐亮度，通过与卫星影像（<code>.hdf</code>等带有大量信息的格式文件）做比较就可以得到定标系数。</p>
<p>对于第<span class="math inline"><em>i</em></span>波段光的表观反射率（卫星的表观反射率，但是我觉得好像没什么用，因为只需要测卫星的表观辐亮度就够了吧）有 <span class="math display">$$
\rho^*_i(\theta_v,\theta_s,\phi_v,\phi_s)=\frac{\pi d^2L_i(\theta_v,\theta_s,\phi_v,\phi_s)}{E_{0i\cos\theta}}
$$</span> <span class="math inline"><em>ρ</em><sub><em>i</em></sub><sup>*</sup>(<em>θ</em><sub><em>v</em></sub>,<em>θ</em><sub><em>s</em></sub>,<em>ϕ</em><sub><em>v</em></sub>,<em>ϕ</em><sub><em>s</em></sub>)</span>是对于第<span class="math inline"><em>i</em></span>波段光的地表反射率 <span class="math inline"><em>θ</em><sub><em>s</em></sub></span>是太阳的天顶角 <span class="math inline"><em>ϕ</em><sub><em>s</em></sub></span>是太阳的方位角 <span class="math inline"><em>θ</em><sub><em>v</em></sub></span>是观测天顶角 <span class="math inline"><em>ϕ</em><sub><em>v</em></sub></span>是观测方位角 <span class="math inline"><em>L</em><sub><em>i</em></sub>(<em>θ</em><sub><em>v</em></sub>,<em>θ</em><sub><em>s</em></sub>,<em>ϕ</em><sub><em>v</em></sub>,<em>ϕ</em><sub><em>s</em></sub>)</span>是表观辐亮度 <span class="math inline"><em>E</em><sub>0<em>i</em></sub></span>是日地平均距离处大气层顶的太阳辐照度 <span class="math inline"><em>d</em>​</span>是日地平均距离与实际距离的比值</p>
<p>表观反射率公式如公式（1）所示，各个参数计算如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">计算方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline"><em>θ</em><sub><em>s</em></sub></span>是太阳的天顶角</td>
<td style="text-align: center;">之前论文的公式</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline"><em>ϕ</em><sub><em>s</em></sub></span>是太阳的方位角</td>
<td style="text-align: center;">之前论文的公式</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline"><em>θ</em><sub><em>v</em></sub></span>是观测天顶角</td>
<td style="text-align: center;">测量</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline"><em>ϕ</em><sub><em>v</em></sub></span>是观测方位角</td>
<td style="text-align: center;">测量</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline"><em>L</em><sub><em>i</em></sub>(<em>θ</em><sub><em>v</em></sub>,<em>θ</em><sub><em>s</em></sub>,<em>ϕ</em><sub><em>v</em></sub>,<em>ϕ</em><sub><em>s</em></sub>)</span>是表观辐亮度</td>
<td style="text-align: center;">由地表反射率经过辐射传输模型计算</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline"><em>E</em><sub>0<em>i</em></sub></span>是日地平均距离处大气层顶的太阳辐照度</td>
<td style="text-align: center;">？</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline"><em>d</em></span>是日地平均距离与实际距离的比值</td>
<td style="text-align: center;">之前论文的公式</td>
</tr>
</tbody>
</table>
<h4 id="辐射传输模型">辐射传输模型</h4>
<p>输入参数</p>
<h2 id="自动化定标">自动化定标</h2>
<p>自动化定标也就是不需要人参加，仪器实时计算数据，因为是计算机系统，所以计算出的是离散值，即不断计算特定时刻点的数据。 根据前面的说明，我们要得到的数据是地表反射率和大气参数。由于人工定标可以得到实时的地表反射率，但是仪器不行（为什么？？？）。</p>
<h4 id="使用的仪器">使用的仪器</h4>
<h5 id="asc">ASC</h5>
<p>全天空成像仪（All Sky Cloud，ASC）。用来测量云量数据，判断天气情况是否适合自动化定标。</p>
<h5 id="atr">ATR</h5>
<p>通道式自动化场地辐射计（Automated Test-site Radiometer，ATR）。用来测量地表反射率，输出为<span class="math inline"><em>V</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>，即<span class="math inline"><em>i</em></span>波段的输出电压值。</p>
<h5 id="him">HIM</h5>
<p>超光谱辐照度仪（Hyperspectral Irradiance Meter，HIM）。用来测量漫总比<span class="math inline"><em>α</em></span>，与6S模型输出计算的直射照度一起可以计算出总照度。</p>
<h5 id="psr">PSR</h5>
<p>高精度太阳辐射计（Precision Solar Radiometer，PSR）。用来测量气溶胶的光学厚度。</p>
<h5 id="svc">SVC</h5>
<p>是一台可以精确测量高光谱地表反射率的仪器，主要是用来将ATR从多光谱扩展为高光谱的。</p>
<h4 id="地表反射率">地表反射率</h4>
<p>通过计算地表反射率。公式如下：</p>
<p><span class="math display">$$
\rho_{ATR-i}=\frac{\pi C_{ATR-i}V_{ATR-i}}{E_{总照度}}
$$</span> <span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>是地表反射率 <span class="math inline"><em>C</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>是ATR在<span class="math inline"><em>i</em></span>波段的辐射亮度定标系数，这是个仪器标定值，可以直接得到 <span class="math inline"><em>V</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>是ATR在<span class="math inline"><em>i</em></span>波段的输出电压值，这是仪器输出值 <span class="math inline"><em>E</em><sub><em>总</em><em>照</em><em>度</em></sub></span>由HIM仪器得到漫总比，再经过6S模型输出直射照度，由直射照度除以直总比得到总照度 <span class="math display">$$
E_{总照度}=\frac{E_{直射照度}}{1-\alpha}
$$</span> <span class="math inline"><em>α</em></span>为漫总比，由HIM得到。</p>
<p>但是由于仪器是通道式的（8通道），所以只能获得在八个波长对应的地表反射率<span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>，但是卫星测量的却是高光谱（也就是一段波长内的辐亮度<span class="math inline"><em>L</em><sub><em>r</em><em>e</em><em>a</em><em>l</em> − <em>s</em><em>e</em><em>g</em><em>m</em><em>e</em><em>n</em><em>t</em></sub></span>），所以我需要把通道式的<span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span>扩展到和卫星同波段的<span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − <em>s</em><em>e</em><em>g</em><em>m</em><em>e</em><em>n</em><em>t</em></sub>​</span>代入传输模型。</p>
<p>获取高光谱地表反射率的过程如下图所示。</p>
<p>其中SVC只需要定期测量，因为模型是建立在SVC的变化在短时间内很小的前提下。所以在测量一次SVC进行ATR多光谱扩展之后，之后按照SVC测量出的高光谱曲线来生成ATR的扩展即可。即从<span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em></sub></span>这条参考线上下平移到多光谱ATR仪器的八个点处，保持尽可能小的误差，这个上下平移的距离为<span class="math inline"><em>k</em></span>。</p>
<p>前面已经计算出了在某一时刻八个通道的地表反射率<span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − 1</sub>​</span>到<span class="math inline"><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − 8</sub>​</span>。当然平移也就是同时对高光谱的地表防反射率乘以一个系数，造成曲线的上下移动。即：</p>
<p><span class="math display"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>i</em></sub> = <em>η</em><sub><em>i</em></sub><em>ρ</em><sub><em>A</em><em>T</em><em>R</em> − <em>i</em></sub></span></p>
<p>在确定平移因子之前，首先通过敦煌校正场的 <code>BRDF</code>模型要对光的入射方向做一次校正，这个入射方向的校正的是因为卫星过顶时得到的数据和仪器测量的数据的时间不一定完全一致，这就导致了入射角的微小差异，所以需要将仪器测量点时刻的入射角方向校正到卫星测量时刻的入射角。校正公式： <span class="math display">$$
\rho(\lambda,\theta_2,0^\circ,0^\circ)=\frac{R(\lambda,\theta_2,0^\circ,0^\circ)}{R(\lambda,\theta_1,0^\circ,0^\circ)}\cdot\rho(\lambda,\theta_1,0^\circ,0^\circ)
$$</span></p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>,<em>θ</em><sub>2</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>卫星过顶时刻的参考反射率</p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>,<em>θ</em><sub>1</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>仪器测量时刻的参考反射率</p>
<p><span class="math inline"><em>R</em>(<em>λ</em>,<em>θ</em><sub>2</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>是BRDF模型计算的反射率</p>
<p><span class="math inline"><em>R</em>(<em>λ</em>,<em>θ</em><sub>1</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>是BRDF模型计算的反射率</p>
<p>采用<span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em><sub><em>i</em></sub></sub></span>与参考曲线<span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em></sub></span>的偏差的加权平均和来确定高光谱地表反射率的平移距离。平移引子<span class="math inline"><em>k</em></span>由下式计算 <span class="math display">$$
W=\sqrt{\sum_{i=1}^8\frac{1}{\sigma_i}(\rho_{i}-(k+\rho_{SVC-Ref-i}))^2}
$$</span></p>
<p><span class="math inline"><em>i</em></span>是波段</p>
<p><span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>是对应<span class="math inline"><em>i</em></span>波段的反射率，这个是由ATR测量得到的八个值</p>
<p><span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em> − <em>i</em></sub></span>是参考反射率<span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em></sub></span>在波段<span class="math inline"><em>i</em>​</span>处的取值</p>
<p><span class="math inline"><em>σ</em><sub><em>i</em></sub></span>是<span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>的标准偏差（这个应该是通道反射率，即由 ATR 测量的八个通道的反射率）</p>
<p><span class="math inline"><em>k</em>​</span>是平移的大小</p>
<p><span class="math inline"><em>W</em></span>是用来确定<span class="math inline"><em>k</em></span>的，<span class="math inline"><em>W</em></span>的取值最小处就是<span class="math inline"><em>k</em></span>的取值处</p>
<p><img src="高光谱地表反射率.png" /></p>
<p>从上图看出，红线就是SVC测量的值，这个值隔一段时间测量一次即可，八个黑点就是ATR在当前时刻测量的值，通过前面的，通过公式（6）的计算得到平移距离<span class="math inline"><em>k</em></span>之后，将红线平移就可以得到蓝线（即目标曲线）。</p>
<p>这个时候完成的工作就是得到了实时高光谱反射率。是地面的反射率，但是还有一个问题，就是现在得到的地面反射率，是入射角为卫星过顶时刻的太阳天顶角，出射方向是测量时刻的仪器对应的观测角度，现在需要的是得到卫星过顶时刻的出射角，所以还需要进行一次BRDF校正，这次是对出射方向做的BRDF校正，(这个公式怎么写？？)</p>
<p><span class="math display">$$
\rho(\lambda,\theta_2,0^\circ,0^\circ)=\frac{R(\lambda,\theta_2,0^\circ,0^\circ)}{R(\lambda,\theta_1,0^\circ,0^\circ)}\cdot\rho(\lambda,\theta_1,0^\circ,0^\circ)
$$</span></p>
<p>现在这个<span class="math inline"><em>ρ</em></span>是ATR每个测量时刻得到的高光谱通道反射率，接下来进行出射校正</p>
<p><span class="math display">$$
\rho_i=\frac{\int_{\lambda_{1}}^{\lambda_{2}}\rho(\lambda)R_i(\lambda)d\lambda}{\int_{\lambda_{1}}^{\lambda_{2}}R_i(\lambda)d\lambda}
$$</span></p>
<p><span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>是对应卫星<span class="math inline"><em>i</em></span>通道的BRDF出射校正的反射率</p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>)</span>是得到的高光谱曲线</p>
<p><span class="math inline"><em>R</em>(<em>λ</em>)​</span>是对应<span class="math inline"><em>i</em>​</span>通道的光谱响应函数</p>
<p>这样也就得到了对应卫星的<span class="math inline"><em>i</em></span>通道的经过BRDF校正之后的地表反射率，当然，这时候的时刻就是卫星过顶时刻的表观反射率。</p>
<p><img src="每日的通道反射率.png" /></p>
<p>即完成了流程图中的<code>Surface Reflectance measurement</code>参数就得到了。</p>
<h4 id="大气参数">大气参数</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">臭氧</td>
<td style="text-align: center;">下载</td>
</tr>
<tr class="even">
<td style="text-align: center;">气溶胶光学厚度AOD</td>
<td style="text-align: center;">PSR反演</td>
</tr>
<tr class="odd">
<td style="text-align: center;">水汽</td>
<td style="text-align: center;">下载或者计算</td>
</tr>
<tr class="even">
<td style="text-align: center;">太阳天顶角</td>
<td style="text-align: center;">直接获取</td>
</tr>
<tr class="odd">
<td style="text-align: center;">太阳方位角</td>
<td style="text-align: center;">直接获取</td>
</tr>
<tr class="even">
<td style="text-align: center;">仪器观测天顶角</td>
<td style="text-align: center;">直接获取</td>
</tr>
<tr class="odd">
<td style="text-align: center;">仪器观测方位角</td>
<td style="text-align: center;">直接获取</td>
</tr>
</tbody>
</table>
<h4 id="计算表观反射率和表观辐亮度">计算表观反射率和表观辐亮度</h4>
<p>输入大气传输模型6S，得到表观反射率（即卫星上本来应该是的反射率）和表观辐亮度。</p>
<h4 id="定标">定标</h4>
<p>得到表观反射率TOA（Top Of Atmosphere）之后，得到表观反射率和表观辐亮度，与卫星的实测的反射率和辐亮度做比较就可以得到定标系数。</p>
<h3 id="小结">小结</h3>
<p><img src="流程.bmp" /></p>
<p>其中比较重要的操作是在<code>数据处理2</code>中的三步 1. BRDF入射角校正 2. 光谱扩展 3. BRDF出射校正</p>
<p>下面就来看一下这些处理。</p>
<h3 id="计算中的一些处理">计算中的一些处理</h3>
<h4 id="brdf校正">*BRDF校正</h4>
<p>BRDF模型如下：</p>
<p><span class="math display"><em>R</em>(<em>λ</em>,<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>) = <em>f</em><sub><em>i</em><em>s</em><em>o</em></sub>(<em>λ</em>) + <em>f</em><sub><em>v</em><em>o</em><em>l</em></sub>(<em>λ</em>)<em>K</em><sub><em>v</em><em>o</em><em>l</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>) + <em>f</em><sub><em>g</em><em>e</em><em>o</em></sub>(<em>λ</em>)<em>K</em><sub><em>g</em><em>e</em><em>o</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>)</span></p>
<p><span class="math inline"><em>R</em>(<em>λ</em>,<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>)</span>是二向反射比</p>
<p><span class="math inline"><em>K</em><sub><em>v</em><em>o</em><em>l</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>)​</span>是体散射核</p>
<p><span class="math inline"><em>K</em><sub><em>g</em><em>e</em><em>o</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>)​</span>是几何光学散射核</p>
<p><span class="math inline"><em>K</em><sub><em>v</em><em>o</em><em>l</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>), <em>K</em><sub><em>g</em><em>e</em><em>o</em></sub>(<em>θ</em><sub><em>s</em></sub>,<em>θ</em><sub><em>v</em></sub>,<em>ϕ</em>)​</span>均只与观测几何条件有关</p>
<p><span class="math inline"><em>f</em><sub><em>i</em><em>s</em><em>o</em></sub>, <em>f</em><sub><em>v</em><em>o</em><em>l</em></sub>, <em>f</em><sub><em>g</em><em>e</em><em>o</em></sub></span>均是系数，分别叫做波长<span class="math inline"><em>λ</em></span>处的各向同性散射系数、体散射系数和几何光学散射系数。</p>
<p><span class="math inline"><em>θ</em><sub><em>s</em></sub>​</span>是太阳天顶角</p>
<p><span class="math inline"><em>θ</em><sub><em>v</em></sub>​</span>是观测天顶角</p>
<p><span class="math inline"><em>ϕ</em></span>相对方位角</p>
<h5 id="brdf入射校正">BRDF入射校正</h5>
<p><span class="math display">$$
\rho(\lambda,\theta_2,0^\circ,0^\circ)=\frac{R(\lambda,\theta_2,0^\circ,0^\circ)}{R(\lambda,\theta_1,0^\circ,0^\circ)}\cdot\rho(\lambda,\theta_1,0^\circ,0^\circ)
$$</span></p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>,<em>θ</em><sub>2</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>卫星过顶时刻的参考反射率</p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>,<em>θ</em><sub>1</sub>,0<sup>∘</sup>,0<sup>∘</sup>)</span>仪器测量时刻的参考反射率</p>
<p><span class="math inline"><em>R</em>(<em>λ</em>,<em>θ</em><sub>2</sub>,0<sup>∘</sup>,0<sup>∘</sup>)​</span>是BRDF模型计算的反射率，在卫星测量的太阳天顶角<span class="math inline"><em>θ</em><sub>2</sub>​</span>，观测角<span class="math inline">0<sup>∘</sup>​</span></p>
<p><span class="math inline"><em>R</em>(<em>λ</em>,<em>θ</em><sub>1</sub>,0<sup>∘</sup>,0<sup>∘</sup>)</span>是BRDF模型计算的反射率，在仪器测量的太阳天顶角<span class="math inline"><em>θ</em><sub>1</sub></span>，观测角<span class="math inline">0<sup>∘</sup></span></p>
<h5 id="brdf出射校正">BRDF出射校正</h5>
<p>$$</p>
<p>_i= $$</p>
<p><span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>是对应卫星<span class="math inline"><em>i</em></span>通道的BRDF出射校正的反射率</p>
<p><span class="math inline"><em>ρ</em>(<em>λ</em>)</span>是得到的高光谱曲线</p>
<p><span class="math inline"><em>R</em>(<em>λ</em>)​</span>是对应<span class="math inline"><em>i</em>​</span>通道的光谱响应函数</p>
<h4 id="光谱扩展">光谱扩展</h4>
<p><span class="math display">$$
W=\sqrt{\sum_{i=1}^8\frac{1}{\sigma_i}(\rho_{i}-(k+\rho_{SVC-Ref-i}))^2}
$$</span></p>
<p><span class="math inline"><em>i</em></span>是波段</p>
<p><span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>是对应<span class="math inline"><em>i</em></span>波段的反射率，这个是由ATR测量得到的八个值</p>
<p><span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em> − <em>i</em></sub></span>是参考反射率<span class="math inline"><em>ρ</em><sub><em>S</em><em>V</em><em>C</em> − <em>R</em><em>e</em><em>f</em></sub></span>在波段<span class="math inline"><em>i</em></span>处的取值</p>
<p><span class="math inline"><em>σ</em><sub><em>i</em></sub></span>是<span class="math inline"><em>ρ</em><sub><em>i</em></sub></span>的标准偏差（这个应该是通道反射率，即由 ATR 测量的八个通道的反射率）</p>
<p><span class="math inline"><em>k</em></span>是平移的大小</p>
<p><span class="math inline"><em>W</em></span>是用来确定<span class="math inline"><em>k</em></span>的，<span class="math inline"><em>W</em></span>的取值最小处就是<span class="math inline"><em>k</em></span>的取值处</p>
<p>即求函数<span class="math inline"><em>W</em>(<em>k</em>)​</span>取极小值时<span class="math inline"><em>k</em>​</span>的大小。</p>
<h4 id="s传输模型">*6S传输模型</h4>
<p>6S的源码是用FORTRAN来写的，想要对6S有所了解，还是要有一定的FORTRAN基础。由于作者是法国人，有很多变量缩写也是以法文为缩写的，不要望文生义。</p>
<p><strong>第一节 6S简介</strong></p>
<p>所谓6S是SECOND SIMULATION OF THE SATELLITE SIGNAL IN THE SOLAR SPECTRUM的简写，直译的意思就是<strong>“太阳光谱的卫星信号二次模拟”</strong>。其前身为法国里尔科技大学大气光学实验室开发的5S（SIMULATION OF THE SATELLITE SIGNAL IN THESOLAR SPECTRUM）大气辐射传输模型。在遥感观测的太阳-目标-传感器这种模式中，无论是使用卫星或是飞机，获取数据的过程中都不可避免的受到大气的影响。<strong>6S就是为了模拟这种地气系统中的太阳辐射，计算卫星入瞳处的辐射能量</strong>。通过这种模拟，我们就可以知道大气对太阳辐射的影响大小，由此来进行大气校正。</p>
<p><strong>注：我的理解，6S是遥感用于对地气系统进行模拟的正演用的软件，而不是用于“大气校正”的软件，只不过正演结果往往被用于大气校正。当然也不仅仅是输出“表观辐亮度”这个正演结果，还有正演过程中所得到的有关大气一系列量。</strong></p>
<p>6S假定晴空无云的条件下，并考虑了水汽、CO2、O3和O2等的吸收、分子和气溶胶的散射以及非均一地面和双向反射率的问题。相比与5S，6S可以模拟机载观测、设置目标高程、解释BRDF作用和临近效应，增加了新的吸收气体的计算（CO、N2O、CH4），对于瑞利和气溶胶散射的计算由于使用了逐级散射(successive order of scattering)方法，精度有了显著提升，并且光谱积分的步长从5nm改进到2.5nm。6S所能处理的光谱区间为0.25微米至4微米，低于0.25或高于4的都无法运算。缺点是对球形大气和limb (临边)观测不能处理。</p>
<p>目前国内大部分使用的都是1997年发布的标量版本，版本号一般为6SV4，在2005年Vermote等人又发布了一个矢量版本，版本号一般为6sV-1.0。相对于标量版本，矢量又做了很多改进，最明显的就是可以对于偏振进行处理。在本文中，主要介绍标量版本的使用，如果有时间，后续会再介绍矢量版本。</p>
<p>最后在后面说下，很多人都以为6S是一个软件，直接将图像输入，设置一些参数之后就可以获得大气校正过的影像了。其实这是一个完全错误的想法，原始的6S只是一个是使用Fortran写出来的一堆代码而已，而且也不能读取影像。可能大家使用的时候都是使用别人生成的EXE程序，在DOS界面里对各种参数进行输入。</p>
<p><strong>第二节 6S使用</strong></p>
<p>6S需要9个输入参数，对于这些参数都是必须仔细了解的，使用起来才能保证不会出错。学习都是一个由浅及深的过程，要努力做到知其然更知其所以然，通过对6S的学习能做到对辐射传输的公式以及推导有一个完善的了解，那么才是真正掌握了6S的使用。对于各参数下面将会一一介绍。</p>
<ol type="1">
<li><p>第一步需要输入的为几何参数igeom，其中有8情况，当选择igeom=0时，需要手动输入太阳高度角、方位角，卫星高度角、方位角以及影像获取月份与日期。剩下的7种为内置的一些卫星参数，如AVHRR、TM、GOES等，大部分都是需要输入日期，行列号等。</p></li>
<li><p>第二步为大气模式idatm的选择，6S里内置了0-6共其中大气模式，依次为无大气吸收，热带，中纬度夏季，中纬度冬季，亚寒带夏季，亚寒带冬季以及美国标准62大气模式，或者选择自定义大气廓线，选择7的话，需要输入海拔，压强，温度，水汽浓度，臭氧浓度。选择8需要输入水汽与臭氧浓度，大气廓线使用美国62。</p></li>
<li><p>第三步为选择气溶胶模式iaer，内置了7中标准气溶胶模式，为0-无气溶胶模式，1-大陆型，2-海洋型，3-城市型，5-沙漠背景的shettle模型，6-生物燃烧模型，7-平流层模型。或者自定义自己的气溶胶模式，当iaer=4时，需要输入各组分的百分比：粉状尘，水溶性物质，海洋性物质，煤烟。8为最多四种模型联合运算的一个正态分布模型。9为改进型的一种伽马分布模型。10为Junge谱幂分布模型。11为选择太阳光度计的测量值进行计算，12为读取已经设定好的参数进行计算。一般情况下如果不想做气溶胶的模式研究，就直接用刚开始介绍的7个标准模式。</p></li>
<li><p>第四步为气溶胶浓度，关于这个由两种输入方式，气溶胶光学厚度taer55或者可见度v。可见度v的单位为千米，如选择光学厚度taer55，可见度v的值就为0，taer55为550纳米处的气溶胶光学厚度。在气溶胶模式iaer中如果选择无气溶胶，可见度v的值就要为-1。其中气溶胶光学厚度与可见度有一个公式可以转换，为了快速计算，也可以使用4.8除光学厚度得到可见度，但这只是一个约值。</p></li>
<li><p>第五步为目标海拔高度xps的计算，如果xps&gt;=0，那么表示目标在水平面上。xps&lt;0表明你知道地面的高程，所以输入具体的值，不过前面加个负号。</p></li>
<li><p>第六步为传感器Xpp高度的输入，xpp=-1000 表明传感器为星载传感器，xpp=0 表明传感器在地面上。-100</p></li>
<li><p>第七步为光谱条件iwave的输入，其中6S内置了很多传感器的光谱条件，如MODIS，TM，AVHRR，SPOT，NOAA等。也可以使用自定义的光谱条件。其中光谱响应函数的计算是以2.5微米为间隔。</p></li>
</ol>
<p>iinf=(wlinf-.25)/0.0025+1.5 为起始光谱值</p>
<p>isup=(wlsup-.25)/0.0025+1.5 为结束光谱值</p>
<p>由于6S所支持的光谱区间为0.25-4，代入上式iinf=(0.25-.25)/0.0025+1.5 =1.5=1，isup=(4-.25)/0.0025+1.5=1501.5=1501。所以6S所能处理的所有光谱曲线就位1-1501条。以TM数据蓝光波段为例，其光谱范围为0.430-0.560，代入上式可以得到iinf=(0.430-.25)/0.0025+1.5=73，isup=(0.56-.25)/0.0025+1.5=125，在TM的光谱响应曲线的就可以看做前72个数值为0，后1376个也为0值。</p>
<p>在6S之中，计算各种参数的时候，尤其是在计算光谱响应的起始与结束值时，定义的为整型，但计算结果可能会为一个小数，这就要考虑截断了，FORTRAN中并没有使用四舍五入的情况，而是直接取整。</p>
<p>对于6S没有内置的一些光谱响应也就可以自己按照这个规则来写一个Fortran文件。</p>
<p>第八步为地表特性的选择，这是一个比较复杂的选项，可以选择地面作为朗伯体或者各向异性来构建BRDF。下图为6S中给出的选择路径。</p>
<p>inhomo选择0代表地表是考虑地面为朗伯体，选择1代表地表各向异性。如果inhomo=0进入第二步的选择，再次选择0表明没有方向效应的影响，然后输入roe（表面反射比）。选择1表明有方向效应的影响，然后选择内置的一些BRDF模型来进行计算。如果inhomo=1，那么接着输入igrou1（roc）（目标的反射）、igrou2（roe）（周围环境反射）、radius r（表面半径）。</p>
<p>最后一步为选择rapp大气校正模型，如果rapp&lt;-1那么就不进行大气改正，这就为遥感之中的正演，即为通过地表反射率来求得表观反射率。如果rapp&gt;0 程序将重新赋值表观反射率，使用输入的这个辐射亮度值进行表观反射率的转换。当-1</p>
<p>上面的介绍，其实还是很抽象的，想要了解6S，就必须自己动手去做。</p>
]]></content>
      <tags>
        <tag>光学</tag>
        <tag>遥感</tag>
      </tags>
  </entry>
</search>
